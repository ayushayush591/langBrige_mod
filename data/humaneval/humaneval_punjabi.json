{"task_id":"HumanEval\/0","prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" ਜਾਂਚੋ ਕਿ ਦਿੱਤੀ ਗਈ ਸੰਖਿਆਵਾਂ ਦੀ ਸੂਚੀ ਵਿੱਚ, ਕੀ ਕੋਈ ਦੋ ਸੰਖਿਆਵਾਂ ਇੱਕ-ਦੂਜੇ ਦੇ ਨਾਲੋਂ ਦਿੱਤੀ ਗਈ ਸੀਮਾ ਤੋਂ ਵੱਧ ਨੇੜੇ ਹਨ।\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n","canonical_solution":"    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n","entry_point":"has_close_elements"}
{"task_id":"HumanEval\/1","prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" ਇਸ ਫੰਕਸ਼ਨ ਵਿੱਚ ਇੰਪੁੱਟ ਇੱਕ ਸਟਰਿੰਗ ਹੈ ਜਿਸ ਵਿੱਚ ਕਈ ਗਰੁੱਪ ਹਨ ਜੋ ਨੈਸਟਿਡ ਪੈਰੇਂਥੀਸਿਸ ਨਾਲ ਬਣੇ ਹੋਏ ਹਨ। ਤੁਹਾਡਾ ਮਕਸਦ ਹੈ ਕਿ\n    ਇਨ੍ਹਾਂ ਗਰੁੱਪਾਂ ਨੂੰ ਵੱਖ-ਵੱਖ ਸਟਰਿੰਗਾਂ ਵਿੱਚ ਵੱਖ ਕਰੋ ਅਤੇ ਉਹਨਾਂ ਦੀ ਸੂਚੀ ਵਾਪਸ ਕਰੋ।\n    ਵੱਖਰੇ ਗਰੁੱਪ ਸੰਤੁਲਿਤ ਹਨ (ਹਰ ਖੁੱਲ੍ਹਾ ਬ੍ਰੈਸ ਠੀਕ ਤਰ੍ਹਾਂ ਬੰਦ ਹੈ) ਅਤੇ ਇੱਕ ਦੂਜੇ ਦੇ ਅੰਦਰ ਨੈਸਟਿਡ ਨਹੀਂ ਹਨ\n    ਇੰਪੁੱਟ ਸਟਰਿੰਗ ਵਿੱਚ ਕਿਸੇ ਵੀ ਖਾਲੀ ਥਾਂ ਨੂੰ ਨਜ਼ਰਅੰਦਾਜ਼ ਕਰੋ।\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n","canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n","entry_point":"separate_paren_groups"}
{"task_id":"HumanEval\/2","prompt":"\ndef truncate_number(number: float) -> float:\n    \"\"\" ਇੱਕ ਸਕਾਰਾਤਮਕ ਫਲੋਟਿੰਗ ਪੁਆਇੰਟ ਨੰਬਰ ਨੂੰ ਦੋ ਭਾਗਾਂ ਵਿੱਚ ਵੰਡਿਆ ਜਾ ਸਕਦਾ ਹੈ\n    ਇੱਕ ਪੂਰਨ ਅੰਕ (ਦਿੱਤੇ ਗਏ ਨੰਬਰ ਤੋਂ ਵੱਡਾ ਸਭ ਤੋਂ ਵੱਡਾ ਪੂਰਨ ਅੰਕ) ਅਤੇ ਦਸਮਲਵ\n    (ਬਾਕੀ ਬਚਿਆ ਹਿੱਸਾ ਹਮੇਸ਼ਾ 1 ਤੋਂ ਘੱਟ)।\n\n    ਨੰਬਰ ਦਾ ਦਸਮਲਵ ਭਾਗ ਵਾਪਸ ਕਰੋ।\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n","canonical_solution":"    return number % 1.0\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n","entry_point":"truncate_number"}
{"task_id":"HumanEval\/3","prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" ਤੁਹਾਨੂੰ ਇੱਕ ਬੈਂਕ ਖਾਤੇ ਦੇ ਜਮਾ ਅਤੇ ਚੱਕ ਕਰਨ ਵਾਲੇ ਓਪਰੇਸ਼ਨਾਂ ਦੀ ਸੂਚੀ ਦਿੱਤੀ ਗਈ ਹੈ ਜੋ ਕਿ ਜ਼ੀਰੋ ਬੈਲੈਂਸ ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦੀ ਹੈ। ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਪਤਾ ਲਗਾਉਣਾ ਹੈ ਕਿ ਕੀ ਕਿਸੇ ਵੀ ਸਮੇਂ ਖਾਤੇ ਦਾ ਬੈਲੈਂਸ ਜ਼ੀਰੋ ਤੋਂ ਹੇਠਾਂ ਚਲਾ ਜਾਂਦਾ ਹੈ, ਅਤੇ ਉਸ ਸਮੇਂ ਫੰਕਸ਼ਨ ਨੂੰ True ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ। ਨਹੀਂ ਤਾਂ ਇਸ ਨੂੰ False ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ।\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n","canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n","entry_point":"below_zero"}
{"task_id":"HumanEval\/4","prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" ਦਿੱਤੀ ਗਈ ਸੰਖਿਆਵਾਂ ਦੀ ਸੂਚੀ ਲਈ, ਇਸ ਡੇਟਾਸੈੱਟ ਦੇ ਔਸਤ ਦੇ ਆਲੇ-ਦੁਆਲੇ ਔਸਤ ਸਰਾਬ ਵਿਚਲਨ ਦੀ ਗਣਨਾ ਕਰੋ।\n    ਔਸਤ ਸਰਾਬ ਵਿਚਲਨ ਹਰੇਕ ਅੰਸ਼ ਅਤੇ ਇੱਕ ਕੇਂਦਰ ਬਿੰਦੂ (ਇਸ ਮਾਮਲੇ ਵਿੱਚ ਔਸਤ) ਵਿਚਕਾਰ ਔਸਤ ਸਰਾਬ ਅੰਤਰ ਹੈ:\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n","canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n","entry_point":"mean_absolute_deviation"}
{"task_id":"HumanEval\/5","prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" ਇਨਪੁੱਟ ਸੂਚੀ `numbers` ਦੇ ਹਰ ਦੋ ਲਗਾਤਾਰ ਤੱਤਾਂ ਵਿਚਕਾਰ 'delimeter' ਨੰਬਰ ਪਾਓ\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n","canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n","entry_point":"intersperse"}
{"task_id":"HumanEval\/6","prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" ਇਸ ਫੰਕਸ਼ਨ ਦੇ ਇਨਪੁਟ ਵਿੱਚ ਕਈ ਗਰੁੱਪ ਹਨ ਜੋ ਵੱਖ-ਵੱਖ ਨੈਸਟਿਡ ਪੈਰੇਂਥਿਸਿਸ ਨਾਲ ਬਣੇ ਹੋਏ ਹਨ ਅਤੇ ਸਪੇਸਿਸ ਨਾਲ ਵੱਖ ਕੀਤੇ ਗਏ ਹਨ।\n    ਹਰੇਕ ਗਰੁੱਪ ਲਈ, ਪੈਰੇਂਥਿਸਿਸ ਦੇ ਸਭ ਤੋਂ ਗੂੜ੍ਹੇ ਪੱਧਰ ਦੀ ਨੈਸਟਿੰਗ ਦਾ ਆਉਟਪੁਟ ਦਿਓ।\n    ਉਦਾਹਰਣ ਵਜੋਂ, (()()) ਵਿੱਚ ਅਧਿਕਤਮ ਦੋ ਪੱਧਰ ਦੀ ਨੈਸਟਿੰਗ ਹੈ ਜਦਕਿ ((())) ਵਿੱਚ ਤਿੰਨ ਹਨ।\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n","canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n","entry_point":"parse_nested_parens"}
{"task_id":"HumanEval\/7","prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" ਇਨਪੁੱਟ ਲਿਸਟ ਵਿੱਚੋਂ ਸਿਰਫ ਉਹ ਸਟਰਿੰਗਸ ਫਿਲਟਰ ਕਰੋ ਜੋ ਦਿੱਤੀ ਗਈ ਸਬਸਟਰਿੰਗ ਨੂੰ ਸਮੋਹਣ\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n","canonical_solution":"    return [x for x in strings if substring in x]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n","entry_point":"filter_by_substring"}
{"task_id":"HumanEval\/8","prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" ਦਿੱਤੀ ਗਈ ਪੂਰੀ ਸੰਖਿਆਵਾਂ ਦੀ ਸੂਚੀ ਲਈ, ਸੂਚੀ ਵਿੱਚ ਸਾਰੀਆਂ ਪੂਰੀ ਸੰਖਿਆਵਾਂ ਦੇ ਜੋੜ ਅਤੇ ਗੁਣਨਫਲ ਵਾਲੀ ਇੱਕ ਜੋੜੀ ਵਾਪਸ ਕਰੋ।\n    ਖਾਲੀ ਜੋੜ ਨੂੰ 0 ਦੇ ਬਰਾਬਰ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ ਅਤੇ ਖਾਲੀ ਗੁਣਨਫਲ ਨੂੰ 1 ਦੇ ਬਰਾਬਰ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ।\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n","canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n","entry_point":"sum_product"}
{"task_id":"HumanEval\/9","prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" ਦਿੱਤੀ ਗਈ ਪੂਰਨਾਂਕਾਂ ਦੀ ਸੂਚੀ ਤੋਂ, ਉਸ ਸਮੇਂ ਤੱਕ ਸਿਲਸਿਲੇ ਵਿੱਚ ਮਿਲੇ ਅਧਿਕਤਮ ਤੱਤ ਦੀ ਇੱਕ ਸੂਚੀ ਤਿਆਰ ਕਰੋ।\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n","canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n","entry_point":"rolling_max"}
{"task_id":"HumanEval\/10","prompt":"\ndef is_palindrome(string: str) -> bool:\n    \"\"\" ਜਾਂਚ ਕਰੋ ਕਿ ਦਿੱਤੀ ਗਈ ਸਟਰਿੰਗ ਇੱਕ ਪੈਲਿੰਡਰੋਮ ਹੈ ਜਾਂ ਨਹੀਂ \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" ਉਸ ਸਟਰਿੰਗ ਨਾਲ ਸ਼ੁਰੂ ਹੋਣ ਵਾਲੇ ਸਭ ਤੋਂ ਛੋਟੇ ਪੈਲਿੰਡਰੋਮ ਨੂੰ ਲੱਭੋ।\n    ਐਲਗੋਰਿਦਮ ਦਾ ਵਿਚਾਰ ਸਧਾਰਣ ਹੈ:\n    - ਦਿੱਤੀ ਗਈ ਸਟਰਿੰਗ ਦੇ ਸਭ ਤੋਂ ਲੰਬੇ ਪੋਸਟਫਿਕਸ ਨੂੰ ਲੱਭੋ ਜੋ ਕਿ ਪੈਲਿੰਡਰੋਮ ਹੈ।\n    - ਪੈਲਿੰਡਰੋਮਿਕ ਸਫਿਕਸ ਤੋਂ ਪਹਿਲਾਂ ਆਉਣ ਵਾਲੀ ਸਟਰਿੰਗ ਪ੍ਰੀਫਿਕਸ ਦੇ ਉਲਟ ਨੂੰ ਸਟਰਿੰਗ ਦੇ ਅੰਤ ਵਿੱਚ ਜੋੜੋ।\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"","canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n","entry_point":"make_palindrome"}
{"task_id":"HumanEval\/11","prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" ਇਨਪੁਟ ਵਿੱਚ ਦੋ ਸਟਰਿੰਗਸ a ਅਤੇ b ਹਨ ਜੋ ਕੇਵਲ 1 ਅਤੇ 0 ਦੇ ਬਣੇ ਹੋਏ ਹਨ।\n    ਇਨ੍ਹਾਂ ਇਨਪੁਟਾਂ 'ਤੇ ਬਾਇਨਰੀ XOR ਕਾਰਵਾਈ ਕਰੋ ਅਤੇ ਨਤੀਜਾ ਵੀ ਸਟਰਿੰਗ ਦੇ ਰੂਪ ਵਿੱਚ ਵਾਪਸ ਕਰੋ।\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n","canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n","entry_point":"string_xor"}
{"task_id":"HumanEval\/12","prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" ਸਟਰਿੰਗਾਂ ਦੀ ਸੂਚੀ ਵਿੱਚੋਂ, ਸਭ ਤੋਂ ਲੰਬੀ ਸਟਰਿੰਗ ਨੂੰ ਵਾਪਸ ਕਰੋ। ਜੇਕਰ ਕਈ ਸਟਰਿੰਗਾਂ ਦੀ ਲੰਬਾਈ ਇੱਕੋ ਜਿਹੀ ਹੋਵੇ, ਤਾਂ ਪਹਿਲੀ ਨੂੰ ਵਾਪਸ ਕਰੋ। ਜੇਕਰ ਇੰਪੁੱਟ ਸੂਚੀ ਖਾਲੀ ਹੋਵੇ ਤਾਂ None ਵਾਪਸ ਕਰੋ।\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n","canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n","entry_point":"longest"}
{"task_id":"HumanEval\/13","prompt":"\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" ਦੋ ਪੂਰਨਾਂਕ ਅਤੇ ਬੀ ਦੇ ਸਭ ਤੋਂ ਵੱਡੇ ਸਾਂਝੇ ਭਾਜਕ ਨੂੰ ਵਾਪਸ ਕਰੋ\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"","canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n","entry_point":"greatest_common_divisor"}
{"task_id":"HumanEval\/14","prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" ਇਨਪੁੱਟ ਸਟਰਿੰਗ ਦੇ ਸਭ ਤੋਂ ਛੋਟੇ ਤੋਂ ਲੈ ਕੇ ਸਭ ਤੋਂ ਲੰਬੇ ਤੱਕ ਦੇ ਸਾਰੇ ਪ੍ਰੀਫਿਕਸਾਂ ਦੀ ਸੂਚੀ ਮੁੜਤੀ ਦਿਓ\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n","canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n","entry_point":"all_prefixes"}
{"task_id":"HumanEval\/15","prompt":"def string_sequence(n: int) -> str:\n    \"\"\" 0 ਤੋਂ ਸ਼ੁਰੂ ਹੋ ਕੇ n ਤੱਕ ਸਪੇਸ-ਵਿੱਚਕਾਰ ਵਾਲੇ ਨੰਬਰਾਂ ਵਾਲੀ ਇੱਕ ਸਟਰਿੰਗ ਮੁੜਾਓ।\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"","canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n","entry_point":"string_sequence"}
{"task_id":"HumanEval\/16","prompt":"def count_distinct_characters(string: str) -> int:\n    \"\"\" ਇੱਕ ਸਟਰਿੰਗ ਦਿੱਤੀ ਗਈ ਹੈ, ਪਤਾ ਲਗਾਓ ਕਿ ਇਸ ਵਿੱਚ ਕਿੰਨੇ ਵੱਖਰੇ ਅੱਖਰ (ਕੇਸ ਦੀ ਪਰਵਾਹ ਕੀਤੇ ਬਿਨਾਂ) ਹਨ\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"","canonical_solution":"    return len(set(string.lower()))\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n","entry_point":"count_distinct_characters"}
{"task_id":"HumanEval\/17","prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" ਇਸ ਫੰਕਸ਼ਨ ਵਿੱਚ ਇੰਪੁੱਟ ਇੱਕ ਸਟਰਿੰਗ ਹੈ ਜੋ ਖਾਸ ASCII ਫਾਰਮੈਟ ਵਿੱਚ ਸੰਗੀਤ ਦੇ ਨੋਟਾਂ ਨੂੰ ਦਰਸਾਉਂਦੀ ਹੈ।\n    ਤੁਹਾਡਾ ਕੰਮ ਇਸ ਸਟਰਿੰਗ ਨੂੰ ਪਾਰਸ ਕਰਨਾ ਹੈ ਅਤੇ ਉਹ ਸੂਚੀ ਵਾਪਸ ਕਰਨਾ ਹੈ ਜੋ ਹਰੇਕ ਨੋਟ ਦੇ ਬੀਟਾਂ ਦੀ ਗਿਣਤੀ ਨੂੰ ਦਰਸਾਉਂਦੀ ਹੈ।\n\n    ਇੱਥੇ ਇੱਕ ਕਿਵਦੰਤੀ ਹੈ:\n    'o' - ਪੂਰਾ ਨੋਟ, ਚਾਰ ਬੀਟਾਂ ਤਕ ਰਹਿੰਦਾ ਹੈ\n    'o|' - ਅੱਧਾ ਨੋਟ, ਦੋ ਬੀਟਾਂ ਤਕ ਰਹਿੰਦਾ ਹੈ\n    '.|' - ਚੌਥਾਈ ਨੋਟ, ਇੱਕ ਬੀਟ ਤਕ ਰਹਿੰਦਾ ਹੈ\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n","canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n","entry_point":"parse_music"}
{"task_id":"HumanEval\/18","prompt":"def how_many_times(string: str, substring: str) -> int:\n    \"\"\" ਪਤਾ ਲਗਾਓ ਕਿ ਦਿੱਤੀ ਗਈ ਸਬਸਟਰਿੰਗ ਮੂਲ ਸਟਰਿੰਗ ਵਿੱਚ ਕਿੰਨੀ ਵਾਰ ਮਿਲਦੀ ਹੈ। ਓਵਰਲੈਪਿੰਗ ਮਾਮਲਿਆਂ ਦੀ ਗਿਣਤੀ ਕਰੋ।\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"","canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n","entry_point":"how_many_times"}
{"task_id":"HumanEval\/19","prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" ਇੰਪੁੱਟ ਇੱਕ ਸਪੇਸ-ਵਿਖਾਲਾ ਵਾਲੀ ਸਟਰਿੰਗ ਹੈ ਜਿਸ ਵਿੱਚ 'zero' ਤੋਂ 'nine' ਤੱਕ ਦੇ ਨੰਬਰ ਸ਼ਬਦ ਹਨ।\n    ਵੈਧ ਚੋਣਾਂ 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' ਅਤੇ 'nine' ਹਨ।\n    ਸਭ ਤੋਂ ਛੋਟੇ ਤੋਂ ਸਭ ਤੋਂ ਵੱਡੇ ਤੱਕ ਨੰਬਰਾਂ ਨੂੰ ਸੋਰਟ ਕਰਕੇ ਸਟਰਿੰਗ ਵਾਪਸ ਕਰੋ\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n","canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n","entry_point":"sort_numbers"}
{"task_id":"HumanEval\/20","prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" ਦਿੱਤੀ ਗਈ ਸੰਖਿਆਵਾਂ ਦੀ ਸੂਚੀ ਵਿੱਚੋਂ (ਘੱਟੋ ਘੱਟ ਦੋ ਦੀ ਲੰਬਾਈ ਨਾਲ) ਦੋ ਅਜਿਹੀਆਂ ਚੁਣੋ ਅਤੇ ਵਾਪਸ ਕਰੋ ਜੋ ਇੱਕ ਦੂਜੇ ਦੇ ਸਭ ਤੋਂ ਨੇੜੇ ਹੋਣ ਅਤੇ ਉਹਨਾਂ ਨੂੰ ਕ੍ਰਮ ਅਨੁਸਾਰ ਵਾਪਸ ਕਰੋ (ਛੋਟੀ ਸੰਖਿਆ, ਵੱਡੀ ਸੰਖਿਆ)।\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n","canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n","entry_point":"find_closest_elements"}
{"task_id":"HumanEval\/21","prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" ਦਿੱਤੀ ਗਈ ਸੰਖਿਆਵਾਂ ਦੀ ਸੂਚੀ (ਘੱਟੋ ਘੱਟ ਦੋ ਅੰਸ਼ ਵਾਲੀ), ਉਸ ਸੂਚੀ ਉੱਤੇ ਰੇਖਿਕ ਪਰਿਵਰਤਨ ਲਾਗੂ ਕਰੋ,\n    ਜਿਸ ਨਾਲ ਸਭ ਤੋਂ ਛੋਟੀ ਸੰਖਿਆ 0 ਬਣ ਜਾਵੇਗੀ ਅਤੇ ਸਭ ਤੋਂ ਵੱਡੀ 1 ਬਣ ਜਾਵੇਗੀ\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n","canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n","entry_point":"rescale_to_unit"}
{"task_id":"HumanEval\/22","prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" ਕਿਸੇ ਵੀ ਪਾਇਥਨ ਮੁੱਲਾਂ ਦੀ ਦਿੱਤੀ ਗਈ ਸੂਚੀ ਵਿੱਚੋਂ ਸਿਰਫ ਪੂਰਨਾਂਕਾਂ ਲਈ ਫਿਲਟਰ ਕਰੋ\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n","canonical_solution":"    return [x for x in values if isinstance(x, int)]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n","entry_point":"filter_integers"}
{"task_id":"HumanEval\/23","prompt":"def strlen(string: str) -> int:\n    \"\"\" ਦਿੱਤੀ ਗਈ ਸਟਰਿੰਗ ਦੀ ਲੰਬਾਈ ਵਾਪਸ ਕਰੋ\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"","canonical_solution":"    return len(string)\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n","entry_point":"strlen"}
{"task_id":"HumanEval\/24","prompt":"\ndef largest_divisor(n: int) -> int:\n    \"\"\" ਦਿੱਤੀ ਗਈ ਸੰਖਿਆ n ਲਈ, ਉਸ ਸੰਖਿਆ ਨੂੰ ਲੱਭੋ ਜੋ n ਨੂੰ ਬਰਾਬਰ ਵੰਡਦੀ ਹੈ, n ਤੋਂ ਛੋਟੀ ਹੈ\n    >>> largest_divisor(15)\n    5\n    \"\"\"","canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n","entry_point":"largest_divisor"}
{"task_id":"HumanEval\/25","prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" ਦਿੱਤੀ ਗਈ ਪੂਰਨ ਸੰਖਿਆ ਦੇ ਅਭਿਨ ਗੁਣਕਾਂ ਦੀ ਸੂਚੀ ਨੂੰ ਸਭ ਤੋਂ ਛੋਟੇ ਤੋਂ ਲੈ ਕੇ ਸਭ ਤੋਂ ਵੱਡੇ ਕ੍ਰਮ ਵਿੱਚ ਵਾਪਸ ਕਰੋ।\n    ਹਰੇਕ ਗੁਣਕ ਨੂੰ ਉਸ ਗਿਣਤੀ ਵਿੱਚ ਸੂਚੀਬੱਧ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਜੋ ਗੁਣਨਫਲ ਵਿੱਚ ਉਸ ਦੇ ਆਉਣ ਦੀ ਗਿਣਤੀ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ।\n    ਇਨਪੁਟ ਨੰਬਰ ਸਾਰੇ ਗੁਣਕਾਂ ਦੇ ਗੁਣਨਫਲ ਕੇ ਬਰਾਬਰ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n","canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n","entry_point":"factorize"}
{"task_id":"HumanEval\/26","prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" ਪੂਰੀਆਂ ਸੰਖਿਆਵਾਂ ਦੀ ਸੂਚੀ ਤੋਂ, ਉਹ ਸਾਰੇ ਅੰਕ ਹਟਾਓ ਜੋ ਇੱਕ ਤੋਂ ਵੱਧ ਵਾਰ ਆਉਂਦੇ ਹਨ।\n    ਬਚੇ ਹੋਏ ਅੰਕਾਂ ਦੀ ਕ੍ਰਮ ਉਸੇ ਤਰ੍ਹਾਂ ਰੱਖੋ ਜਿਵੇਂ ਕਿ ਇਨਪੁਟ ਵਿੱਚ ਹੈ।\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n","canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n","entry_point":"remove_duplicates"}
{"task_id":"HumanEval\/27","prompt":"def flip_case(string: str) -> str:\n    \"\"\" ਦਿੱਤੀ ਗਈ ਸਟਰਿੰਗ ਲਈ, ਛੋਟੇ ਅੱਖਰਾਂ ਨੂੰ ਵੱਡਾ ਅਤੇ ਵੱਡੇ ਅੱਖਰਾਂ ਨੂੰ ਛੋਟਾ ਕਰੋ।\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"","canonical_solution":"    return string.swapcase()\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n","entry_point":"flip_case"}
{"task_id":"HumanEval\/28","prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" ਸਟਰਿੰਗਾਂ ਦੀ ਸੂਚੀ ਨੂੰ ਇੱਕ ਸਿੰਗਲ ਸਟਰਿੰਗ ਵਿੱਚ ਜੋੜੋ\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n","canonical_solution":"    return ''.join(strings)\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n","entry_point":"concatenate"}
{"task_id":"HumanEval\/29","prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" ਇੱਕ ਦਿੱਤੀ ਗਈ ਪ੍ਰੀਫਿਕਸ ਨਾਲ ਸ਼ੁਰੂ ਹੋਣ ਵਾਲੀਆਂ ਸਟਰਿੰਗਾਂ ਲਈ ਇੱਕ ਇੰਪੁੱਟ ਸਟਰਿੰਗ ਲਿਸਟ ਨੂੰ ਫਿਲਟਰ ਕਰੋ।\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n","canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n","entry_point":"filter_by_prefix"}
{"task_id":"HumanEval\/30","prompt":"\ndef get_positive(l: list):\n    \"\"\"ਸੂਚੀ ਵਿੱਚੋਂ ਸਿਰਫ ਪੌਜ਼ੀਟਿਵ ਨੰਬਰਾਂ ਨੂੰ ਵਾਪਸ ਕਰੋ.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n","canonical_solution":"    return [e for e in l if e > 0]\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n","entry_point":"get_positive"}
{"task_id":"HumanEval\/31","prompt":"\ndef is_prime(n):\n    \"\"\"ਜੇਕਰ ਦਿੱਤਾ ਗਿਆ ਨੰਬਰ ਪ੍ਰਾਈਮ ਹੈ ਤਾਂ ਸੱਚ ਵਾਪਸ ਕਰੋ, ਨਹੀਂ ਤਾਂ ਝੂਠ।\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"","canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n","entry_point":"is_prime"}
{"task_id":"HumanEval\/32","prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    ਇਹ ਫੰਕਸ਼ਨ ਬਿੰਦੂ x 'ਤੇ xs ਗੁਣਾਂਕਾਂ ਵਾਲੇ ਬਹੁਪਦ ਦਾ ਮੁੱਲਾਂਕਣ ਕਰਦਾ ਹੈ।\n    ਇਹ xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n ਨੂੰ ਵਾਪਸ ਕਰਦਾ ਹੈ।\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs ਬਹੁਪਦ ਦੇ ਗੁਣਾਂਕ ਹਨ।\n    find_zero ਅਜਿਹਾ x ਲੱਭਦਾ ਹੈ ਜਿਸ ਲਈ poly(x) = 0 ਹੋਵੇ।\n    ਜੇਕਰ ਬਹੁਤ ਸਾਰੇ ਸ਼ੂਨਯ ਬਿੰਦੂ ਹਨ, ਤਾਂ find_zero ਕੇਵਲ ਇੱਕ ਸ਼ੂਨਯ ਬਿੰਦੂ ਹੀ ਵਾਪਸ ਕਰਦਾ ਹੈ।\n    ਇਸ ਤੋਂ ਇਲਾਵਾ, find_zero ਕੇਵਲ ਉਹ xs ਸੂਚੀ ਲੈਂਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਗੁਣਾਂਕਾਂ ਦੀ ਸੰਖਿਆ ਸਮਾਨ ਹੋਵੇ\n    ਅਤੇ ਸਭ ਤੋਂ ਵੱਡਾ ਗੈਰ-ਜ਼ੀਰੋ ਗੁਣਾਂਕ ਹੋਵੇ ਕਿਉਂਕਿ ਇਹ ਹੱਲ ਦੀ ਗਰੰਟੀ ਦਿੰਦਾ ਹੈ।\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n","canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n","entry_point":"find_zero"}
{"task_id":"HumanEval\/33","prompt":"def sort_third(l: list):\n    \"\"\"ਇਹ ਫੰਕਸ਼ਨ ਇੱਕ ਸੂਚੀ l ਲੈਂਦਾ ਹੈ ਅਤੇ ਇੱਕ ਸੂਚੀ l' ਵਾਪਸ ਕਰਦਾ ਹੈ ਇਸ ਤਰ੍ਹਾਂ ਕਿ\n    l' l ਨਾਲ ਉਹਨਾਂ ਸੂਚਕਾਂ ਤੇ ਇਕੋ ਜਿਹੀ ਹੈ ਜੋ ਤਿੰਨ ਨਾਲ ਵੰਡਣਯੋਗ ਨਹੀਂ ਹਨ, ਜਦਕਿ ਉਸਦੇ ਮੁੱਲ ਜੋ ਸੂਚਕਾਂ ਤੇ ਹਨ ਜੋ ਤਿੰਨ ਨਾਲ ਵੰਡਣਯੋਗ ਹਨ\n    l ਦੇ ਅਨੁਰੂਪ ਸੂਚਕਾਂ ਦੇ ਮੁੱਲਾਂ ਦੇ ਬਰਾਬਰ ਹਨ, ਪਰ ਸੋਰਟ ਕੀਤੇ ਗਏ ਹਨ।\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n","canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n","entry_point":"sort_third"}
{"task_id":"HumanEval\/34","prompt":"\ndef unique(l: list):\n    \"\"\"ਇੱਕ ਸੂਚੀ ਵਿੱਚੋਂ ਵੱਖਰੇ ਅਤੇ ਸੋਰਟ ਕੀਤੇ ਹੋਏ ਅਨੋਖੇ ਤੱਤ ਮੁੜ ਪ੍ਰਾਪਤ ਕਰੋ\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n","canonical_solution":"    return sorted(list(set(l)))\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n","entry_point":"unique"}
{"task_id":"HumanEval\/35","prompt":"\ndef max_element(l: list):\n    \"\"\"ਸੂਚੀ ਵਿੱਚੋਂ ਅਧਿਕਤਮ ਤੱਤ ਮੁੜ ਪ੍ਰਾਪਤ ਕਰੋ.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"","canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n","entry_point":"max_element"}
{"task_id":"HumanEval\/36","prompt":"\ndef fizz_buzz(n: int):\n    \"\"\"n ਤੋਂ ਘੱਟ ਅੰਕਾਂ ਵਿੱਚ 7 ਦੇ ਅੰਕ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰੋ ਜੋ 11 ਜਾਂ 13 ਨਾਲ ਵੰਡਣਯੋਗ ਹਨ।\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n","canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n","entry_point":"fizz_buzz"}
{"task_id":"HumanEval\/37","prompt":"def sort_even(l: list):\n    \"\"\"ਇਹ ਫੰਕਸ਼ਨ ਇੱਕ ਸੂਚੀ l ਲੈਂਦਾ ਹੈ ਅਤੇ ਇੱਕ ਸੂਚੀ l' ਵਾਪਸ ਕਰਦਾ ਹੈ ਇਸ ਤਰ੍ਹਾਂ ਕਿ\n    l' l ਦੇ ਅਜੀਬ ਸੂਚਕਾਂ ਵਿੱਚ ਇਕੋ ਜਿਹੀ ਹੈ, ਜਦਕਿ ਇਸਦੇ ਮੁੱਲ ਸਮਾਨ ਸੂਚਕਾਂ ਵਿੱਚ ਬਰਾਬਰ ਹਨ\n    l ਦੇ ਸਮਾਨ ਸੂਚਕਾਂ ਦੇ ਮੁੱਲਾਂ ਨੂੰ, ਪਰ ਸੋਰਟ ਕੀਤਾ ਗਿਆ।\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n","canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n","entry_point":"sort_even"}
{"task_id":"HumanEval\/38","prompt":"def encode_cyclic(s: str):\n    \"\"\"\n    ਤਿੰਨ ਅੱਖਰਾਂ ਦੇ ਗਰੁੱਪਾਂ ਨੂੰ ਸਾਈਕਲ ਕਰਕੇ ਕੋਡਿਤ ਸਟਰਿੰਗ ਵਾਪਸ ਕਰਦਾ ਹੈ।\n    \"\"\"\n    # ਸਟਰਿੰਗ ਨੂੰ ਗਰੁੱਪਾਂ ਵਿੱਚ ਵੰਡੋ। ਹਰੇਕ ਦੀ ਲੰਬਾਈ 3 ਹੋਵੇ।\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # ਹਰੇਕ ਗਰੁੱਪ ਵਿੱਚ ਤੱਤਾਂ ਨੂੰ ਸਾਈਕਲ ਕਰੋ। ਜੇ ਗਰੁੱਪ ਵਿੱਚ ਤਿੰਨ ਤੋਂ ਘੱਟ ਤੱਤ ਹਨ ਤਾਂ ਨਾ ਕਰੋ।\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    ਇਨਪੁੱਟ ਵਜੋਂ ਕੋਡਿਤ ਸਟਰਿੰਗ ਲੈਂਦਾ ਹੈ ਜੋ ਕਿ encode_cyclic ਫੰਕਸ਼ਨ ਨਾਲ ਕੋਡਿਤ ਹੈ। ਕੋਡ ਮੁਕਤ ਸਟਰਿੰਗ ਵਾਪਸ ਕਰਦਾ ਹੈ।\n    \"\"\"","canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n","entry_point":"decode_cyclic"}
{"task_id":"HumanEval\/39","prompt":"\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib ਫੰਕਸ਼ਨ n-ਵੇਂ ਨੰਬਰ ਨੂੰ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੋ ਕਿ ਫਿਬੋਨਾਚੀ ਨੰਬਰ ਹੈ ਅਤੇ ਇਹ ਪ੍ਰਾਈਮ ਵੀ ਹੈ।\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n","canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n","entry_point":"prime_fib"}
{"task_id":"HumanEval\/40","prompt":"def triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero ਇੱਕ ਪੂਰਨਾਂਕਾਂ ਦੀ ਸੂਚੀ ਨੂੰ ਇੰਪੁੱਟ ਵਜੋਂ ਲੈਂਦਾ ਹੈ।\n    ਜੇ ਸੂਚੀ ਵਿੱਚ ਤਿੰਨ ਵੱਖਰੇ ਅੰਕ ਹਨ ਜੋ ਜੋੜ ਕੇ ਜ਼ੀਰੋ ਬਣਾਉਂਦੇ ਹਨ, ਤਾਂ ਇਹ True ਵਾਪਸ ਕਰਦਾ ਹੈ, ਅਤੇ ਨਹੀਂ ਤਾਂ False।\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n","canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n","entry_point":"triples_sum_to_zero"}
{"task_id":"HumanEval\/41","prompt":"\ndef car_race_collision(n: int):\n    \"\"\"\n    ਕਲਪਨਾ ਕਰੋ ਕਿ ਇੱਕ ਸੜਕ ਹੈ ਜੋ ਇੱਕ ਬਿਲਕੁਲ ਸਿੱਧੀ ਅਨੰਤ ਲੰਬੀ ਰੇਖਾ ਹੈ।\n    n ਕਾਰਾਂ ਖੱਬੇ ਤੋਂ ਸੱਜੇ ਵੱਲ ਚਲ ਰਹੀਆਂ ਹਨ; ਇਸੇ ਸਮੇਂ, ਵੱਖਰੇ ਸੈੱਟ ਦੀਆਂ n ਕਾਰਾਂ\n    ਸੱਜੇ ਤੋਂ ਖੱਬੇ ਵੱਲ ਚਲ ਰਹੀਆਂ ਹਨ। ਦੋ ਸੈੱਟਾਂ ਦੀਆਂ ਕਾਰਾਂ ਇੱਕ-ਦੂਜੇ ਤੋਂ ਬਹੁਤ ਦੂਰ ਹਨ।\n    ਸਾਰੀਆਂ ਕਾਰਾਂ ਇੱਕੋ ਗਤੀ ਨਾਲ ਚੱਲ ਰਹੀਆਂ ਹਨ। ਦੋ ਕਾਰਾਂ ਦੇ ਟੱਕਰਾਉਣ ਦੀ ਗੱਲ ਤਦੋਂ ਕਹੀ ਜਾਂਦੀ ਹੈ\n    ਜਦੋਂ ਇੱਕ ਕਾਰ ਜੋ ਖੱਬੇ ਤੋਂ ਸੱਜੇ ਵੱਲ ਜਾ ਰਹੀ ਹੈ ਉਹ ਇੱਕ ਕਾਰ ਨਾਲ ਟੱਕਰਾ ਜਾਂਦੀ ਹੈ ਜੋ ਸੱਜੇ ਤੋਂ ਖੱਬੇ ਵੱਲ ਜਾ ਰਹੀ ਹੈ।\n    ਪਰ, ਕਾਰਾਂ ਬੇਹੱਦ ਮਜ਼ਬੂਤ ਅਤੇ ਸਖਤ ਹਨ; ਨਤੀਜਤਨ, ਉਹ ਆਪਣੇ ਰਸਤੇ 'ਤੇ ਉਸੇ ਤਰ੍ਹਾਂ ਚੱਲਦੀਆਂ ਰਹਿੰਦੀਆਂ ਹਨ\n    ਜਿਵੇਂ ਕਿ ਉਹ ਟੱਕਰਾਈਆਂ ਨਾ ਹੋਣ।\n\n    ਇਹ ਫੰਕਸ਼ਨ ਅਜਿਹੀਆਂ ਟੱਕਰਾਂ ਦੀ ਗਿਣਤੀ ਦੇਂਦਾ ਹੈ।\n    \"\"\"\n","canonical_solution":"    return n**2\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n","entry_point":"car_race_collision"}
{"task_id":"HumanEval\/42","prompt":"def incr_list(l: list):\n    \"\"\"ਇਸ ਲਿਸਟ ਵਿੱਚ ਹਰ ਤੱਤ ਨੂੰ 1 ਨਾਲ ਵਧਾ ਕੇ ਵਾਪਸ ਕਰੋ।\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n","canonical_solution":"    return [(e + 1) for e in l]\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n","entry_point":"incr_list"}
{"task_id":"HumanEval\/43","prompt":"\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero ਇੱਕ ਪੂਰਨਾਂਕਾਂ ਦੀ ਸੂਚੀ ਨੂੰ ਇੰਪੁੱਟ ਵਜੋਂ ਲੈਂਦਾ ਹੈ।\n    ਜੇ ਸੂਚੀ ਵਿੱਚ ਦੋ ਵੱਖਰੇ ਅੰਕ ਹਨ ਜੋ ਜੋੜ ਕੇ ਜ਼ੀਰੋ ਬਣਾਉਂਦੇ ਹਨ, ਤਾਂ ਇਹ True ਵਾਪਸ ਕਰਦਾ ਹੈ, ਅਤੇ ਨਹੀਂ ਤਾਂ False।\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n","canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n","entry_point":"pairs_sum_to_zero"}
{"task_id":"HumanEval\/44","prompt":"def change_base(x: int, base: int):\n    \"\"\"ਇਨਪੁੱਟ ਨੰਬਰ x ਦਾ ਅੰਕੀ ਆਧਾਰ base 'ਤੇ ਬਦਲੋ।\n    ਤਬਦੀਲੀ ਤੋਂ ਬਾਅਦ ਦੀ ਸਟਰਿੰਗ ਨੂੰਮਾਂਦਗੀ ਵਾਪਸ ਕਰੋ।\n    ਆਧਾਰ ਨੰਬਰ 10 ਤੋਂ ਘੱਟ ਹਨ।\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"","canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n","entry_point":"change_base"}
{"task_id":"HumanEval\/45","prompt":"\ndef triangle_area(a, h):\n    \"\"\"ਇੱਕ ਪਾਸੇ ਦੀ ਲੰਬਾਈ ਅਤੇ ਉਚਾਈ ਦਿੱਤੀ ਗਈ ਹੈ, ਤਿਕੋਣ ਦੇ ਖੇਤਰਫਲ ਨੂੰ ਵਾਪਸ ਕਰੋ।\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n","canonical_solution":"    return a * h \/ 2.0\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n","entry_point":"triangle_area"}
{"task_id":"HumanEval\/46","prompt":"\ndef fib4(n: int):\n    \"\"\"Fib4 ਨੰਬਰ ਲੜੀ ਇੱਕ ਅਜਿਹੀ ਲੜੀ ਹੈ ਜੋ ਫਿਬੋਨੈਚੀ ਲੜੀ ਵਾਂਗ ਹੈ ਜਿਸਦੀ ਪਰਿਭਾਸ਼ਾ ਇਸ ਤਰ੍ਹਾਂ ਹੈ:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    ਕਿਰਪਾ ਕਰਕੇ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ fib4 ਨੰਬਰ ਲੜੀ ਦੇ n-ਵੇਂ ਅੰਕ ਨੂੰ ਕੁਸ਼ਲਤਾ ਨਾਲ ਗਣਨਾ ਕਰੇ। ਮੁੜਾਵਰਤੀ (recursion) ਦੀ ਵਰਤੋਂ ਨਾ ਕਰੋ।\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"","canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n","entry_point":"fib4"}
{"task_id":"HumanEval\/47","prompt":"\ndef median(l: list):\n    \"\"\"ਲਿਸਟ l ਵਿੱਚ ਮੌਜੂਦ ਤੱਤਾਂ ਦਾ ਮੱਧ ਮੁੱਲ ਵਾਪਸ ਕਰੋ.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"","canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n","entry_point":"median"}
{"task_id":"HumanEval\/48","prompt":"\ndef is_palindrome(text: str):\n    \"\"\"\n    ਜਾਂਚਦਾ ਹੈ ਕਿ ਦਿੱਤੀ ਗਈ ਸਟਰਿੰਗ ਇੱਕ ਪੈਲਿੰਡਰੋਮ ਹੈ ਜਾਂ ਨਹੀਂ\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n","canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n","entry_point":"is_palindrome"}
{"task_id":"HumanEval\/49","prompt":"\ndef modp(n: int, p: int):\n    \"\"\"2^n ਨੂੰ p ਨਾਲ ਮੋਡੂਲੋ ਕਰਕੇ ਵਾਪਸ ਕਰੋ (ਅੰਕੜਾਸ਼ਾਸਤਰ ਦਾ ਧਿਆਨ ਰੱਖੋ)।\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n","canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n","entry_point":"modp"}
{"task_id":"HumanEval\/50","prompt":"\ndef encode_shift(s: str):\n    \"\"\"\n    ਹਰੇਕ ਅੱਖਰ ਨੂੰ ਵਰਣਮਾਲਾ ਵਿੱਚ 5 ਨਾਲ ਸ਼ਿਫਟ ਕਰਕੇ ਐਨਕੋਡ ਕੀਤੀ ਸਟਰਿੰਗ ਨੂੰ ਵਾਪਸ ਕਰਦਾ ਹੈ।\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    ਇਨਪੁਟ ਵਜੋਂ ਐਨਕੋਡ_ਸ਼ਿਫਟ ਫੰਕਸ਼ਨ ਨਾਲ ਐਨਕੋਡ ਕੀਤੀ ਗਈ ਸਟਰਿੰਗ ਲੈਂਦਾ ਹੈ। ਡੀਕੋਡ ਕੀਤੀ ਸਟਰਿੰਗ ਨੂੰ ਵਾਪਸ ਕਰਦਾ ਹੈ।\n    \"\"\"\n","canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n","entry_point":"decode_shift"}
{"task_id":"HumanEval\/51","prompt":"\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels ਇੱਕ ਫੰਕਸ਼ਨ ਹੈ ਜੋ ਸਟਰਿੰਗ ਲੈਂਦਾ ਹੈ ਅਤੇ ਵਾਪਸ ਸਟਰਿੰਗ ਬਿਨਾਂ ਸਵਰਾਂ ਦੇ ਦਿੰਦਾ ਹੈ।\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n","canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n","entry_point":"remove_vowels"}
{"task_id":"HumanEval\/52","prompt":"\ndef below_threshold(l: list, t: int):\n    \"\"\"ਜੇ ਸਾਰੇ ਨੰਬਰ ਸੂਚੀ l ਵਿੱਚ ਸੀਮਾ t ਤੋਂ ਹੇਠਾਂ ਹਨ ਤਾਂ True ਪਰਤਾਓ।\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n","canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n","entry_point":"below_threshold"}
{"task_id":"HumanEval\/53","prompt":"def add(x: int, y: int):\n    \"\"\"ਦੋ ਨੰਬਰ x ਅਤੇ y ਨੂੰ ਜੋੜੋ\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"","canonical_solution":"    return x + y\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n","entry_point":"add"}
{"task_id":"HumanEval\/54","prompt":"\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    ਜਾਂਚੋ ਕਿ ਦੋ ਸ਼ਬਦਾਂ ਵਿੱਚ ਇੱਕੋ ਜਿਹੇ ਅੱਖਰ ਹਨ ਜਾਂ ਨਹੀਂ।\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n","canonical_solution":"    return set(s0) == set(s1)\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n","entry_point":"same_chars"}
{"task_id":"HumanEval\/55","prompt":"\ndef fib(n: int):\n    \"\"\"n-ਵੀਂ ਫਿਬੋਨਾਚੀ ਸੰਖਿਆ ਮੁੜ ਪ੍ਰਾਪਤ ਕਰੋ.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"","canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n","entry_point":"fib"}
{"task_id":"HumanEval\/56","prompt":"def correct_bracketing(brackets: str):\n    \"\"\" brackets ਇੱਕ \"<\" ਅਤੇ \">\" ਦੀਆਂ ਸਟਰਿੰਗਾਂ ਹਨ।\n    ਜੇ ਹਰ ਖੁੱਲ੍ਹੇ ਬ੍ਰੈਕਟ ਦਾ ਮੇਲ ਬੰਦ ਬ੍ਰੈਕਟ ਨਾਲ ਹੈ ਤਾਂ True ਵਾਪਸ ਕਰੋ।\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n","canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n","entry_point":"correct_bracketing"}
{"task_id":"HumanEval\/57","prompt":"\ndef monotonic(l: list):\n    \"\"\"ਜੇ ਲਿਸਟ ਦੇ ਤੱਤ ਇਕਸਾਰ ਵਧਦੇ ਜਾਂ ਘਟਦੇ ਹਨ ਤਾਂ True ਮੁੜਾਓ।\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"","canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n","entry_point":"monotonic"}
{"task_id":"HumanEval\/58","prompt":"\ndef common(l1: list, l2: list):\n    \"\"\"ਦੋ ਸੂਚੀਆਂ ਲਈ ਕ੍ਰਮਬੱਧ ਅਨੋਖੇ ਸਾਂਝੇ ਤੱਤ ਪਰਤਾਓ।\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"","canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n","entry_point":"common"}
{"task_id":"HumanEval\/59","prompt":"\ndef largest_prime_factor(n: int):\n    \"\"\"n ਦਾ ਸਭ ਤੋਂ ਵੱਡਾ ਪ੍ਰਾਈਮ ਫੈਕਟਰ ਮੁੜ ਕੇ ਦਿਓ। ਮੰਨ ਲਵੋ ਕਿ n > 1 ਹੈ ਅਤੇ ਪ੍ਰਾਈਮ ਨਹੀਂ ਹੈ।\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n","canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n","entry_point":"largest_prime_factor"}
{"task_id":"HumanEval\/60","prompt":"def sum_to_n(n: int):\n    \"\"\"sum_to_n ਇੱਕ ਫੰਕਸ਼ਨ ਹੈ ਜੋ 1 ਤੋਂ n ਤੱਕ ਦੇ ਨੰਬਰਾਂ ਦਾ ਜੋੜ ਕਰਦਾ ਹੈ।\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"","canonical_solution":"    return sum(range(n + 1))\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n","entry_point":"sum_to_n"}
{"task_id":"HumanEval\/61","prompt":"def correct_bracketing(brackets: str):\n    \"\"\" brackets ਇੱਕ ਸਟਰਿੰਗ ਹੈ ਜਿਸ ਵਿੱਚ \"(\" ਅਤੇ \")\" ਹਨ।\n    ਜੇ ਹਰ ਖੁੱਲ੍ਹਾ ਬ੍ਰੈਕਟ ਦਾ ਮੇਲ ਬੰਦ ਬ੍ਰੈਕਟ ਨਾਲ ਹੈ ਤਾਂ True ਮੁੜਾਓ।\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"","canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n","entry_point":"correct_bracketing"}
{"task_id":"HumanEval\/62","prompt":"def derivative(xs: list):\n    \"\"\" xs ਇੱਕ ਬਹੁਪਦੀ ਦੇ ਗੁਣਾਂਕ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ।\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     ਇਸ ਬਹੁਪਦੀ ਦਾ ਵਿਅੱਖ ਇਸੇ ਰੂਪ ਵਿੱਚ ਵਾਪਸ ਕਰੋ।\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n","canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n","entry_point":"derivative"}
{"task_id":"HumanEval\/63","prompt":"def fibfib(n: int):\n    \"\"\"FibFib ਨੰਬਰ ਲੜੀ ਇੱਕ ਅਜਿਹੀ ਲੜੀ ਹੈ ਜੋ ਕਿ Fibbonacci ਲੜੀ ਵਾਂਗ ਹੈ ਜਿਸਦੀ ਪਰਿਭਾਸ਼ਾ ਇਸ ਤਰ੍ਹਾਂ ਹੈ:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    ਕਿਰਪਾ ਕਰਕੇ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਕਿ fibfib ਨੰਬਰ ਲੜੀ ਦੇ n-ਵੇਂ ਅੰਕ ਨੂੰ ਕੁਸ਼ਲਤਾ ਨਾਲ ਗਣਨਾ ਕਰੇ।\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"","canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n","entry_point":"fibfib"}
{"task_id":"HumanEval\/64","prompt":"FIX = \"\"\"\nਹੋਰ ਟੈਸਟ ਕੇਸ ਜੋੜੋ।\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"ਇੱਕ ਫੰਕਸ਼ਨ vowels_count ਲਿਖੋ ਜੋ ਇੱਕ ਸਟਰਿੰਗ ਨੂੰ ਇੰਪੁੱਟ ਵਜੋਂ ਲੈਂਦਾ ਹੈ ਜੋ ਕਿ ਇੱਕ ਸ਼ਬਦ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ ਅਤੇ ਸਟਰਿੰਗ ਵਿੱਚ ਮੌਜੂਦ ਸਵਰਾਂ ਦੀ ਗਿਣਤੀ ਨੂੰ ਵਾਪਸ ਕਰਦਾ ਹੈ।\n    ਇਸ ਮਾਮਲੇ ਵਿੱਚ ਸਵਰ 'a', 'e', 'i', 'o', 'u' ਹਨ। ਇੱਥੇ, 'y' ਵੀ ਇੱਕ ਸਵਰ ਹੈ, ਪਰ ਸਿਰਫ ਤਦ ਜਦੋਂ ਇਹ ਦਿੱਤੇ ਗਏ ਸ਼ਬਦ ਦੇ ਅੰਤ ਵਿੱਚ ਹੋਵੇ।\n\n    ਉਦਾਹਰਣ:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"","canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"vowels_count"}
{"task_id":"HumanEval\/65","prompt":"def circular_shift(x, shift):\n    \"\"\"ਪੂਰਨ ਸੰਖਿਆ x ਦੇ ਅੰਕਾਂ ਨੂੰ ਚੱਕਰਦਾਰ ਸ਼ਿਫਟ ਕਰੋ, ਅੰਕਾਂ ਨੂੰ ਸੱਜੇ ਪਾਸੇ shift ਦੁਆਰਾ ਸ਼ਿਫਟ ਕਰੋ\n    ਅਤੇ ਨਤੀਜਾ ਇੱਕ ਸਟਰਿੰਗ ਵਜੋਂ ਵਾਪਸ ਕਰੋ।\n    ਜੇਕਰ shift > ਅੰਕਾਂ ਦੀ ਗਿਣਤੀ, ਤਾਂ ਅੰਕਾਂ ਨੂੰ ਉਲਟਾ ਕਰ ਕੇ ਵਾਪਸ ਕਰੋ।\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"","canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"circular_shift"}
{"task_id":"HumanEval\/66","prompt":"def digitSum(s):\n    \"\"\"ਟਾਸਕ\n    ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੰਪੁੱਟ ਵਜੋਂ ਇੱਕ ਸਟਰਿੰਗ ਲੈਂਦਾ ਹੈ ਅਤੇ ਸਿਰਫ ਉੱਚ ਅੱਖਰਾਂ ਦੇ ASCII ਕੋਡਾਂ ਦਾ ਜੋੜ ਵਾਪਸ ਕਰਦਾ ਹੈ।\n\n    ਉਦਾਹਰਣ:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n    \"\"\"","canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n","entry_point":"digitSum"}
{"task_id":"HumanEval\/67","prompt":"def fruit_distribution(s,n):\n    \"\"\"\n    ਇਸ ਟਾਸਕ ਵਿੱਚ, ਤੁਹਾਨੂੰ ਇੱਕ ਸਟਰਿੰਗ ਦਿੱਤੀ ਜਾਵੇਗੀ ਜੋ ਸੇਬਾਂ ਅਤੇ ਸੰਤਰਿਆਂ ਦੀ ਗਿਣਤੀ ਨੂੰ ਦਰਸਾਉਂਦੀ ਹੈ \n    ਜੋ ਇੱਕ ਫਲਾਂ ਦੀ ਟੋਕਰੀ ਵਿੱਚ ਵੰਡੀਆਂ ਗਈਆਂ ਹਨ ਇਸ ਟੋਕਰੀ ਵਿੱਚ \n    ਸੇਬ, ਸੰਤਰੇ ਅਤੇ ਆਮ ਫਲ ਹਨ। ਸੇਬਾਂ ਅਤੇ ਸੰਤਰਿਆਂ ਦੀ ਕੁੱਲ ਗਿਣਤੀ ਨੂੰ ਦਰਸਾਉਂਦੀ ਸਟਰਿੰਗ ਅਤੇ \n    ਟੋਕਰੀ ਵਿੱਚ ਫਲਾਂ ਦੀ ਕੁੱਲ ਗਿਣਤੀ ਨੂੰ ਦਰਸਾਉਂਦੇ ਇੱਕ ਪੂਰਨਾਂਕ ਦਿੱਤੇ ਜਾਣ ਤੇ ਟੋਕਰੀ ਵਿੱਚ ਆਮ ਫਲਾਂ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰੋ।\n    ਉਦਾਹਰਣ ਲਈ:\n    fruit_distribution(\"5 apples and 6 oranges\", 19) -> 19 - 5 - 6 = 8\n    fruit_distribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n    fruit_distribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n    fruit_distribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n    \"\"\"\n","canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n","entry_point":"fruit_distribution"}
{"task_id":"HumanEval\/68","prompt":"def pluck(arr):\n    \"\"\"\n    \"ਇੱਕ ਰੁੱਖ ਦੀ ਟਹਿਣੀ ਨੂੰ ਦਰਸਾਉਂਦੇ ਹੋਏ ਇੱਕ ਐਰੇ ਦਿੱਤਾ ਗਿਆ ਹੈ ਜਿਸ ਵਿੱਚ ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨਾਂਕ ਨੋਡ ਹਨ,\n    ਤੁਹਾਡਾ ਕੰਮ ਹੈ ਕਿ ਇੱਕ ਨੋਡ ਨੂੰ ਚੁਣੋ ਅਤੇ ਉਸ ਨੂੰ ਵਾਪਸ ਕਰੋ।\n    ਚੁਣਿਆ ਗਿਆ ਨੋਡ ਉਹ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ ਜਿਸ ਦਾ ਸਭ ਤੋਂ ਘੱਟ ਸਮਾਨ ਮੁੱਲ ਹੋਵੇ।\n    ਜੇਕਰ ਇੱਕੋ ਜਿਹੇ ਸਭ ਤੋਂ ਘੱਟ ਸਮਾਨ ਮੁੱਲ ਵਾਲੇ ਕਈ ਨੋਡ ਮਿਲਦੇ ਹਨ ਤਾਂ ਉਸ ਨੋਡ ਨੂੰ ਵਾਪਸ ਕਰੋ ਜਿਸ ਦਾ ਸੂਚਕਾਂਕ ਸਭ ਤੋਂ ਘੱਟ ਹੋਵੇ।\n\n    ਚੁਣਿਆ ਗਿਆ ਨੋਡ ਇੱਕ ਸੂਚੀ ਵਿੱਚ ਵਾਪਸ ਕੀਤਾ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ, [ ਸਭ ਤੋਂ ਘੱਟ ਮੁੱਲ, ਉਸ ਦਾ ਸੂਚਕਾਂਕ ],\n    ਜੇਕਰ ਕੋਈ ਵੀ ਸਮਾਨ ਮੁੱਲ ਨਾ ਹੋਵੇ ਜਾਂ ਦਿੱਤਾ ਗਿਆ ਐਰੇ ਖਾਲੀ ਹੋਵੇ, ਤਾਂ [] ਵਾਪਸ ਕਰੋ।\n\n    ਉਦਾਹਰਣ 1:\n        ਇੰਪੁੱਟ: [4,2,3]\n        ਆਉਟਪੁੱਟ: [2, 1]\n        ਵਿਆਖਿਆ: 2 ਦਾ ਸਭ ਤੋਂ ਘੱਟ ਸਮਾਨ ਮੁੱਲ ਹੈ, ਅਤੇ 2 ਦਾ ਸੂਚਕਾਂਕ ਵੀ ਸਭ ਤੋਂ ਘੱਟ ਹੈ।\n\n    ਉਦਾਹਰਣ 2:\n        ਇੰਪੁੱਟ: [1,2,3]\n        ਆਉਟਪੁੱਟ: [2, 1]\n        ਵਿਆਖਿਆ: 2 ਦਾ ਸਭ ਤੋਂ ਘੱਟ ਸਮਾਨ ਮੁੱਲ ਹੈ, ਅਤੇ 2 ਦਾ ਸੂਚਕਾਂਕ ਵੀ ਸਭ ਤੋਂ ਘੱਟ ਹੈ। \n\n    ਉਦਾਹਰਣ 3:\n        ਇੰਪੁੱਟ: []\n        ਆਉਟਪੁੱਟ: []\n    \n    ਉਦਾਹਰਣ 4:\n        ਇੰਪੁੱਟ: [5, 0, 3, 0, 4, 2]\n        ਆਉਟਪੁੱਟ: [0, 1]\n        ਵਿਆਖਿਆ: 0 ਸਭ ਤੋਂ ਘੱਟ ਮੁੱਲ ਹੈ, ਪਰ ਦੋ ਜ਼ੀਰੋ ਹਨ,\n                     ਇਸ ਲਈ ਅਸੀਂ ਪਹਿਲੇ ਜ਼ੀਰੋ ਨੂੰ ਚੁਣਾਂਗੇ, ਜਿਸ ਦਾ ਸੂਚਕਾਂਕ ਸਭ ਤੋਂ ਘੱਟ ਹੈ।\n\n    ਬੰਦਿਸ਼ਾਂ:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n","canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n","entry_point":"pluck"}
{"task_id":"HumanEval\/69","prompt":"def search(lst):\n    '''\n    ਤੁਹਾਨੂੰ ਇੱਕ ਨਾ-ਖਾਲੀ ਸੂਚੀ ਦਿੱਤੀ ਗਈ ਹੈ ਜਿਸ ਵਿੱਚ ਸਿਰਫ ਮਿਥਾਤਮਕ ਪੂਰਨ ਅੰਕ ਹਨ। ਉਸ ਸਭ ਤੋਂ ਵੱਡੇ ਅੰਕ ਨੂੰ ਵਾਪਸ ਕਰੋ ਜੋ ਕਿ ਸਿਫਰ ਤੋਂ ਵੱਡਾ ਹੈ, \n    ਅਤੇ ਜਿਸਦੀ ਫਰੀਕੁਏਂਸੀ ਉਸ ਅੰਕ ਦੇ ਮੁੱਲ ਜਾਂ ਉਸ ਤੋਂ ਵੱਧ ਹੈ। ਕਿਸੇ ਅੰਕ ਦੀ ਫਰੀਕੁਏਂਸੀ ਉਹ ਗਿਣਤੀ ਹੈ ਜਿੰਨੀ ਵਾਰ ਉਹ ਸੂਚੀ ਵਿੱਚ ਆਉਂਦਾ ਹੈ।\n    ਜੇਕਰ ਅਜਿਹਾ ਕੋਈ ਮੁੱਲ ਮੌਜੂਦ ਨਹੀਂ ਹੈ, ਤਾਂ -1 ਵਾਪਸ ਕਰੋ।\n    ਉਦਾਹਰਣ:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n","canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n","test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n","entry_point":"search"}
{"task_id":"HumanEval\/70","prompt":"def strange_sort_list(lst):\n    '''\n    ਪੂਰੀ ਸੂਚੀ ਦਿੱਤੀ ਗਈ ਹੈ, ਅਜੀਬ ਕ੍ਰਮ ਵਿੱਚ ਸੂਚੀ ਵਾਪਸ ਕਰੋ।\n    ਅਜੀਬ ਕ੍ਰਮਬੱਧ, ਜਦੋਂ ਤੁਸੀਂ ਘੱਟੋ-ਘੱਟ ਮੁੱਲ ਨਾਲ ਸ਼ੁਰੂ ਕਰਦੇ ਹੋ,\n    ਫਿਰ ਬਾਕੀ ਬਚੇ ਪੂਰੇ ਅੰਕਾਂ ਵਿੱਚੋਂ ਵੱਧ ਤੋਂ ਵੱਧ, ਫਿਰ ਘੱਟੋ-ਘੱਟ ਅਤੇ ਇਸੇ ਤਰ੍ਹਾਂ।\n\n    ਉਦਾਹਰਣਾਂ:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n","canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"strange_sort_list"}
{"task_id":"HumanEval\/71","prompt":"def triangle_area(a, b, c):\n    '''\n    ਤਿੰਨ ਪਾਸਿਆਂ ਦੀਆਂ ਲੰਬਾਈਆਂ ਦੇ ਨਾਲ ਇੱਕ ਤਿਕੋਣ ਦਿੱਤਾ ਗਿਆ ਹੈ। ਜੇ ਤਿੰਨ ਪਾਸਿਆਂ ਇੱਕ ਵੈਧ ਤਿਕੋਣ ਬਣਾਉਂਦੀਆਂ ਹਨ, \n    ਤਾਂ ਤਿਕੋਣ ਦੇ ਖੇਤਰਫਲ ਨੂੰ 2 ਦਸਮਲਵ ਅੰਕਾਂ ਤੱਕ ਗੋਲ ਕਰਕੇ ਮੁੜਤ ਕਰੋ। \n    ਨਹੀਂ ਤਾਂ -1 ਮੁੜਤ ਕਰੋ\n    ਤਿੰਨ ਪਾਸਿਆਂ ਤਦੋਂ ਇੱਕ ਵੈਧ ਤਿਕੋਣ ਬਣਾਉਂਦੀਆਂ ਹਨ ਜਦੋਂ ਕਿਸੇ ਵੀ ਦੋ ਪਾਸਿਆਂ ਦਾ ਜੋੜ ਤੀਜੀ ਪਾਸੇ ਤੋਂ ਵੱਧ ਹੁੰਦਾ ਹੈ।\n    ਉਦਾਹਰਣ:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n","canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n","entry_point":"triangle_area"}
{"task_id":"HumanEval\/72","prompt":"def will_it_fly(q,w):\n    '''\n    ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਸੱਚ ਮੁੱਚ ਦੇਵੇ ਜੇ ਚੀਜ਼ q ਉਡਾਣ ਭਰੇਗੀ, ਅਤੇ ਨਹੀਂ ਤਾਂ ਝੂਠ।\n    ਚੀਜ਼ q ਉਡਾਣ ਭਰੇਗੀ ਜੇ ਇਹ ਸੰਤੁਲਿਤ ਹੈ (ਇਹ ਇੱਕ ਪੈਲਿੰਡ੍ਰੋਮਿਕ ਸੂਚੀ ਹੈ) ਅਤੇ ਇਸਦੇ ਤੱਤਾਂ ਦਾ ਜੋੜ ਅਧਿਕਤਮ ਸੰਭਵ ਭਾਰ w ਤੋਂ ਘੱਟ ਜਾਂ ਬਰਾਬਰ ਹੈ।\n\n    ਉਦਾਹਰਣ:\n    will_it_fly([1, 2], 5) ➞ ਝੂਠ\n    # 1+2 ਅਧਿਕਤਮ ਸੰਭਵ ਭਾਰ ਤੋਂ ਘੱਟ ਹੈ, ਪਰ ਇਹ ਅਸੰਤੁਲਿਤ ਹੈ।\n\n    will_it_fly([3, 2, 3], 1) ➞ ਝੂਠ\n    # ਇਹ ਸੰਤੁਲਿਤ ਹੈ, ਪਰ 3+2+3 ਅਧਿਕਤਮ ਸੰਭਵ ਭਾਰ ਤੋਂ ਵੱਧ ਹੈ।\n\n    will_it_fly([3, 2, 3], 9) ➞ ਸੱਚ\n    # 3+2+3 ਅਧਿਕਤਮ ਸੰਭਵ ਭਾਰ ਤੋਂ ਘੱਟ ਹੈ, ਅਤੇ ਇਹ ਸੰਤੁਲਿਤ ਹੈ।\n\n    will_it_fly([3], 5) ➞ ਸੱਚ\n    # 3 ਅਧਿਕਤਮ ਸੰਭਵ ਭਾਰ ਤੋਂ ਘੱਟ ਹੈ, ਅਤੇ ਇਹ ਸੰਤੁਲਿਤ ਹੈ।\n    '''\n","canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n","entry_point":"will_it_fly"}
{"task_id":"HumanEval\/73","prompt":"def smallest_change(arr):\n    \"\"\"\n    ਇੱਕ ਪੂਰਨਾਂਕਾਂ ਦੀ ਐਰੇ arr ਦਿੱਤੀ ਗਈ ਹੈ, ਐਰੇ ਨੂੰ ਪੈਲਿੰਡ੍ਰੋਮਿਕ ਬਣਾਉਣ ਲਈ ਘੱਟੋ-ਘੱਟ ਕਿੰਨੇ ਅੰਕਾਂ ਨੂੰ ਬਦਲਣ ਦੀ ਲੋੜ ਹੈ। ਇੱਕ ਪੈਲਿੰਡ੍ਰੋਮਿਕ ਐਰੇ ਉਹ ਐਰੇ ਹੁੰਦਾ ਹੈ ਜੋ ਪਿੱਛੇ ਤੋਂ ਅੱਗੇ ਅਤੇ ਅੱਗੇ ਤੋਂ ਪਿੱਛੇ ਇੱਕੋ ਜਿਹਾ ਪੜ੍ਹਿਆ ਜਾਂਦਾ ਹੈ। ਇੱਕ ਬਦਲਾਅ ਵਿੱਚ, ਤੁਸੀਂ ਇੱਕ ਅੰਕ ਨੂੰ ਕਿਸੇ ਵੀ ਹੋਰ ਅੰਕ ਨਾਲ ਬਦਲ ਸਕਦੇ ਹੋ।\n\n    ਉਦਾਹਰਣ ਲਈ:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n","canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n","entry_point":"smallest_change"}
{"task_id":"HumanEval\/74","prompt":"def total_match(lst1, lst2):\n    '''\n    ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਦੋ ਸਟਰਿੰਗਾਂ ਦੀਆਂ ਸੂਚੀਆਂ ਨੂੰ ਸਵੀਕਾਰ ਕਰਦਾ ਹੈ ਅਤੇ ਉਸ ਸੂਚੀ ਨੂੰ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਸਾਰੀਆਂ ਸਟਰਿੰਗਾਂ ਵਿੱਚ ਅੱਖਰਾਂ ਦੀ ਕੁੱਲ ਗਿਣਤੀ ਦੂਜੀ ਸੂਚੀ ਨਾਲੋਂ ਘੱਟ ਹੈ।\n\n    ਜੇ ਦੋਵਾਂ ਸੂਚੀਆਂ ਵਿੱਚ ਅੱਖਰਾਂ ਦੀ ਗਿਣਤੀ ਇੱਕੋ ਜਿਹੀ ਹੈ, ਪਹਿਲੀ ਸੂਚੀ ਨੂੰ ਵਾਪਸ ਕਰੋ।\n\n    ਉਦਾਹਰਣ\n    total_match([], []) ➞ []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n    '''\n","canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n","entry_point":"total_match"}
{"task_id":"HumanEval\/75","prompt":"def is_multiply_prime(a):\n    \"\"\"ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇਹ ਚੈੱਕ ਕਰੇ ਕਿ ਦਿੱਤੀ ਗਈ ਸੰਖਿਆ 3 ਪ੍ਰਾਈਮ ਸੰਖਿਆਵਾਂ ਦੀ ਗੁਣਾ ਹੈ ਜਾਂ ਨਹੀਂ।\n    ਜਾਣੋ ਕਿ (a) 100 ਤੋਂ ਘੱਟ ਹੈ। \n    ਉਦਾਹਰਣ:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"","canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n","test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n","entry_point":"is_multiply_prime"}
{"task_id":"HumanEval\/76","prompt":"def is_simple_power(x, n):\n    \"\"\"ਤੁਹਾਡਾ ਕੰਮ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖਣਾ ਹੈ ਜੋ ਸੱਚ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੇ ਇੱਕ ਨੰਬਰ x n ਦੀ ਇੱਕ ਸਾਦੀ ਸ਼ਕਤੀ ਹੈ ਅਤੇ ਹੋਰ ਮਾਮਲਿਆਂ ਵਿੱਚ ਝੂਠਾ ਹੈ।\n    x ਇੱਕ ਸਾਦੀ ਸ਼ਕਤੀ ਹੈ ਜੇ n**int=x\n    ਉਦਾਹਰਣ ਲਈ:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n    \"\"\"","canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"is_simple_power"}
{"task_id":"HumanEval\/77","prompt":"def iscube(a):\n    '''\n    ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਪੂਰਨ ਅੰਕ a ਲੈਂਦਾ ਹੈ ਅਤੇ ਅਗਰ ਇਹ ਪੂਰਨ ਅੰਕ ਕਿਸੇ ਪੂਰਨ ਅੰਕ ਦਾ ਘਣ ਹੈ ਤਾਂ True ਮੁੜਾਉਂਦਾ ਹੈ।\n    ਨੋਟ: ਤੁਸੀਂ ਮਾਨ ਸਕਦੇ ਹੋ ਕਿ ਇੰਪੁੱਟ ਹਮੇਸ਼ਾ ਵੈਧ ਹੈ।\n    ਉਦਾਹਰਣ:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n","canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n","entry_point":"iscube"}
{"task_id":"HumanEval\/78","prompt":"def hex_key(num):\n    \"\"\"ਤੁਹਾਨੂੰ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖਣ ਦਾ ਕੰਮ ਸੌਂਪਿਆ ਗਿਆ ਹੈ ਜੋ ਇੱਕ ਹੈਕਸਾਡੈਸੀਮਲ ਨੰਬਰ ਨੂੰ ਸਟਰਿੰਗ ਦੇ ਰੂਪ ਵਿੱਚ ਪ੍ਰਾਪਤ ਕਰਦਾ ਹੈ ਅਤੇ ਹੈਕਸਾਡੈਸੀਮਲ ਅੰਕਾਂ ਦੀ ਗਿਣਤੀ ਕਰਦਾ ਹੈ ਜੋ ਪ੍ਰਾਈਮ ਹਨ (ਪ੍ਰਾਈਮ ਨੰਬਰ, ਜਾਂ ਇੱਕ ਪ੍ਰਾਈਮ, ਇੱਕ ਕੁਦਰਤੀ ਨੰਬਰ ਹੈ ਜੋ 1 ਤੋਂ ਵੱਡਾ ਹੈ ਅਤੇ ਦੋ ਛੋਟੇ ਕੁਦਰਤੀ ਨੰਬਰਾਂ ਦਾ ਉਤਪਾਦ ਨਹੀਂ ਹੈ)।\n    ਹੈਕਸਾਡੈਸੀਮਲ ਅੰਕ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F ਹਨ।\n    ਪ੍ਰਾਈਮ ਨੰਬਰ 2, 3, 5, 7, 11, 13, 17,... ਹਨ।\n    ਇਸ ਲਈ ਤੁਹਾਨੂੰ ਅੰਕਾਂ 2, 3, 5, 7, B (=ਦਸਮਲਵ 11), D (=ਦਸਮਲਵ 13) ਦੀ ਗਿਣਤੀ ਕਰਨੀ ਹੈ।\n    ਨੋਟ: ਤੁਸੀਂ ਮਾਨ ਸਕਦੇ ਹੋ ਕਿ ਇਨਪੁਟ ਹਮੇਸ਼ਾ ਸਹੀ ਜਾਂ ਖਾਲੀ ਸਟਰਿੰਗ ਹੈ, ਅਤੇ ਅੱਖਰ A,B,C,D,E,F ਹਮੇਸ਼ਾ ਵੱਡੇ ਹਰਫਾਂ ਵਿੱਚ ਹਨ।\n    ਉਦਾਹਰਣਾਂ:\n    ਜੇਕਰ num = \"AB\" ਹੈ ਤਾਂ ਆਉਟਪੁਟ 1 ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ।\n    ਜੇਕਰ num = \"1077E\" ਹੈ ਤਾਂ ਆਉਟਪੁਟ 2 ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ।\n    ਜੇਕਰ num = \"ABED1A33\" ਹੈ ਤਾਂ ਆਉਟਪੁਟ 4 ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ।\n    ਜੇਕਰ num = \"123456789ABCDEF0\" ਹੈ ਤਾਂ ਆਉਟਪੁਟ 6 ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ।\n    ਜੇਕਰ num = \"2020\" ਹੈ ਤਾਂ ਆਉਟਪੁਟ 2 ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ।\n    \"\"\"","canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n","entry_point":"hex_key"}
{"task_id":"HumanEval\/79","prompt":"def decimal_to_binary(decimal):\n    \"\"\"ਤੁਹਾਨੂੰ ਦਸਮਲਵ ਰੂਪ ਵਿੱਚ ਇੱਕ ਨੰਬਰ ਦਿੱਤਾ ਜਾਵੇਗਾ ਅਤੇ ਤੁਹਾਡਾ ਕੰਮ ਇਸ ਨੂੰ ਬਾਇਨਰੀ ਫਾਰਮੈਟ ਵਿੱਚ ਬਦਲਣਾ ਹੈ। ਫੰਕਸ਼ਨ ਨੂੰ ਇੱਕ ਸਟਰਿੰਗ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ, ਜਿਸ ਵਿੱਚ ਹਰ ਇੱਕ ਅੱਖਰ ਇੱਕ ਬਾਇਨਰੀ ਨੰਬਰ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ। ਸਟਰਿੰਗ ਵਿੱਚ ਹਰ ਇੱਕ ਅੱਖਰ '0' ਜਾਂ '1' ਹੋਵੇਗਾ।\n\n    ਸਟਰਿੰਗ ਦੇ ਸ਼ੁਰੂ ਅਤੇ ਅੰਤ ਵਿੱਚ 'db' ਦੇ ਦੋ ਵਾਧੂ ਅੱਖਰ ਹੋਣਗੇ। ਵਾਧੂ ਅੱਖਰ ਫਾਰਮੈਟ ਨਾਲ ਮਦਦ ਲਈ ਹਨ।\n\n    ਉਦਾਹਰਣ:\n    decimal_to_binary(15)   # \"db1111db\" ਵਾਪਸ ਕਰਦਾ ਹੈ\n    decimal_to_binary(32)   # \"db100000db\" ਵਾਪਸ ਕਰਦਾ ਹੈ\n    \"\"\"","canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"decimal_to_binary"}
{"task_id":"HumanEval\/80","prompt":"def is_happy(s):\n    \"\"\"ਤੁਹਾਨੂੰ ਇੱਕ ਸਟਰਿੰਗ s ਦਿੱਤੀ ਗਈ ਹੈ।\n    ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਚੈੱਕ ਕਰਨਾ ਹੈ ਕਿ ਸਟਰਿੰਗ ਖੁਸ਼ ਹੈ ਜਾਂ ਨਹੀਂ।\n    ਇੱਕ ਸਟਰਿੰਗ ਖੁਸ਼ ਹੈ ਜੇਕਰ ਇਸਦੀ ਲੰਬਾਈ ਘੱਟੋ ਘੱਟ 3 ਹੈ ਅਤੇ ਹਰ 3 ਲਗਾਤਾਰ ਅੱਖਰ ਵੱਖਰੇ ਹਨ\n    ਉਦਾਹਰਣ ਲਈ:\n    is_happy(a) => ਝੂਠਾ\n    is_happy(aa) => ਝੂਠਾ\n    is_happy(abcd) => ਸੱਚਾ\n    is_happy(aabb) => ਝੂਠਾ\n    is_happy(adb) => ਸੱਚਾ\n    is_happy(xyy) => ਝੂਠਾ\n    \"\"\"","canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n","entry_point":"is_happy"}
{"task_id":"HumanEval\/81","prompt":"def numerical_letter_grade(grades):\n    \"\"\"ਇਹ ਸਮੈਸਟਰ ਦਾ ਆਖਰੀ ਹਫਤਾ ਹੈ ਅਤੇ ਅਧਿਆਪਕ ਨੂੰ ਵਿਦਿਆਰਥੀਆਂ ਨੂੰ ਗ੍ਰੇਡ ਦੇਣੇ ਪੈ ਰਹੇ ਹਨ। ਅਧਿਆਪਕ ਨੇ ਆਪਣੀ ਗ੍ਰੇਡਿੰਗ ਲਈ ਖੁਦ ਦਾ ਇੱਕ ਐਲਗੋਰਿਦਮ ਬਣਾਇਆ ਹੈ।\n    ਸਿਰਫ ਇੱਕ ਸਮੱਸਿਆ ਹੈ, ਉਸ ਨੇ ਗ੍ਰੇਡਿੰਗ ਲਈ ਵਰਤੀ ਗਈ ਕੋਡ ਗੁਆ ਦਿੱਤੀ ਹੈ।\n    ਉਸ ਨੇ ਤੁਹਾਨੂੰ ਕੁਝ ਵਿਦਿਆਰਥੀਆਂ ਦੇ GPA ਦੀ ਇੱਕ ਸੂਚੀ ਦਿੱਤੀ ਹੈ ਅਤੇ ਤੁਹਾਨੂੰ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖਣਾ ਹੈ ਜੋ ਹੇਠ ਦਿੱਤੀ ਤਾਲਿਕਾ ਦੀ ਵਰਤੋਂ ਕਰਦਿਆਂ ਅੱਖਰ ਗ੍ਰੇਡ ਦੀ ਇੱਕ ਸੂਚੀ ਦਾ ਨਿਕਾਸ ਕਰ ਸਕੇ:\n             GPA       |    ਅੱਖਰ ਗ੍ਰੇਡ\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    ਉਦਾਹਰਣ:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"","canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"numerical_letter_grade"}
{"task_id":"HumanEval\/82","prompt":"def prime_length(string):\n    \"\"\"ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਸਟਰਿੰਗ ਲੈਂਦਾ ਹੈ ਅਤੇ ਜੇ ਸਟਰਿੰਗ ਦੀ ਲੰਬਾਈ ਪ੍ਰਾਈਮ ਨੰਬਰ ਹੈ ਤਾਂ True ਵਾਪਸ ਕਰਦਾ ਹੈ ਨਹੀਂ ਤਾਂ False\n    ਉਦਾਹਰਣ\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"","canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n","entry_point":"prime_length"}
{"task_id":"HumanEval\/83","prompt":"def starts_one_ends(n):\n    \"\"\"\n    ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਹੋਇਆ ਹੈ, n-ਅੰਕਾਂ ਵਾਲੇ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕਾਂ ਦੀ ਗਿਣਤੀ ਦਾਸੋ ਜੋ 1 ਨਾਲ ਸ਼ੁਰੂ ਜਾਂ ਖਤਮ ਹੁੰਦੇ ਹਨ।\n    \"\"\"\n","canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"starts_one_ends"}
{"task_id":"HumanEval\/84","prompt":"def solve(N):\n    \"\"\"ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ N ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇਸ ਦੇ ਅੰਕਾਂ ਦੇ ਯੋਗ ਦਾ ਕੁੱਲ ਜੋੜ ਬਾਈਨਰੀ ਵਿੱਚ ਵਾਪਸ ਕਰੋ।\n    \n    ਉਦਾਹਰਣ\n        ਜੇ N = 1000 ਹੈ, ਤਾਂ ਅੰਕਾਂ ਦਾ ਯੋਗ 1 ਹੋਵੇਗਾ ਅਤੇ ਆਉਟਪੁਟ \"1\" ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ।\n        ਜੇ N = 150 ਹੈ, ਤਾਂ ਅੰਕਾਂ ਦਾ ਯੋਗ 6 ਹੋਵੇਗਾ ਅਤੇ ਆਉਟਪੁਟ \"110\" ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ।\n        ਜੇ N = 147 ਹੈ, ਤਾਂ ਅੰਕਾਂ ਦਾ ਯੋਗ 12 ਹੋਵੇਗਾ ਅਤੇ ਆਉਟਪੁਟ \"1100\" ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ।\n    \n    ਵੇਰੀਏਬਲ:\n        @N ਪੂਰਨ ਅੰਕ\n             ਬੰਧਨਾਂ: 0 ≤ N ≤ 10000.\n    ਆਉਟਪੁਟ:\n         ਬਾਈਨਰੀ ਨੰਬਰ ਦੀ ਇੱਕ ਸਟਰਿੰਗ\n    \"\"\"","canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n","entry_point":"solve"}
{"task_id":"HumanEval\/85","prompt":"def add(lst):\n    \"\"\"ਇੱਕ ਨਾ-ਖਾਲੀ ਪੂਰਨਾਂਕ ਸੂਚੀ lst ਦਿੱਤੀ ਗਈ ਹੈ। ਉਹਨਾਂ ਸਮਾਨ ਅੰਕਾਂ ਨੂੰ ਜੋੜੋ ਜੋ ਅਜੀਬ ਸੂਚਕਾਂ 'ਤੇ ਹਨ।\n\n\n    ਉਦਾਹਰਣ:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"","canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n","entry_point":"add"}
{"task_id":"HumanEval\/86","prompt":"def anti_shuffle(s):\n    \"\"\"\n    ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਸਟਰਿੰਗ ਲੈਂਦਾ ਹੈ ਅਤੇ ਇਸਦਾ ਇੱਕ ਕ੍ਰਮਬੱਧ ਵਰਜਨ ਵਾਪਸ ਕਰਦਾ ਹੈ।\n    ਸਟਰਿੰਗ ਦਾ ਕ੍ਰਮਬੱਧ ਵਰਜਨ, ਇੱਕ ਅਜਿਹੀ ਸਟਰਿੰਗ ਹੈ ਜਿੱਥੇ ਸਾਰੇ ਸ਼ਬਦ (ਖਾਲੀ ਥਾਂ ਦੁਆਰਾ ਵੱਖ ਕੀਤੇ ਗਏ)\n    ਨਵੇਂ ਸ਼ਬਦ ਨਾਲ ਬਦਲੇ ਜਾਂਦੇ ਹਨ ਜਿੱਥੇ ਸਾਰੇ ਅੱਖਰ ਆਸਕੀ ਮੁੱਲ ਦੇ ਆਧਾਰ 'ਤੇ ਚੜ੍ਹਦੇ ਕ੍ਰਮ ਵਿੱਚ ਵਿਵਸਥਿਤ ਹੁੰਦੇ ਹਨ।\n    ਨੋਟ: ਤੁਸੀਂ ਵਾਕ ਵਿੱਚ ਸ਼ਬਦਾਂ ਅਤੇ ਖਾਲੀ ਥਾਵਾਂ ਦੇ ਕ੍ਰਮ ਨੂੰ ਬਰਕਰਾਰ ਰੱਖਣਾ ਚਾਹੀਦਾ ਹੈ।\n\n    ਉਦਾਹਰਣ ਲਈ:\n    anti_shuffle('Hi') ਵਾਪਸ 'Hi'\n    anti_shuffle('hello') ਵਾਪਸ 'ehllo'\n    anti_shuffle('Hello World!!!') ਵਾਪਸ 'Hello !!!Wdlor'\n    \"\"\"\n","canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"anti_shuffle"}
{"task_id":"HumanEval\/87","prompt":"def get_row(lst, x):\n    \"\"\"\n    ਤੁਹਾਨੂੰ ਇੱਕ ਦੋ ਆਯਾਮੀ ਡਾਟਾ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਜੋ ਕਿ ਨੈਸਟਿਡ ਲਿਸਟਾਂ ਦੇ ਰੂਪ ਵਿੱਚ ਹੈ,\n    ਜੋ ਕਿ ਮੈਟ੍ਰਿਕਸ ਵਾਂਗ ਹੈ, ਪਰ ਮੈਟ੍ਰਿਕਸਾਂ ਦੇ ਉਲਟ, ਹਰ ਕਤਾਰ ਵਿੱਚ ਵੱਖ ਵੱਖ ਗਿਣਤੀ ਦੇ ਕਾਲਮ ਹੋ ਸਕਦੇ ਹਨ।\n    ਦਿੱਤੀ ਗਈ lst, ਅਤੇ ਪੂਰਨਾਂਕ x, ਲਿਸਟ ਵਿੱਚ x ਪੂਰਨਾਂਕ ਲੱਭੋ,\n    ਅਤੇ ਟਪਲਾਂ ਦੀ ਲਿਸਟ ਵਾਪਸ ਕਰੋ, [(x1, y1), (x2, y2) ...] ਇਸ ਤਰ੍ਹਾਂ\n    ਕਿ ਹਰ ਟਪਲ ਇੱਕ ਕੋਆਰਡੀਨੇਟ ਹੈ - (ਕਤਾਰ, ਕਾਲਮ), 0 ਤੋਂ ਸ਼ੁਰੂ ਹੋ ਕੇ।\n    ਸ਼ੁਰੂ ਵਿੱਚ ਕਤਾਰਾਂ ਨੂੰ ਚੜ੍ਹਦੇ ਕ੍ਰਮ ਵਿੱਚ ਸੋਰਟ ਕਰੋ।\n    ਨਾਲ ਹੀ, ਕਤਾਰ ਦੇ ਕੋਆਰਡੀਨੇਟਾਂ ਨੂੰ ਕਾਲਮਾਂ ਵਿੱਚ ਉੱਤਰਦੇ ਕ੍ਰਮ ਵਿੱਚ ਸੋਰਟ ਕਰੋ।\n    \n    ਉਦਾਹਰਣਾਂ:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n","canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"get_row"}
{"task_id":"HumanEval\/88","prompt":"def sort_array(array):\n    \"\"\"\n    ਨੌਨ-ਨੈਗੇਟਿਵ ਪੂਰਨਾਂਕਾਂ ਦੀ ਇੱਕ ਐਰੇ ਦਿੱਤੀ ਗਈ ਹੈ, ਦਿੱਤੀ ਗਈ ਐਰੇ ਦੀ ਇੱਕ ਕਾਪੀ ਨੂੰ ਸੋਰਟ ਕਰਕੇ ਵਾਪਸ ਕਰੋ,\n    ਜੇ ਪਹਿਲੀ ਇੰਡੈਕਸ ਮੁੱਲ ਅਤੇ ਆਖਰੀ ਇੰਡੈਕਸ ਮੁੱਲ ਦਾ ਜੋੜ ਅਜੀਬ ਹੈ ਤਾਂ ਤੁਸੀਂ ਦਿੱਤੀ ਗਈ ਐਰੇ ਨੂੰ ਚੜ੍ਹਦੇ ਕ੍ਰਮ ਵਿੱਚ ਸੋਰਟ ਕਰੋਗੇ,\n    ਜਾਂ ਜੇ ਜੋੜ ਸਮਾਂ ਹੈ ਤਾਂ ਇਸਨੂੰ ਉਤਰਦੇ ਕ੍ਰਮ ਵਿੱਚ ਸੋਰਟ ਕਰੋ।\n\n    ਨੋਟ:\n    * ਦਿੱਤੀ ਗਈ ਐਰੇ ਨੂੰ ਬਦਲੋ ਨਾ।\n\n    ਉਦਾਹਰਣ:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n","canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n","entry_point":"sort_array"}
{"task_id":"HumanEval\/89","prompt":"def encrypt(s):\n    \"\"\"ਇੱਕ ਫੰਕਸ਼ਨ encrypt ਬਣਾਓ ਜੋ ਇੱਕ ਸਟਰਿੰਗ ਨੂੰ ਆਰਗੂਮੈਂਟ ਵਜੋਂ ਲੈਂਦਾ ਹੈ ਅਤੇ\n    ਅਕਸ਼ਰਾਂ ਨੂੰ ਘੁੰਮਾ ਕੇ ਇਨਕ੍ਰਿਪਟ ਕੀਤੀ ਗਈ ਸਟਰਿੰਗ ਵਾਪਸ ਕਰਦਾ ਹੈ।\n    ਅਕਸ਼ਰਾਂ ਨੂੰ ਇਸ ਤਰ੍ਹਾਂ ਘੁੰਮਾਇਆ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ ਕਿ ਅੱਖਰ \n    ਦੋ ਗੁਣਾ ਦੋ ਥਾਵਾਂ ਨੀਚੇ ਸ਼ਿਫਟ ਹੋ ਜਾਣ।\n    ਉਦਾਹਰਣ ਵਜੋਂ:\n    encrypt('hi') ਵਾਪਸ ਕਰਦਾ ਹੈ 'lm'\n    encrypt('asdfghjkl') ਵਾਪਸ ਕਰਦਾ ਹੈ 'ewhjklnop'\n    encrypt('gf') ਵਾਪਸ ਕਰਦਾ ਹੈ 'kj'\n    encrypt('et') ਵਾਪਸ ਕਰਦਾ ਹੈ 'ix'\n    \"\"\"\n","canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"encrypt"}
{"task_id":"HumanEval\/90","prompt":"def next_smallest(lst):\n    \"\"\"\n    ਤੁਹਾਨੂੰ ਇੱਕ ਸੂਚੀ ਦਿੱਤੀ ਗਈ ਹੈ ਜਿਸ ਵਿੱਚ ਪੂਰੇ ਅੰਕ ਹਨ।\n    ਇੱਕ ਫੰਕਸ਼ਨ next_smallest() ਲਿਖੋ ਜੋ ਸੂਚੀ ਦੇ ਦੂਜੇ ਸਭ ਤੋਂ ਛੋਟੇ ਅੰਕ ਨੂੰ ਵਾਪਸ ਕਰਦਾ ਹੈ।\n    ਜੇਕਰ ਅਜਿਹਾ ਕੋਈ ਅੰਕ ਨਹੀਂ ਹੈ, ਤਾਂ None ਵਾਪਸ ਕਰੋ।\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n","canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"next_smallest"}
{"task_id":"HumanEval\/91","prompt":"def is_bored(S):\n    \"\"\"\n    ਤੁਹਾਨੂੰ ਇੱਕ ਸ਼ਬਦਾਂ ਦੀ ਸਟਰਿੰਗ ਦਿੱਤੀ ਜਾਵੇਗੀ, ਅਤੇ ਤੁਹਾਡਾ ਕੰਮ ਹੈ ਕਿ ਤੁਸੀਂ ਬੋਰਡਮ ਦੀ ਗਿਣਤੀ ਕਰੋ। ਇੱਕ ਬੋਰਡਮ ਉਹ ਵਾਕ ਹੁੰਦਾ ਹੈ ਜੋ \"I\" ਸ਼ਬਦ ਨਾਲ ਸ਼ੁਰੂ ਹੁੰਦਾ ਹੈ। ਵਾਕਾਂ ਨੂੰ '.' ਜਾਂ '?' ਜਾਂ '!' ਨਾਲ ਵੱਖ ਕੀਤਾ ਜਾਂਦਾ ਹੈ।\n   \n    ਉਦਾਹਰਣ ਲਈ:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n","canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"is_bored"}
{"task_id":"HumanEval\/92","prompt":"def any_int(x, y, z):\n    '''\n    ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ 3 ਨੰਬਰ ਲੈਂਦਾ ਹੈ।\n    ਜੇਕਰ ਨੰਬਰਾਂ ਵਿੱਚੋਂ ਇੱਕ ਨੰਬਰ ਬਾਕੀ ਦੋ ਨੰਬਰਾਂ ਦੇ ਜੋੜ ਬਰਾਬਰ ਹੈ ਅਤੇ ਸਾਰੇ ਨੰਬਰ ਪੂਰਨਾਂਕ ਹਨ, ਤਾਂ ਸੱਚ ਮੁੱਚ ਵਾਪਸ ਕਰੋ।\n    ਬਾਕੀ ਸਾਰੇ ਕੇਸਾਂ ਵਿੱਚ ਝੂਠ ਵਾਪਸ ਕਰੋ।\n    \n    ਉਦਾਹਰਣ\n    any_int(5, 2, 7) ➞ True\n    \n    any_int(3, 2, 2) ➞ False\n\n    any_int(3, -2, 1) ➞ True\n    \n    any_int(3.6, -2.2, 2) ➞ False\n  \n\n    \n    '''\n","canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n","entry_point":"any_int"}
{"task_id":"HumanEval\/93","prompt":"def encode(message):\n    \"\"\"\n    ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਸੁਨੇਹਾ ਲੈਂਦਾ ਹੈ, ਅਤੇ ਇਸ ਤਰ੍ਹਾਂ ਕੋਡਿਤ ਕਰਦਾ ਹੈ \n    ਕਿ ਇਹ ਸਾਰੇ ਅੱਖਰਾਂ ਦੇ ਕੇਸ ਨੂੰ ਬਦਲ ਦਿੰਦਾ ਹੈ, ਸੁਨੇਹੇ ਵਿੱਚ ਸਾਰੇ ਸਵਰਾਂ ਨੂੰ \n    ਉਸ ਸਵਰ ਦੇ ਅੰਗਰੇਜ਼ੀ ਵਰਣਮਾਲਾ ਵਿੱਚ ਅੱਗੇ ਦੇ ਦੋ ਸਥਾਨਾਂ ਵਿੱਚ ਆਉਣ ਵਾਲੇ ਅੱਖਰ ਨਾਲ ਬਦਲ ਦਿੰਦਾ ਹੈ।\n    ਸਿਰਫ ਅੱਖਰਾਂ ਨੂੰ ਹੀ ਮੰਨੋ।\n    \n    ਉਦਾਹਰਣ:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n","canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"encode"}
{"task_id":"HumanEval\/94","prompt":"def skjkasdkd(lst):\n    \"\"\"ਤੁਹਾਨੂੰ ਪੂਰਨ ਅੰਕਾਂ ਦੀ ਇੱਕ ਸੂਚੀ ਦਿੱਤੀ ਗਈ ਹੈ।\n    ਤੁਹਾਨੂੰ ਸਭ ਤੋਂ ਵੱਡੀ ਪ੍ਰਾਈਮ ਮੁੱਲ ਲੱਭਣੀ ਹੈ ਅਤੇ ਉਸਦੇ ਅੰਕਾਂ ਦਾ ਜੋੜ ਵਾਪਸ ਕਰਨਾ ਹੈ।\n\n    ਉਦਾਹਰਣਾਂ:\n    ਜੇ lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] ਹੈ ਤਾਂ ਆਉਟਪੁਟ 10 ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ\n    ਜੇ lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] ਹੈ ਤਾਂ ਆਉਟਪੁਟ 25 ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ\n    ਜੇ lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] ਹੈ ਤਾਂ ਆਉਟਪੁਟ 13 ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ\n    ਜੇ lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] ਹੈ ਤਾਂ ਆਉਟਪੁਟ 11 ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ\n    ਜੇ lst = [0,81,12,3,1,21] ਹੈ ਤਾਂ ਆਉਟਪੁਟ 3 ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ\n    ਜੇ lst = [0,8,1,2,1,7] ਹੈ ਤਾਂ ਆਉਟਪੁਟ 7 ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ\n    \"\"\"","canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n","entry_point":"skjkasdkd"}
{"task_id":"HumanEval\/95","prompt":"def check_dict_case(dict):\n    \"\"\"\n    ਇੱਕ ਡਿਕਸ਼ਨਰੀ ਦਿੱਤੀ ਗਈ ਹੈ, ਜੇ ਸਾਰੀਆਂ ਕੁੰਜੀਆਂ ਛੋਟੇ ਅੱਖਰਾਂ ਵਿੱਚ ਸਟਰਿੰਗਾਂ ਹਨ ਜਾਂ ਸਾਰੀਆਂ ਕੁੰਜੀਆਂ ਵੱਡੇ ਅੱਖਰਾਂ ਵਿੱਚ ਸਟਰਿੰਗਾਂ ਹਨ, ਤਾਂ True ਵਾਪਸ ਕਰੋ,\n    ਨਹੀਂ ਤਾਂ False ਵਾਪਸ ਕਰੋ।\n    ਜੇ ਦਿੱਤੀ ਗਈ ਡਿਕਸ਼ਨਰੀ ਖਾਲੀ ਹੈ ਤਾਂ ਫੰਕਸ਼ਨ ਨੂੰ False ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ।\n    ਉਦਾਹਰਣਾਂ:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) ਨੂੰ True ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ।\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) ਨੂੰ False ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ।\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) ਨੂੰ False ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ।\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) ਨੂੰ False ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ।\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) ਨੂੰ True ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ।\n    \"\"\"\n","canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n","entry_point":"check_dict_case"}
{"task_id":"HumanEval\/96","prompt":"def count_up_to(n):\n    \"\"\"ਇੱਕ ਫੰਕਸ਼ਨ ਲਾਗੂ ਕਰੋ ਜੋ ਇੱਕ ਨਾਨ-ਨੈਗੇਟਿਵ ਪੂਰਨ ਅੰਕ ਲੈਂਦਾ ਹੈ ਅਤੇ ਪਹਿਲੇ n ਪੂਰਨ ਅੰਕਾਂ ਦੀ ਇੱਕ ਐਰੇ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੋ ਪ੍ਰਾਈਮ ਨੰਬਰ ਹਨ ਅਤੇ n ਤੋਂ ਘੱਟ ਹਨ।\n    ਉਦਾਹਰਣ ਲਈ:\n    count_up_to(5) => [2,3]\n    count_up_to(11) => [2,3,5,7]\n    count_up_to(0) => []\n    count_up_to(20) => [2,3,5,7,11,13,17,19]\n    count_up_to(1) => []\n    count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"","canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n","test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n","entry_point":"count_up_to"}
{"task_id":"HumanEval\/97","prompt":"def multiply(a, b):\n    \"\"\"ਇਸ ਫੰਕਸ਼ਨ ਨੂੰ ਪੂਰਾ ਕਰੋ ਜੋ ਦੋ ਪੂਰਨ ਅੰਕ ਲੈਂਦਾ ਹੈ ਅਤੇ ਉਹਨਾਂ ਦੇ ਇਕਾਈ ਅੰਕਾਂ ਦਾ ਗੁਣਾਂਕ ਮੁੜ ਦਿੰਦਾ ਹੈ।\n    ਮਾਨ ਲਓ ਇੰਪੁੱਟ ਹਮੇਸ਼ਾ ਜਾਇਜ਼ ਹੈ।\n    ਉਦਾਹਰਣ:\n    multiply(148, 412) ਨੂੰ 16 ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ।\n    multiply(19, 28) ਨੂੰ 72 ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ।\n    multiply(2020, 1851) ਨੂੰ 0 ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ।\n    multiply(14,-15) ਨੂੰ 20 ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ।\n    \"\"\"","canonical_solution":"    return abs(a % 10) * abs(b % 10)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n","entry_point":"multiply"}
{"task_id":"HumanEval\/98","prompt":"def count_upper(s):\n    \"\"\"\n    ਇੱਕ ਸਟਰਿੰਗ s ਦਿੱਤੀ ਗਈ ਹੈ, ਸਮਾਂ ਸੂਚੀਆਂ ਵਿੱਚ ਉੱਚ ਕੇਸ ਵਾਓਲਜ਼ ਦੀ ਗਿਣਤੀ ਕਰੋ।\n    \n    ਉਦਾਹਰਣ ਲਈ:\n    count_upper('aBCdEf') ਵਾਪਸ ਕਰਦਾ ਹੈ 1\n    count_upper('abcdefg') ਵਾਪਸ ਕਰਦਾ ਹੈ 0\n    count_upper('dBBE') ਵਾਪਸ ਕਰਦਾ ਹੈ 0\n    \"\"\"\n","canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"count_upper"}
{"task_id":"HumanEval\/99","prompt":"def closest_integer(value):\n    '''\n    ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਇੱਕ ਮੁੱਲ (ਸਟਰਿੰਗ) ਨੂੰ ਲੈਂਦਾ ਹੈ ਜੋ ਇੱਕ ਨੰਬਰ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ\n    ਅਤੇ ਇਸ ਨੂੰ ਸਭ ਤੋਂ ਨੇੜਲਾ ਪੂਰਾ ਅੰਕ ਵਾਪਸ ਕਰਦਾ ਹੈ। ਜੇ ਨੰਬਰ ਦੋ ਪੂਰੇ ਅੰਕਾਂ ਵਿਚਕਾਰ ਸਮਾਨ ਦੂਰੀ ਤੇ ਹੈ,\n    ਤਾਂ ਇਸ ਨੂੰ ਜ਼ੀਰੋ ਤੋਂ ਦੂਰ ਗੋਲ ਕਰੋ।\n\n    ਉਦਾਹਰਣ\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    ਨੋਟ:\n    ਜ਼ੀਰੋ ਤੋਂ ਦੂਰ ਗੋਲ ਕਰਨਾ ਦਾ ਮਤਲਬ ਹੈ ਕਿ ਜੇ ਦਿੱਤਾ ਗਿਆ ਨੰਬਰ ਦੋ ਪੂਰੇ ਅੰਕਾਂ ਵਿਚਕਾਰ ਸਮਾਨ ਦੂਰੀ ਤੇ ਹੈ,\n    ਤਾਂ ਤੁਹਾਨੂੰ ਜੋ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਉਹ ਹੈ ਜੋ ਜ਼ੀਰੋ ਤੋਂ ਸਭ ਤੋਂ ਦੂਰ ਹੈ। ਉਦਾਹਰਣ ਵਜੋਂ closest_integer(\"14.5\") ਚਾਹੀਦਾ ਹੈ\n    15 ਅਤੇ closest_integer(\"-14.5\") ਚਾਹੀਦਾ ਹੈ -15.\n    '''\n","canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n","entry_point":"closest_integer"}
{"task_id":"HumanEval\/100","prompt":"def make_a_pile(n):\n    \"\"\"\n    ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਤੁਹਾਨੂੰ n ਪੱਧਰਾਂ ਦਾ ਪੱਥਰਾਂ ਦਾ ਢੇਰ ਬਣਾਉਣਾ ਹੈ।\n    ਪਹਿਲੀ ਪੱਧਰ ਵਿੱਚ n ਪੱਥਰ ਹਨ।\n    ਅਗਲੀ ਪੱਧਰ ਵਿੱਚ ਪੱਥਰਾਂ ਦੀ ਗਿਣਤੀ ਹੈ:\n        - ਅਗਲਾ ਵਿਸ਼ਮ ਅੰਕ ਜੇ n ਵਿਸ਼ਮ ਹੈ।\n        - ਅਗਲਾ ਸਮ ਅੰਕ ਜੇ n ਸਮ ਹੈ।\n    ਹਰੇਕ ਪੱਧਰ ਵਿੱਚ ਪੱਥਰਾਂ ਦੀ ਗਿਣਤੀ ਨੂੰ ਇੱਕ ਸੂਚੀ ਵਿੱਚ ਵਾਪਸ ਕਰੋ, ਜਿੱਥੇ ਸੂਚੀ ਦੇ ਇੰਡੈਕਸ\n    i ਤੇ ਤੱਤ ਪੱਧਰ (i+1) ਵਿੱਚ ਪੱਥਰਾਂ ਦੀ ਗਿਣਤੀ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ।\n\n    ਉਦਾਹਰਣ:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n","canonical_solution":"    return [n + 2*i for i in range(n)]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"make_a_pile"}
{"task_id":"HumanEval\/101","prompt":"def words_string(s):\n    \"\"\"\n    ਤੁਹਾਨੂੰ ਇੱਕ ਸਟਰਿੰਗ ਦਿੱਤੀ ਜਾਵੇਗੀ ਜਿਸ ਵਿੱਚ ਸ਼ਬਦ ਕੌਮਾਂ ਜਾਂ ਖਾਲੀ ਥਾਵਾਂ ਨਾਲ ਵੱਖ ਕੀਤੇ ਗਏ ਹਨ। ਤੁਹਾਡਾ ਕੰਮ ਹੈ\n    ਸਟਰਿੰਗ ਨੂੰ ਸ਼ਬਦਾਂ ਵਿੱਚ ਵੰਡਣਾ ਅਤੇ ਸ਼ਬਦਾਂ ਦੀ ਇੱਕ ਐਰੇ ਨੂੰ ਵਾਪਸ ਕਰਨਾ।\n    \n    ਉਦਾਹਰਣ ਲਈ:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"","canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n","entry_point":"words_string"}
{"task_id":"HumanEval\/102","prompt":"def choose_num(x, y):\n    \"\"\"ਇਹ ਫੰਕਸ਼ਨ ਦੋ ਪੌਜ਼ੀਟਿਵ ਨੰਬਰ x ਅਤੇ y ਲੈਂਦਾ ਹੈ ਅਤੇ ਵਾਪਸ ਕਰਦਾ ਹੈ\n    ਸਭ ਤੋਂ ਵੱਡਾ ਜੋੜਾ ਪੂਰਨਾਂਕ ਨੰਬਰ ਜੋ ਕਿ ਰੇਂਜ [x, y] ਵਿੱਚ ਸ਼ਾਮਲ ਹੈ। ਜੇਕਰ\n    ਅਜਿਹਾ ਕੋਈ ਨੰਬਰ ਨਹੀਂ ਹੈ, ਤਾਂ ਫੰਕਸ਼ਨ ਨੂੰ -1 ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ।\n\n    ਉਦਾਹਰਣ ਲਈ:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"","canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n","entry_point":"choose_num"}
{"task_id":"HumanEval\/103","prompt":"def rounded_avg(n, m):\n    \"\"\"ਤੁਹਾਨੂੰ ਦੋ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਅਤੇ m ਦਿੱਤੇ ਗਏ ਹਨ, ਅਤੇ ਤੁਹਾਡਾ ਕੰਮ ਹੈ n ਤੋਂ m ਤੱਕ ਦੇ ਪੂਰਨ ਅੰਕਾਂ ਦਾ ਔਸਤ ਲੱਭਣਾ (n ਅਤੇ m ਸਮੇਤ)। \n    ਜਵਾਬ ਨੂੰ ਨੇੜਲੇ ਪੂਰਨ ਅੰਕ ਤੱਕ ਗੋਲ ਕਰੋ ਅਤੇ ਉਸ ਨੂੰ ਬਾਈਨਰੀ ਵਿੱਚ ਬਦਲੋ।\n    ਜੇ n m ਤੋਂ ਵੱਡਾ ਹੈ, ਤਾਂ -1 ਵਾਪਸ ਕਰੋ।\n    ਉਦਾਹਰਣ:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n","canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n","entry_point":"rounded_avg"}
{"task_id":"HumanEval\/104","prompt":"def unique_digits(x):\n    \"\"\"ਦਿੱਤੀ ਗਈ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕਾਂ ਦੀ ਸੂਚੀ x ਵਿੱਚੋਂ, ਉਹ ਸਾਰੇ ਅੰਕ ਵਾਪਸ ਕਰੋ ਜਿਸ ਵਿੱਚ ਕੋਈ ਵੀ ਸਮਾਂ ਅੰਕ ਨਹੀਂ ਹੈ।\n\n    ਨੋਟ: ਵਾਪਸ ਕੀਤੀ ਗਈ ਸੂਚੀ ਵਧਦੇ ਕ੍ਰਮ ਵਿੱਚ ਸੋਰਟ ਕੀਤੀ ਹੋਣੀ ਚਾਹੀਦੀ ਹੈ।\n    \n    ਉਦਾਹਰਣ ਲਈ:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n","canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"unique_digits"}
{"task_id":"HumanEval\/105","prompt":"def by_length(arr):\n    \"\"\"\n    ਇੱਕ ਪੂਰਨ ਅੰਕਾਂ ਦੀ ਐਰੇ ਦਿੱਤੀ ਗਈ ਹੈ, ਉਹ ਪੂਰਨ ਅੰਕ ਜੋ ਕਿ 1 ਤੋਂ 9 ਤੱਕ ਹਨ, ਉਨ੍ਹਾਂ ਨੂੰ ਛਾਂਟੋ,\n    ਨਤੀਜੇ ਵਾਲੀ ਐਰੇ ਨੂੰ ਉਲਟ ਦਿਓ, ਅਤੇ ਫਿਰ ਹਰੇਕ ਅੰਕ ਨੂੰ ਉਸ ਦੇ ਅਨੁਸਾਰੀ ਨਾਮ ਨਾਲ ਬਦਲ ਦਿਓ ਜੋ ਕਿ\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\" ਤੋਂ ਹਨ।\n\n    ਉਦਾਹਰਣ ਲਈ:\n      arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> arr ਨੂੰ ਛਾਂਟੋ -> [1, 1, 2, 2, 3, 4, 5, 8] \n            -> arr ਨੂੰ ਉਲਟ ਦਿਓ -> [8, 5, 4, 3, 2, 2, 1, 1]\n      ਵਾਪਸੀ [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n    \n      ਜੇਕਰ ਐਰੇ ਖਾਲੀ ਹੈ, ਤਾਂ ਇੱਕ ਖਾਲੀ ਐਰੇ ਵਾਪਸ ਕਰੋ:\n      arr = []\n      ਵਾਪਸੀ []\n    \n      ਜੇਕਰ ਐਰੇ ਵਿੱਚ ਕੋਈ ਵਿਚਿਤਰ ਅੰਕ ਹੈ ਤਾਂ ਉਸ ਨੂੰ ਨਜ਼ਰਅੰਦਾਜ਼ ਕਰੋ:\n      arr = [1, -1 , 55] \n            -> arr ਨੂੰ ਛਾਂਟੋ -> [-1, 1, 55]\n            -> arr ਨੂੰ ਉਲਟ ਦਿਓ -> [55, 1, -1]\n      ਵਾਪਸੀ = ['One']\n    \"\"\"","canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n","entry_point":"by_length"}
{"task_id":"HumanEval\/106","prompt":"def f(n):\n    \"\"\" ਇਸ ਫੰਕਸ਼ਨ f ਨੂੰ ਲਾਗੂ ਕਰੋ ਜੋ n ਨੂੰ ਪੈਰਾਮੀਟਰ ਵਜੋਂ ਲੈਂਦਾ ਹੈ,\n    ਅਤੇ ਇੱਕ ਅਜਿਹੀ ਸਾਈਜ਼ ਦੀ ਸੂਚੀ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜਿਸ ਦੀ ਸਾਈਜ਼ n ਹੈ, ਇਸ ਤਰ੍ਹਾਂ ਕਿ ਸੂਚੀ ਦੇ i ਇੰਡੈਕਸ 'ਤੇ ਤੱਤ ਦਾ ਮੁੱਲ ਉਸ ਦਾ ਫੈਕਟੋਰੀਅਲ ਹੈ ਜੇਕਰ i ਸਮਾਂ ਹੈ\n    ਜਾਂ ਨਹੀਂ ਤਾਂ 1 ਤੋਂ i ਤੱਕ ਦੇ ਨੰਬਰਾਂ ਦਾ ਜੋੜ ਹੈ।\n    i 1 ਤੋਂ ਸ਼ੁਰੂ ਹੁੰਦਾ ਹੈ।\n    i ਦਾ ਫੈਕਟੋਰੀਅਲ 1 ਤੋਂ i ਤੱਕ ਦੇ ਨੰਬਰਾਂ ਦਾ ਗੁਣਾ ਹੈ (1 * 2 * ... * i)।\n    ਉਦਾਹਰਣ:\n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n","canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n","test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n","entry_point":"f"}
{"task_id":"HumanEval\/107","prompt":"def even_odd_palindrome(n):\n    \"\"\"\n    ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇੱਕ ਟਪਲ ਵਾਪਸ ਕਰੋ ਜਿਸ ਵਿੱਚ ਉਹ ਗਿਣਤੀ ਹੈ ਜੋ ਸਮਾਂ ਅਤੇ ਵਿਸਮਾਂ ਪੂਰਨ ਅੰਕ ਪੈਲਿੰਡਰੋਮ ਹਨ ਜੋ ਸੀਮਾ(1, n) ਵਿੱਚ ਆਉਂਦੇ ਹਨ, ਸਮਾਵੇਸ਼ੀ.\n\n    ਉਦਾਹਰਣ 1:\n\n        ਇੰਪੁੱਟ: 3\n        ਆਉਟਪੁੱਟ: (1, 2)\n        ਵਿਆਖਿਆ:\n        ਪੂਰਨ ਅੰਕ ਪੈਲਿੰਡਰੋਮ 1, 2, 3 ਹਨ। ਉਨ੍ਹਾਂ ਵਿੱਚੋਂ ਇੱਕ ਸਮਾਂ ਹੈ, ਅਤੇ ਦੋ ਵਿਸਮਾਂ ਹਨ।\n\n    ਉਦਾਹਰਣ 2:\n\n        ਇੰਪੁੱਟ: 12\n        ਆਉਟਪੁੱਟ: (4, 6)\n        ਵਿਆਖਿਆ:\n        ਪੂਰਨ ਅੰਕ ਪੈਲਿੰਡਰੋਮ 1, 2, 3, 4, 5, 6, 7, 8, 9, 11 ਹਨ। ਉਨ੍ਹਾਂ ਵਿੱਚੋਂ ਚਾਰ ਸਮਾਂ ਹਨ, ਅਤੇ 6 ਵਿਸਮਾਂ ਹਨ।\n\n    ਨੋਟ:\n        1. 1 <= n <= 10^3\n        2. ਵਾਪਸ ਕੀਤੇ ਗਏ ਟਪਲ ਵਿੱਚ ਸਮਾਂ ਅਤੇ ਵਿਸਮਾਂ ਪੂਰਨ ਅੰਕ ਪੈਲਿੰਡਰੋਮ ਦੀ ਗਿਣਤੀ ਅਨੁਸਾਰ ਹੈ।\n    \"\"\"\n","canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"even_odd_palindrome"}
{"task_id":"HumanEval\/108","prompt":"def count_nums(arr):\n    \"\"\"\n    ਇੱਕ ਫੰਕਸ਼ਨ count_nums ਲਿਖੋ ਜੋ ਇੱਕ ਪੂਰਨਾਂਕਾਂ ਦੀ ਐਰੇ ਲੈਂਦਾ ਹੈ ਅਤੇ ਉਹਨਾਂ ਅੰਕਾਂ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜਿਸਦਾ ਅੰਕਾਂ ਦਾ ਜੋੜ > 0 ਹੈ।\n    ਜੇਕਰ ਕੋਈ ਨੰਬਰ ਨੈਗੇਟਿਵ ਹੈ, ਤਾਂ ਉਸਦਾ ਪਹਿਲਾ ਸਾਈਨ ਵਾਲਾ ਅੰਕ ਵੀ ਨੈਗੇਟਿਵ ਹੋਵੇਗਾ:\n    ਉਦਾਹਰਣ ਵਜੋਂ -123 ਦੇ ਸਾਈਨ ਵਾਲੇ ਅੰਕ -1, 2, ਅਤੇ 3 ਹਨ।\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n","canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"count_nums"}
{"task_id":"HumanEval\/109","prompt":"def move_one_ball(arr):\n    \"\"\"ਅਸੀਂ ਕੋਲ 'arr' ਨਾਮ ਦੀ ਇੱਕ array ਹੈ ਜਿਸ ਵਿੱਚ N ਪੂਰਨਾਂਕ ਹਨ arr[1], arr[2], ..., arr[N]. ਇਸ array ਵਿੱਚ ਅੰਕ ਬੇਤਰਤੀਬ ਢੰਗ ਨਾਲ ਹੋਣਗੇ। ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਤੈਅ ਕਰਨਾ ਹੈ ਕਿ ਕੀ ਇਸ array ਨੂੰ ਗੈਰ-ਘਟਦੇ ਕ੍ਰਮ ਵਿੱਚ ਲਿਆਉਣਾ ਸੰਭਵ ਹੈ ਜੇਕਰ ਦਿੱਤੀ ਗਈ array 'ਤੇ ਹੇਠ ਲਿਖੇ ਕੰਮ ਨੂੰ ਅੰਜਾਮ ਦਿੱਤਾ ਜਾਵੇ:\n        ਤੁਸੀਂ ਕਿਸੇ ਵੀ ਗਿਣਤੀ ਵਿੱਚ ਸੱਜੇ ਪਾਸੇ ਸ਼ਿਫਟ ਕਾਰਵਾਈ ਕਰਨ ਦੀ ਆਗਿਆ ਹੈ।\n    \n    ਇੱਕ ਸੱਜੇ ਪਾਸੇ ਸ਼ਿਫਟ ਕਾਰਵਾਈ ਦਾ ਮਤਲਬ ਹੈ ਕਿ array ਦੇ ਸਾਰੇ ਅੰਕਾਂ ਨੂੰ ਇੱਕ ਸਥਾਨ ਸੱਜੇ ਦਿਸ਼ਾ ਵਿੱਚ ਸ਼ਿਫਟ ਕਰਨਾ। Array ਦਾ ਆਖਰੀ ਅੰਕ ਸ਼ੁਰੂਆਤੀ ਸਥਾਨ ਤੇ ਚਲਾ ਜਾਵੇਗਾ ਯਾਨੀ 0ਵੇਂ ਇੰਡੈਕਸ 'ਤੇ।\n\n    ਜੇਕਰ ਉਪਰੋਕਤ ਕਾਰਵਾਈ ਕਰਕੇ ਸੋਰਟ ਕੀਤੀ array ਪ੍ਰਾਪਤ ਕਰਨਾ ਸੰਭਵ ਹੋਵੇ ਤਾਂ True ਵਾਪਸ ਕਰੋ ਨਹੀਂ ਤਾਂ False ਵਾਪਸ ਕਰੋ।\n    ਜੇਕਰ ਦਿੱਤੀ ਗਈ array ਖਾਲੀ ਹੈ ਤਾਂ True ਵਾਪਸ ਕਰੋ।\n\n    ਨੋਟ: ਦਿੱਤੀ ਗਈ ਸੂਚੀ ਵਿੱਚ ਅਨੋਖੇ ਅੰਕ ਹੋਣ ਦੀ ਗਾਰੰਟੀ ਹੈ।\n\n    ਉਦਾਹਰਣ ਲਈ:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    ਵਿਆਖਿਆ: 2 ਸੱਜੇ ਪਾਸੇ ਸ਼ਿਫਟ ਕਾਰਵਾਈਆਂ ਕਰਕੇ, ਗੈਰ-ਘਟਦੇ ਕ੍ਰਮ ਨੂੰ ਦਿੱਤੀ ਗਈ array ਲਈ ਪ੍ਰਾਪਤ ਕੀਤਾ ਜਾ ਸਕਦਾ ਹੈ।\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    ਵਿਆਖਿਆ:ਕਿਸੇ ਵੀ ਗਿਣਤੀ ਦੀ ਸੱਜੇ ਪਾਸੇ ਸ਼ਿਫਟ ਕਾਰਵਾਈਆਂ ਕਰਕੇ ਦਿੱਤੀ ਗਈ array ਲਈ ਗੈਰ-ਘਟਦੇ ਕ੍ਰਮ ਪ੍ਰਾਪਤ ਕਰਨਾ ਸੰਭਵ ਨਹੀਂ ਹੈ।\n                \n    \"\"\"","canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n","entry_point":"move_one_ball"}
{"task_id":"HumanEval\/110","prompt":"def exchange(lst1, lst2):\n    \"\"\"ਇਸ ਸਮੱਸਿਆ ਵਿੱਚ, ਤੁਹਾਨੂੰ ਇੱਕ ਫੰਕਸ਼ਨ ਲਾਗੂ ਕਰਨ ਦੀ ਲੋੜ ਹੈ ਜੋ ਦੋ ਸੂਚੀਆਂ ਦੇ ਅੰਕਾਂ ਨੂੰ ਲੈਂਦਾ ਹੈ,\n    ਅਤੇ ਇਹ ਨਿਰਧਾਰਿਤ ਕਰਦਾ ਹੈ ਕਿ ਕੀ ਉਹਨਾਂ ਵਿਚਕਾਰ ਅੰਕਾਂ ਦੀ ਅਦਲਾ-ਬਦਲੀ ਕਰਨਾ ਸੰਭਵ ਹੈ\n    ਤਾਂ ਜੋ lst1 ਨੂੰ ਸਿਰਫ ਜੋੜੇ ਅੰਕਾਂ ਵਾਲੀ ਸੂਚੀ ਬਣਾਇਆ ਜਾ ਸਕੇ।\n    lst1 ਅਤੇ lst2 ਵਿਚਕਾਰ ਅਦਲਾ-ਬਦਲੀ ਕੀਤੇ ਗਏ ਅੰਕਾਂ ਦੀ ਗਿਣਤੀ 'ਤੇ ਕੋਈ ਸੀਮਾ ਨਹੀਂ ਹੈ।\n    ਜੇ lst1 ਅਤੇ lst2 ਵਿਚਕਾਰ ਅੰਕਾਂ ਦੀ ਅਦਲਾ-ਬਦਲੀ ਕਰਨਾ ਸੰਭਵ ਹੋਵੇ ਤਾਂ ਜੋ\n    lst1 ਦੇ ਸਾਰੇ ਅੰਕ ਜੋੜੇ ਹੋਣ, ਤਾਂ \"YES\" ਪਰਤਾਓ।\n    ਨਹੀਂ ਤਾਂ, \"NO\" ਪਰਤਾਓ।\n    ਉਦਾਹਰਣ ਲਈ:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    ਇਹ ਮੰਨਿਆ ਜਾਂਦਾ ਹੈ ਕਿ ਇਨਪੁੱਟ ਸੂਚੀਆਂ ਖਾਲੀ ਨਹੀਂ ਹੋਣਗੀਆਂ।\n    \"\"\"","canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n","entry_point":"exchange"}
{"task_id":"HumanEval\/111","prompt":"def histogram(test):\n    \"\"\"ਇੱਕ ਸਟਰਿੰਗ ਦਿੱਤੀ ਗਈ ਹੈ ਜੋ ਇੱਕ ਸਪੇਸ ਵਿੱਚ ਵੱਖ ਕੀਤੇ ਗਏ ਲੋਅਰਕੇਸ ਅੱਖਰਾਂ ਨੂੰ ਦਰਸਾਉਂਦੀ ਹੈ, ਸਭ ਤੋਂ ਵੱਧ ਦੁਹਰਾਏ ਗਏ ਅੱਖਰ ਅਤੇ ਉਸ ਨਾਲ ਜੁੜੇ ਗਿਣਤੀ ਨਾਲ ਇੱਕ ਡਿਕਸ਼ਨਰੀ ਵਾਪਸ ਕਰੋ।\n    ਜੇਕਰ ਕਈ ਅੱਖਰਾਂ ਦੀ ਘਟਨਾ ਇੱਕੋ ਜਿਹੀ ਹੈ, ਤਾਂ ਉਹਨਾਂ ਸਭ ਨੂੰ ਵਾਪਸ ਕਰੋ।\n    \n    ਉਦਾਹਰਣ:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n\n    \"\"\"","canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n","entry_point":"histogram"}
{"task_id":"HumanEval\/112","prompt":"def reverse_delete(s,c):\n    \"\"\"ਟਾਸਕ\n    ਸਾਨੂੰ ਦੋ ਸਟਰਿੰਗਸ s ਅਤੇ c ਦਿੱਤੀਆਂ ਗਈਆਂ ਹਨ, ਤੁਹਾਨੂੰ s ਵਿੱਚੋਂ ਉਹ ਸਾਰੇ ਅੱਖਰ ਮਿਟਾਉਣੇ ਪੈਣਗੇ ਜੋ c ਵਿੱਚ ਕਿਸੇ ਵੀ ਅੱਖਰ ਦੇ ਬਰਾਬਰ ਹਨ\n    ਫਿਰ ਚੈੱਕ ਕਰੋ ਕਿ ਨਤੀਜਾ ਸਟਰਿੰਗ ਪੈਲਿੰਡਰੋਮ ਹੈ ਜਾਂ ਨਹੀਂ।\n    ਜੇਕਰ ਕੋਈ ਸਟਰਿੰਗ ਪਿੱਛੇ ਤੋਂ ਅੱਗੇ ਵੱਲ ਪੜ੍ਹਨ 'ਤੇ ਇੱਕੋ ਜਿਹੀ ਲੱਗੇ, ਤਾਂ ਉਸ ਨੂੰ ਪੈਲਿੰਡਰੋਮ ਕਿਹਾ ਜਾਂਦਾ ਹੈ।\n    ਤੁਹਾਨੂੰ ਇੱਕ ਟਪਲ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਨਤੀਜਾ ਸਟਰਿੰਗ ਅਤੇ ਚੈੱਕ ਲਈ ਸੱਚ\/ਝੂਠ ਹੋਵੇ।\n    ਉਦਾਹਰਣ\n    ਜੇ s = \"abcde\", c = \"ae\", ਤਾਂ ਨਤੀਜਾ ਹੋਵੇਗਾ ('bcd',False)\n    ਜੇ s = \"abcdef\", c = \"b\" ਤਾਂ ਨਤੀਜਾ ਹੋਵੇਗਾ ('acdef',False)\n    ਜੇ s = \"abcdedcba\", c = \"ab\", ਤਾਂ ਨਤੀਜਾ ਹੋਵੇਗਾ ('cdedc',True)\n    \"\"\"\n","canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n","test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n","entry_point":"reverse_delete"}
{"task_id":"HumanEval\/113","prompt":"def odd_count(lst):\n    \"\"\"ਇੱਕ ਸਟਰਿੰਗਾਂ ਦੀ ਸੂਚੀ ਦਿੱਤੀ ਗਈ ਹੈ, ਜਿੱਥੇ ਹਰ ਸਟਰਿੰਗ ਵਿੱਚ ਕੇਵਲ ਅੰਕ ਹੁੰਦੇ ਹਨ, ਇੱਕ ਸੂਚੀ ਵਾਪਸ ਕਰੋ।\n    ਆਉਟਪੁਟ ਦਾ ਹਰ ਤੱਤ i \"ਇੰਪੁਟ ਦੀ ਸਟਰਿੰਗ i ਵਿੱਚ ਅਜੀਬ ਤੱਤਾਂ ਦੀ ਗਿਣਤੀ\" ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ। ਜਿੱਥੇ ਸਾਰੇ i ਨੂੰ ਇੰਪੁਟ ਦੀ i ਵੀਂ ਸਟਰਿੰਗ ਵਿੱਚ ਅਜੀਬ ਅੰਕਾਂ ਦੀ ਗਿਣਤੀ ਨਾਲ ਬਦਲਿਆ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ।\n\n    >>> odd_count(['1234567'])\n    [\"ਇੰਪੁਟ ਦੀ ਸਟਰਿੰਗ 4 ਵਿੱਚ ਅਜੀਬ ਤੱਤਾਂ ਦੀ ਗਿਣਤੀ 4 ਹੈ।\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"ਇੰਪੁਟ ਦੀ ਸਟਰਿੰਗ 1 ਵਿੱਚ ਅਜੀਬ ਤੱਤਾਂ ਦੀ ਗਿਣਤੀ 1 ਹੈ।\",\n     \"ਇੰਪੁਟ ਦੀ ਸਟਰਿੰਗ 8 ਵਿੱਚ ਅਜੀਬ ਤੱਤਾਂ ਦੀ ਗਿਣਤੀ 8 ਹੈ।\"]\n    \"\"\"\n","canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"odd_count"}
{"task_id":"HumanEval\/114","prompt":"def minSubArraySum(nums):\n    \"\"\"\n    ਇੱਕ ਪੂਰਨਾਂਕਾਂ ਦੀ ਐਰੇ nums ਦਿੱਤੀ ਗਈ ਹੈ, ਇਸ nums ਦੇ ਕਿਸੇ ਵੀ ਨਾਂ-ਖਾਲੀ ਉਪ-ਐਰੇ ਦਾ ਘੱਟੋ-ਘੱਟ ਜੋੜ ਲੱਭੋ।\n    ਉਦਾਹਰਣ\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n","canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n","entry_point":"minSubArraySum"}
{"task_id":"HumanEval\/115","prompt":"def max_fill(grid, capacity):\n    import math\n    \"\"\"\n    ਤੁਹਾਨੂੰ ਇੱਕ ਚੌਕੋਰ ਗ੍ਰਿਡ ਦੇ ਕੁਆਂ ਦਿੱਤੇ ਗਏ ਹਨ। ਹਰ ਕਤਾਰ ਇੱਕ ਵਿਅਕਤੀ ਕੁਆਂ ਨੂੰ ਦਰਸਾਉਂਦੀ ਹੈ,\n    ਅਤੇ ਕਤਾਰ ਵਿੱਚ ਹਰੇਕ 1 ਇੱਕ ਇਕਾਈ ਪਾਣੀ ਨੂੰ ਦਰਸਾਉਂਦਾ ਹੈ।\n    ਹਰੇਕ ਕੁਆਂ ਦੇ ਨਾਲ ਇੱਕ ਬਾਲਟੀ ਹੁੰਦੀ ਹੈ ਜਿਸ ਨੂੰ ਪਾਣੀ ਕੱਢਣ ਲਈ ਵਰਤਿਆ ਜਾ ਸਕਦਾ ਹੈ,\n    ਅਤੇ ਸਾਰੀਆਂ ਬਾਲਟੀਆਂ ਦੀ ਸਮਰੱਥਾ ਇੱਕੋ ਜਿਹੀ ਹੁੰਦੀ ਹੈ।\n    ਤੁਹਾਡਾ ਕੰਮ ਕੁਆਂਆਂ ਨੂੰ ਖਾਲੀ ਕਰਨ ਲਈ ਬਾਲਟੀਆਂ ਦੀ ਵਰਤੋਂ ਕਰਨਾ ਹੈ।\n    ਤੁਸੀਂ ਕਿੰਨੀ ਵਾਰ ਬਾਲਟੀਆਂ ਨੂੰ ਹੇਠਾਂ ਲਾਉਣ ਦੀ ਲੋੜ ਹੈ, ਉਸ ਦੀ ਗਿਣਤੀ ਦੱਸੋ।\n\n    ਉਦਾਹਰਣ 1:\n        ਇੰਪੁੱਟ: \n            ਗ੍ਰਿਡ : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            ਬਾਲਟੀ_ਸਮਰੱਥਾ : 1\n        ਆਉਟਪੁੱਟ: 6\n\n    ਉਦਾਹਰਣ 2:\n        ਇੰਪੁੱਟ: \n            ਗ੍ਰਿਡ : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            ਬਾਲਟੀ_ਸਮਰੱਥਾ : 2\n        ਆਉਟਪੁੱਟ: 5\n    \n    ਉਦਾਹਰਣ 3:\n        ਇੰਪੁੱਟ: \n            ਗ੍ਰਿਡ : [[0,0,0], [0,0,0]]\n            ਬਾਲਟੀ_ਸਮਰੱਥਾ : 5\n        ਆਉਟਪੁੱਟ: 0\n\n    ਬੰਦਿਸ਼ਾਂ:\n        * ਸਾਰੇ ਕੁਆਂਆਂ ਦੀ ਲੰਬਾਈ ਇੱਕੋ ਜਿਹੀ ਹੁੰਦੀ ਹੈ\n        * 1 <= ਗ੍ਰਿਡ.ਲੰਬਾਈ <= 10^2\n        * 1 <= ਗ੍ਰਿਡ[:,1].ਲੰਬਾਈ <= 10^2\n        * ਗ੍ਰਿਡ[i][j] -> 0 | 1\n        * 1 <= ਸਮਰੱਥਾ <= 10\n    \"\"\"\n","canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n","test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n","entry_point":"max_fill"}
{"task_id":"HumanEval\/116","prompt":"def sort_array(arr):\n    \"\"\"\n    ਇਸ ਕਾਤਾ ਵਿੱਚ, ਤੁਹਾਨੂੰ ਇੱਕ ਅਰੇਅ ਨੂੰ ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨਾਂਕਾਂ ਦੇ ਅਨੁਸਾਰ ਸੋਰਟ ਕਰਨਾ ਹੈ\n    ਉਨ੍ਹਾਂ ਦੇ ਬਾਇਨਰੀ ਪ੍ਰਤੀਨਿਧਤਵ ਵਿੱਚ ਇੱਕਾਂ ਦੀ ਗਿਣਤੀ ਅਨੁਸਾਰ ਚੜ੍ਹਦੇ ਕ੍ਰਮ ਵਿੱਚ।\n    ਇੱਕਾਂ ਦੀ ਸਮਾਨ ਗਿਣਤੀ ਲਈ, ਦਸਮਲਵ ਮੁੱਲ ਦੇ ਆਧਾਰ 'ਤੇ ਸੋਰਟ ਕਰੋ।\n\n    ਇਸ ਨੂੰ ਇਸ ਤਰ੍ਹਾਂ ਲਾਗੂ ਕੀਤਾ ਜਾਣਾ ਚਾਹੀਦਾ ਹੈ:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n","canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"sort_array"}
{"task_id":"HumanEval\/117","prompt":"def select_words(s, n):\n    \"\"\"ਇੱਕ ਸਟਰਿੰਗ s ਅਤੇ ਇੱਕ ਕੁਦਰਤੀ ਸੰਖਿਆ n ਦਿੱਤੀ ਗਈ ਹੈ, ਤੁਹਾਨੂੰ ਇੱਕ ਫੰਕਸ਼ਨ ਲਾਗੂ ਕਰਨ ਦਾ ਕੰਮ ਸੌਂਪਿਆ ਗਿਆ ਹੈ ਜੋ ਸਟਰਿੰਗ s ਵਿੱਚੋਂ ਸਾਰੇ ਸ਼ਬਦਾਂ ਦੀ ਸੂਚੀ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਠੀਕ n ਵਿਅੰਜਨ ਹਨ, ਉਸ ਕ੍ਰਮ ਵਿੱਚ ਜਿਸ ਕ੍ਰਮ ਵਿੱਚ ਇਹ ਸ਼ਬਦ ਸਟਰਿੰਗ s ਵਿੱਚ ਆਉਂਦੇ ਹਨ।\n    ਜੇ ਸਟਰਿੰਗ s ਖਾਲੀ ਹੈ ਤਾਂ ਫੰਕਸ਼ਨ ਨੂੰ ਇੱਕ ਖਾਲੀ ਸੂਚੀ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ।\n    ਨੋਟ: ਤੁਸੀਂ ਮਾਨ ਸਕਦੇ ਹੋ ਕਿ ਇੰਪੁੱਟ ਸਟਰਿੰਗ ਵਿੱਚ ਕੇਵਲ ਅੱਖਰ ਅਤੇ ਸਪੇਸ ਹੀ ਹਨ।\n    ਉਦਾਹਰਣ:\n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"","canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n","entry_point":"select_words"}
{"task_id":"HumanEval\/118","prompt":"def get_closest_vowel(word):\n    \"\"\"ਤੁਹਾਨੂੰ ਇੱਕ ਸ਼ਬਦ ਦਿੱਤਾ ਗਿਆ ਹੈ। ਤੁਹਾਡਾ ਕੰਮ ਹੈ ਕਿ ਸ਼ਬਦ ਦੇ ਸੱਜੇ ਪਾਸੇ ਤੋਂ ਦੋ ਵਿਅੰਜਨਾਂ ਦੇ ਵਿਚਕਾਰ ਖੜ੍ਹੇ ਸਭ ਤੋਂ ਨੇੜਲੇ ਸਵਰ ਨੂੰ ਲੱਭੋ (case sensitive)।\n    \n    ਸ਼ੁਰੂਆਤ ਅਤੇ ਅੰਤ ਵਿੱਚ ਦੇ ਸਵਰ ਗਿਣੇ ਨਹੀਂ ਜਾਂਦੇ। ਜੇਕਰ ਤੁਸੀਂ ਕੋਈ ਵੀ ਸਵਰ ਨਾ ਲੱਭੋ ਜੋ ਉਪਰੋਕਤ ਸ਼ਰਤ ਨੂੰ ਪੂਰਾ ਕਰਦਾ ਹੋਵੇ, ਤਾਂ ਖਾਲੀ ਸਟਰਿੰਗ ਵਾਪਸ ਕਰੋ।\n\n    ਤੁਸੀਂ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ ਦਿੱਤੀ ਗਈ ਸਟਰਿੰਗ ਵਿੱਚ ਸਿਰਫ ਅੰਗਰੇਜ਼ੀ ਅੱਖਰ ਹੀ ਹਨ।\n\n    ਉਦਾਹਰਣ:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"","canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"get_closest_vowel"}
{"task_id":"HumanEval\/119","prompt":"def match_parens(lst):\n    '''\n    ਤੁਹਾਨੂੰ ਦੋ ਸਟਰਿੰਗਾਂ ਦੀ ਇੱਕ ਸੂਚੀ ਦਿੱਤੀ ਗਈ ਹੈ, ਦੋਵੇਂ ਸਟਰਿੰਗਾਂ ਵਿੱਚ ਸਿਰਫ ਖੁੱਲ੍ਹੇ ਹੋਏ ਕੋਸ਼ ('(') ਜਾਂ ਬੰਦ ਕੋਸ਼ (')') ਹੀ ਹੁੰਦੇ ਹਨ।\n    ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਚੈੱਕ ਕਰਨਾ ਹੈ ਕਿ ਕੀ ਦੋਵੇਂ ਸਟਰਿੰਗਾਂ ਨੂੰ ਕਿਸੇ ਵੀ ਕ੍ਰਮ ਵਿੱਚ ਜੋੜ ਕੇ ਇੱਕ ਚੰਗੀ ਸਟਰਿੰਗ ਬਣਾਈ ਜਾ ਸਕਦੀ ਹੈ ਜਾਂ ਨਹੀਂ।\n    ਇੱਕ ਸਟਰਿੰਗ S ਨੂੰ ਤਦ ਹੀ ਚੰਗੀ ਮੰਨਿਆ ਜਾਂਦਾ ਹੈ ਜੇਕਰ S ਵਿੱਚ ਸਾਰੇ ਕੋਸ਼ ਸੰਤੁਲਿਤ ਹੋਣ। ਉਦਾਹਰਣ ਵਜੋਂ: ਸਟਰਿੰਗ '(())()' ਚੰਗੀ ਹੈ, ਜਦਕਿ ਸਟਰਿੰਗ '())' ਨਹੀਂ ਹੈ।\n    ਜੇਕਰ ਚੰਗੀ ਸਟਰਿੰਗ ਬਣਾਉਣ ਦਾ ਕੋਈ ਤਰੀਕਾ ਹੈ ਤਾਂ 'Yes' ਵਾਪਸ ਕਰੋ, ਅਤੇ ਨਹੀਂ ਤਾਂ 'No' ਵਾਪਸ ਕਰੋ।\n\n    ਉਦਾਹਰਣ:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n","canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n","entry_point":"match_parens"}
{"task_id":"HumanEval\/120","prompt":"def maximum(arr, k):\n    \"\"\"\n    ਇੱਕ ਐਰੇ arr ਵਿੱਚ ਪੂਰਨਾਂਕ ਅਤੇ ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨਾਂਕ k ਦਿੱਤਾ ਗਿਆ ਹੈ, arr ਵਿੱਚੋਂ ਸਭ ਤੋਂ ਵੱਡੇ k ਨੰਬਰਾਂ ਵਾਲੀ ਇੱਕ ਕ੍ਰਮਬੱਧ ਸੂਚੀ ਨੂੰ ਵਾਪਸ ਕਰੋ।\n\n    ਉਦਾਹਰਣ 1:\n\n        ਇੰਪੁੱਟ: arr = [-3, -4, 5], k = 3\n        ਆਉਟਪੁੱਟ: [-4, -3, 5]\n\n    ਉਦਾਹਰਣ 2:\n\n        ਇੰਪੁੱਟ: arr = [4, -4, 4], k = 2\n        ਆਉਟਪੁੱਟ: [4, 4]\n\n    ਉਦਾਹਰਣ 3:\n\n        ਇੰਪੁੱਟ: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        ਆਉਟਪੁੱਟ: [2]\n\n    ਨੋਟ:\n        1. ਐਰੇ ਦੀ ਲੰਬਾਈ [1, 1000] ਦੇ ਦਾਇਰੇ ਵਿੱਚ ਹੋਵੇਗੀ।\n        2. ਐਰੇ ਵਿੱਚ ਅੰਕ [1000, 1000] ਦੇ ਦਾਇਰੇ ਵਿੱਚ ਹੋਣਗੇ।\n        3. 0 <= k <= len(arr)\n    \"\"\"","canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n","entry_point":"maximum"}
{"task_id":"HumanEval\/121","prompt":"def solution(lst):\n    \"\"\"ਇੱਕ ਨਾ-ਖਾਲੀ ਸੂਚੀ ਵਿੱਚੋਂ ਸਾਰੇ ਅਜੀਬ ਅੰਕਾਂ ਦਾ ਜੋੜ ਮੁੜ ਦਿਓ ਜੋ ਸਮਾਂ ਸਥਾਨਾਂ ਵਿੱਚ ਹਨ।\n    \n\n    ਉਦਾਹਰਣਾਂ\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"\n","canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n","entry_point":"solution"}
{"task_id":"HumanEval\/122","prompt":"def add_elements(arr, k):\n    \"\"\"\n    ਇੱਕ ਨਾ-ਖਾਲੀ ਪੂਰਨਾਂਕਾਂ ਦੀ ਐਰੇ arr ਅਤੇ ਇੱਕ ਪੂਰਨਾਂਕ k ਦਿੱਤਾ ਗਿਆ ਹੈ, arr ਦੇ ਪਹਿਲੇ k ਤੱਤਾਂ ਵਿੱਚੋਂ ਦੋ ਅੰਕਾਂ ਤੱਕ ਦੇ ਤੱਤਾਂ ਦਾ ਜੋੜ ਮੁੜ ਕੇ ਦਿਓ।\n\n    ਉਦਾਹਰਣ:\n\n        ਇੰਪੁੱਟ: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        ਆਉਟਪੁੱਟ: 24 # 21 + 3 ਦਾ ਜੋੜ\n\n    ਬੰਧਨ:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \"\"\"\n","canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"add_elements"}
{"task_id":"HumanEval\/123","prompt":"def get_odd_collatz(n):\n    \"\"\"\n    ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਹੋਇਆ, ਇੱਕ ਵਧਦੇ ਕ੍ਰਮ ਵਿੱਚ ਸੋਰਟ ਕੀਤੀ ਹੋਈ ਸੂਚੀ ਪ੍ਰਦਾਨ ਕਰੋ ਜਿਸ ਵਿੱਚ collatz ਲੜੀ ਦੇ ਵਿਚਕਾਰਲੇ ਅੰਕ ਹੋਣ।\n\n    Collatz ਕਲਪਨਾ ਗਣਿਤ ਵਿੱਚ ਇੱਕ ਕਲਪਨਾ ਹੈ ਜੋ ਇੱਕ ਲੜੀ ਨਾਲ ਸਬੰਧਤ ਹੈ ਜੋ ਇਸ ਪ੍ਰਕਾਰ ਪਰਿਭਾਸ਼ਿਤ ਹੈ: ਕਿਸੇ ਵੀ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਨਾਲ ਸ਼ੁਰੂ ਕਰੋ। ਫਿਰ ਹਰ ਪਦ ਪਿਛਲੇ ਪਦ ਤੋਂ ਇਸ ਪ੍ਰਕਾਰ ਪ੍ਰਾਪਤ ਕੀਤਾ ਜਾਂਦਾ ਹੈ: ਜੇ ਪਿਛਲਾ ਪਦ ਸਮਾਨ ਹੈ, ਅਗਲਾ ਪਦ ਪਿਛਲੇ ਪਦ ਦਾ ਅੱਧਾ ਹੈ। ਜੇ ਪਿਛਲਾ ਪਦ ਵਿਚਕਾਰਲਾ ਹੈ, ਅਗਲਾ ਪਦ ਪਿਛਲੇ ਪਦ ਦਾ ਤਿੰਨ ਗੁਣਾ ਪਲੱਸ 1 ਹੈ। ਕਲਪਨਾ ਇਹ ਹੈ ਕਿ ਕੋਈ ਵੀ n ਦੀ ਕੀਮਤ ਹੋਵੇ, ਲੜੀ ਹਮੇਸ਼ਾ 1 ਤੱਕ ਪਹੁੰਚ ਜਾਵੇਗੀ।\n\n    ਨੋਟ: \n        1. Collatz(1) ਹੈ [1].\n        2. ਵਾਪਸੀ ਵਾਲੀ ਸੂਚੀ ਵਧਦੇ ਕ੍ਰਮ ਵਿੱਚ ਸੋਰਟ ਕੀਤੀ ਗਈ ਹੈ।\n\n    ਉਦਾਹਰਣ ਲਈ:\n    get_odd_collatz(5) ਵਾਪਸ ਕਰਦਾ ਹੈ [1, 5] # 5 ਲਈ collatz ਲੜੀ [5, 16, 8, 4, 2, 1] ਹੈ, ਇਸ ਲਈ ਵਿਚਕਾਰਲੇ ਅੰਕ ਸਿਰਫ 1, ਅਤੇ 5 ਹਨ।\n    \"\"\"\n","canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"get_odd_collatz"}
{"task_id":"HumanEval\/124","prompt":"def valid_date(date):\n    \"\"\"ਤੁਹਾਨੂੰ ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖਣੀ ਹੈ ਜੋ ਦਿੱਤੀ ਗਈ ਤਾਰੀਖ ਦੀ ਸਟਰਿੰਗ ਦੀ ਪੁਸ਼ਟੀ ਕਰਦੀ ਹੈ ਅਤੇ \n    ਜੇ ਤਾਰੀਖ ਵੈਧ ਹੈ ਤਾਂ True ਵਾਪਸ ਕਰਦੀ ਹੈ ਨਹੀਂ ਤਾਂ False.\n    ਤਾਰੀਖ ਤਦ ਵੈਧ ਹੈ ਜਦੋਂ ਹੇਠ ਲਿਖੇ ਸਾਰੇ ਨਿਯਮ ਪੂਰੇ ਹੋਣ:\n    1. ਤਾਰੀਖ ਦੀ ਸਟਰਿੰਗ ਖਾਲੀ ਨਹੀਂ ਹੋਣੀ ਚਾਹੀਦੀ.\n    2. ਦਿਨਾਂ ਦੀ ਗਿਣਤੀ 1 ਤੋਂ ਘੱਟ ਜਾਂ 31 ਦਿਨਾਂ ਤੋਂ ਵੱਧ ਮਹੀਨਿਆਂ 1,3,5,7,8,10,12 ਲਈ ਨਹੀਂ ਹੋਣੀ ਚਾਹੀਦੀ. ਅਤੇ ਦਿਨਾਂ ਦੀ ਗਿਣਤੀ 1 ਤੋਂ ਘੱਟ ਜਾਂ 30 ਦਿਨਾਂ ਤੋਂ ਵੱਧ ਮਹੀਨਿਆਂ 4,6,9,11 ਲਈ ਨਹੀਂ ਹੋਣੀ ਚਾਹੀਦੀ. ਅਤੇ, ਦਿਨਾਂ ਦੀ ਗਿਣਤੀ 1 ਤੋਂ ਘੱਟ ਜਾਂ 29 ਤੋਂ ਵੱਧ ਮਹੀਨਾ 2 ਲਈ ਨਹੀਂ ਹੋਣੀ ਚਾਹੀਦੀ.\n    3. ਮਹੀਨੇ 1 ਤੋਂ ਘੱਟ ਜਾਂ 12 ਤੋਂ ਵੱਧ ਨਹੀਂ ਹੋਣੇ ਚਾਹੀਦੇ.\n    4. ਤਾਰੀਖ ਇਸ ਫਾਰਮੈਟ ਵਿੱਚ ਹੋਣੀ ਚਾਹੀਦੀ: mm-dd-yyyy\n\n    ਉਦਾਹਰਣ ਲਈ: \n    valid_date('03-11-2000') => True\n\n    valid_date('15-01-2012') => False\n\n    valid_date('04-0-2040') => False\n\n    valid_date('06-04-2020') => True\n\n    valid_date('06\/04\/2020') => False\n    \"\"\"","canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n","entry_point":"valid_date"}
{"task_id":"HumanEval\/125","prompt":"def split_words(txt):\n    '''\n    ਇੱਕ ਸ਼ਬਦਾਂ ਦੀ ਸਟਰਿੰਗ ਦਿੱਤੀ ਗਈ ਹੈ, ਸਫੇਦ ਥਾਂ ਤੇ ਵੰਡੇ ਗਏ ਸ਼ਬਦਾਂ ਦੀ ਇੱਕ ਸੂਚੀ ਵਾਪਸ ਕਰੋ, ਜੇ ਪਾਠ ਵਿੱਚ ਕੋਈ ਸਫੇਦ ਥਾਂ ਮੌਜੂਦ ਨਹੀਂ ਹੈ ਤਾਂ ਤੁਸੀਂ\n    ਕਾਮਿਆਂ ',' ਤੇ ਵੰਡਣਾ ਚਾਹੀਦਾ ਹੈ, ਜੇ ਕੋਈ ਕਾਮਾ ਮੌਜੂਦ ਨਹੀਂ ਹੈ ਤਾਂ ਤੁਸੀਂ ਅਜੀਬ ਕ੍ਰਮ ਵਾਲੇ ਛੋਟੇ-ਅੱਖਰ ਵਾਲੇ ਅੱਖਰਾਂ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ\n    ਵਰਣਮਾਲਾ ਵਿੱਚ, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    ਉਦਾਹਰਣ\n    split_words(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n","canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n","test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n","entry_point":"split_words"}
{"task_id":"HumanEval\/126","prompt":"def is_sorted(lst):\n    '''\n    ਦਿੱਤੀ ਗਈ ਸੰਖਿਆਵਾਂ ਦੀ ਸੂਚੀ ਦੇਖੋ ਅਤੇ ਦੱਸੋ ਕਿ ਉਹ ਆਰੋਹੀ ਕ੍ਰਮ ਵਿੱਚ ਲੜੀਬੱਧ ਹਨ ਜਾਂ ਨਹੀਂ। ਜੇ ਸੂਚੀ ਵਿੱਚ ਇੱਕੋ ਸੰਖਿਆ ਦੀ ਇੱਕ ਤੋਂ ਵੱਧ ਨਕਲ ਹੈ, ਤਾਂ False ਮੁੜੋ। ਮਾਨ ਲਵੋ ਕਿ ਕੋਈ ਨਕਾਰਾਤਮਕ ਸੰਖਿਆ ਨਹੀਂ ਹੈ ਅਤੇ ਸਿਰਫ ਪੂਰਨਾਂਕ ਹਨ।\n\n    ਉਦਾਹਰਣ\n    is_sorted([5]) ➞ True\n    is_sorted([1, 2, 3, 4, 5]) ➞ True\n    is_sorted([1, 3, 2, 4, 5]) ➞ False\n    is_sorted([1, 2, 3, 4, 5, 6]) ➞ True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) ➞ True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) ➞ False\n    is_sorted([1, 2, 2, 3, 3, 4]) ➞ True\n    is_sorted([1, 2, 2, 2, 3, 4]) ➞ False\n    '''\n","canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n","entry_point":"is_sorted"}
{"task_id":"HumanEval\/127","prompt":"def intersection(interval1, interval2):\n    \"\"\"ਤੁਹਾਨੂੰ ਦੋ ਅੰਤਰਾਲ ਦਿੱਤੇ ਗਏ ਹਨ,\n    ਜਿੱਥੇ ਹਰੇਕ ਅੰਤਰਾਲ ਅੰਕਾਂ ਦੀ ਜੋੜੀ ਹੈ। ਉਦਾਹਰਣ ਵਜੋਂ, ਅੰਤਰਾਲ = (ਸ਼ੁਰੂਆਤ, ਅੰਤ) = (1, 2)।\n    ਦਿੱਤੇ ਗਏ ਅੰਤਰਾਲ ਬੰਦ ਹਨ ਜਿਸ ਦਾ ਮਤਲਬ ਹੈ ਕਿ ਅੰਤਰਾਲ (ਸ਼ੁਰੂਆਤ, ਅੰਤ)\n    ਵਿੱਚ ਸ਼ੁਰੂਆਤ ਅਤੇ ਅੰਤ ਦੋਵੇਂ ਸ਼ਾਮਲ ਹਨ।\n    ਹਰੇਕ ਦਿੱਤੇ ਗਏ ਅੰਤਰਾਲ ਲਈ, ਇਹ ਮੰਨਿਆ ਜਾਂਦਾ ਹੈ ਕਿ ਇਸਦੀ ਸ਼ੁਰੂਆਤ ਇਸਦੇ ਅੰਤ ਤੋਂ ਘੱਟ ਜਾਂ ਬਰਾਬਰ ਹੈ।\n    ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਨਿਰਧਾਰਤ ਕਰਨਾ ਹੈ ਕਿ ਇਨ੍ਹਾਂ ਦੋ ਅੰਤਰਾਲਾਂ ਦੇ ਕਾਟੇ ਜਾਣ ਦੀ ਲੰਬਾਈ ਇੱਕ ਪ੍ਰਾਈਮ ਨੰਬਰ ਹੈ ਜਾਂ ਨਹੀਂ।\n    ਉਦਾਹਰਣ ਵਜੋਂ, ਅੰਤਰਾਲਾਂ (1, 3), (2, 4) ਦਾ ਕਾਟਾ (2, 3) ਹੈ\n    ਜਿਸ ਦੀ ਲੰਬਾਈ 1 ਹੈ, ਜੋ ਕਿ ਪ੍ਰਾਈਮ ਨੰਬਰ ਨਹੀਂ ਹੈ।\n    ਜੇ ਕਾਟੇ ਜਾਣ ਦੀ ਲੰਬਾਈ ਇੱਕ ਪ੍ਰਾਈਮ ਨੰਬਰ ਹੈ, ਤਾਂ \"YES\" ਵਾਪਸ ਕਰੋ,\n    ਨਹੀਂ ਤਾਂ \"NO\" ਵਾਪਸ ਕਰੋ।\n    ਜੇ ਦੋ ਅੰਤਰਾਲ ਕਾਟੇ ਨਹੀਂ ਜਾਂਦੇ, ਤਾਂ \"NO\" ਵਾਪਸ ਕਰੋ।\n\n\n    [ਇਨਪੁੱਟ\/ਆਉਟਪੁੱਟ] ਨਮੂਨੇ:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"","canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n","entry_point":"intersection"}
{"task_id":"HumanEval\/128","prompt":"def prod_signs(arr):\n    \"\"\"\n    ਤੁਹਾਨੂੰ ਇੱਕ ਪੂਰਨਾਂਕ ਐਰੇ arr ਦਿੱਤਾ ਗਿਆ ਹੈ ਅਤੇ ਤੁਹਾਨੂੰ ਹਰੇਕ ਨੰਬਰ ਦੇ ਚਿੰਨ੍ਹ ਦੇ ਉਤਪਾਦ ਨਾਲ ਗੁਣਾ ਕੀਤੇ ਗਏ ਪੂਰਨਾਂਕਾਂ ਦੀਆਂ ਮਾਤਰਾਵਾਂ ਦਾ ਜੋੜ ਮੁੜਨਾ ਹੈ, ਜੋ ਕਿ 1, -1 ਜਾਂ 0 ਨਾਲ ਦਰਸਾਇਆ ਗਿਆ ਹੈ।\n    ਨੋਟ: arr ਖਾਲੀ ਹੋਣ 'ਤੇ None ਮੁੜਾਓ।\n\n    ਉਦਾਹਰਣ:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n","canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"prod_signs"}
{"task_id":"HumanEval\/129","prompt":"def minPath(grid, k):\n    \"\"\"\n    ਇੱਕ ਗ੍ਰਿਡ ਦਿੱਤੀ ਗਈ ਹੈ ਜਿਸ ਵਿੱਚ N ਕਤਾਰਾਂ ਅਤੇ N ਕਾਲਮ ਹਨ (N >= 2) ਅਤੇ ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ k, \n    ਗ੍ਰਿਡ ਦੇ ਹਰੇਕ ਖਾਨੇ ਵਿੱਚ ਇੱਕ ਮੁੱਲ ਹੁੰਦੀ ਹੈ। ਹਰੇਕ ਪੂਰਨ ਅੰਕ ਜੋ ਕਿ [1, N * N] ਦੀ ਸੀਮਾ ਵਿੱਚ ਹੈ,\n    ਗ੍ਰਿਡ ਦੇ ਖਾਨਿਆਂ ਵਿੱਚ ਠੀਕ ਇੱਕ ਵਾਰ ਆਉਂਦਾ ਹੈ।\n\n    ਤੁਹਾਨੂੰ ਗ੍ਰਿਡ ਵਿੱਚ k ਲੰਬਾਈ ਦੇ ਘੱਟੋ-ਘੱਟ ਰਸਤੇ ਨੂੰ ਲੱਭਣਾ ਹੈ। ਤੁਸੀਂ ਕਿਸੇ ਵੀ ਖਾਨੇ ਤੋਂ ਸ਼ੁਰੂਆਤ ਕਰ ਸਕਦੇ ਹੋ,\n    ਅਤੇ ਹਰੇਕ ਕਦਮ ਵਿੱਚ ਤੁਸੀਂ ਪੜੋਸੀ ਖਾਨਿਆਂ ਵਿੱਚ ਜਾ ਸਕਦੇ ਹੋ,\n    ਦੂਜੇ ਸ਼ਬਦਾਂ ਵਿੱਚ, ਤੁਸੀਂ ਉਹਨਾਂ ਖਾਨਿਆਂ ਵਿੱਚ ਜਾ ਸਕਦੇ ਹੋ ਜੋ ਤੁਹਾਡੇ ਮੌਜੂਦਾ ਖਾਨੇ ਨਾਲ ਕਿਨਾਰਾ ਸਾਂਝਾ ਕਰਦੇ ਹਨ।\n    ਕਿਰਪਾ ਕਰਕੇ ਧਿਆਨ ਦਿਓ ਕਿ k ਲੰਬਾਈ ਦਾ ਰਸਤਾ ਮਤਲਬ ਹੈ ਠੀਕ k ਖਾਨਿਆਂ ਦੀ ਯਾਤਰਾ (ਜ਼ਰੂਰੀ ਨਹੀਂ ਕਿ ਵੱਖਰੇ ਹੋਣ)।\n    ਤੁਸੀਂ ਗ੍ਰਿਡ ਤੋਂ ਬਾਹਰ ਨਹੀਂ ਜਾ ਸਕਦੇ।\n    ਇੱਕ ਰਸਤਾ A (k ਦੀ ਲੰਬਾਈ ਦਾ) ਇੱਕ ਰਸਤੇ B (k ਦੀ ਲੰਬਾਈ ਦਾ) ਤੋਂ ਘੱਟ ਮੰਨਿਆ ਜਾਂਦਾ ਹੈ ਜੇਕਰ\n    ਉਨ੍ਹਾਂ ਖਾਨਿਆਂ ਦੇ ਮੁੱਲਾਂ ਦੀਆਂ ਕ੍ਰਮਬੱਧ ਸੂਚੀਆਂ ਬਣਾਉਣ ਤੋਂ ਬਾਅਦ ਜਿਨ੍ਹਾਂ ਰਾਹੀਂ A ਅਤੇ B ਲੰਘਦੇ ਹਨ (ਆਓ ਉਨ੍ਹਾਂ ਨੂੰ lst_A ਅਤੇ lst_B ਕਹੀਏ), lst_A ਸ਼ਬਦਕੋਸ਼ੀ ਤੌਰ ਤੇ lst_B ਤੋਂ ਘੱਟ ਹੈ, ਦੂਜੇ ਸ਼ਬਦਾਂ ਵਿੱਚ, ਇੱਕ ਪੂਰਨ ਅੰਕ ਸੂਚਕ ਮੌਜੂਦ ਹੈ i (1 <= i <= k)\n    ਇਸ ਤਰ੍ਹਾਂ ਕਿ lst_A[i] < lst_B[i] ਅਤੇ ਕਿਸੇ ਵੀ j ਲਈ (1 <= j < i) ਸਾਨੂੰ\n    lst_A[j] = lst_B[j] ਮਿਲਦਾ ਹੈ।\n    ਇਹ ਗਰੰਟੀ ਹੈ ਕਿ ਜਵਾਬ ਅਨੋਖਾ ਹੈ।\n    ਉਹ ਕ੍ਰਮਬੱਧ ਸੂਚੀ ਵਾਪਸ ਕਰੋ ਜਿਸ ਵਿੱਚ ਖਾਨਿਆਂ ਦੇ ਮੁੱਲ ਹਨ ਜਿਨ੍ਹਾਂ ਰਾਹੀਂ ਘੱਟੋ-ਘੱਟ ਰਸਤਾ ਲੰਘਦਾ ਹੈ।\n\n    ਉਦਾਹਰਣਾਂ:\n\n        ਇੰਪੁੱਟ: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        ਆਉਟਪੁੱਟ: [1, 2, 1]\n\n        ਇੰਪੁੱਟ: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        ਆਉਟਪੁੱਟ: [1]\n    \"\"\"\n","canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n","test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n","entry_point":"minPath"}
{"task_id":"HumanEval\/130","prompt":"def tri(n):\n    \"\"\"ਹਰ ਕੋਈ ਫਿਬੋਨਾਚੀ ਲੜੀ ਬਾਰੇ ਜਾਣਦਾ ਹੈ, ਇਸ ਨੂੰ ਪਿਛਲੀਆਂ ਕੁਝ ਸਦੀਆਂ ਵਿੱਚ ਗਣਿਤਜ਼ਾਂ ਦੁਆਰਾ ਗਹਿਰਾਈ ਨਾਲ ਅਧਿਐਨ ਕੀਤਾ ਗਿਆ ਹੈ। ਪਰ, ਜੋ ਲੋਕ ਨਹੀਂ ਜਾਣਦੇ ਉਹ ਹੈ ਟ੍ਰਾਈਬੋਨਾਚੀ ਲੜੀ।\n    ਟ੍ਰਾਈਬੋਨਾਚੀ ਲੜੀ ਨੂੰ ਮੁੜ-ਆਵਰਤੀ ਨਿਯਮ ਦੁਆਰਾ ਪਰਿਭਾਸ਼ਿਤ ਕੀਤਾ ਗਿਆ ਹੈ:\n    tri(1) = 3\n    tri(n) = 1 + n \/ 2, ਜੇ n ਸਮਾਂ ਹੈ।\n    tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1), ਜੇ n ਵਿਸਮ ਹੈ।\n    ਉਦਾਹਰਣ ਵਜੋਂ:\n    tri(2) = 1 + (2 \/ 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    ਤੁਹਾਨੂੰ ਇੱਕ ਨਕਾਰਾਤਮਕ ਨਹੀਂ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਤੁਹਾਨੂੰ ਟ੍ਰਾਈਬੋਨਾਚੀ ਲੜੀ ਦੇ ਪਹਿਲੇ n + 1 ਅੰਕਾਂ ਦੀ ਸੂਚੀ ਵਾਪਸ ਕਰਨੀ ਹੈ।\n    ਉਦਾਹਰਣ:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"","canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n","test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n","entry_point":"tri"}
{"task_id":"HumanEval\/131","prompt":"def digits(n):\n    \"\"\"ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ, ਵਿਸ਼ਮ ਅੰਕਾਂ ਦਾ ਗੁਣਾਂਕ ਮੁੜ ਕਰੋ।\n    ਜੇ ਸਾਰੇ ਅੰਕ ਸਮ ਹਨ ਤਾਂ 0 ਮੁੜ ਕਰੋ।\n    ਉਦਾਹਰਣ ਲਈ:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"","canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n","entry_point":"digits"}
{"task_id":"HumanEval\/132","prompt":"def is_nested(string):\n    '''\n    ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਇੱਕ ਸਟਰਿੰਗ ਨੂੰ ਇੰਪੁੱਟ ਵਜੋਂ ਲੈਂਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਸਿਰਫ ਚੌਕੋਰ ਬਰੈਕਟ ਹੁੰਦੇ ਹਨ।\n    ਫੰਕਸ਼ਨ ਤਦੋਂ ਹੀ ਸੱਚ ਵਾਪਸ ਕਰੇਗਾ ਜੇ ਬਰੈਕਟਾਂ ਦੀ ਇੱਕ ਵੈਧ ਉਪ-ਲੜੀ ਹੋਵੇ ਜਿਸ ਵਿੱਚ ਘੱਟੋ-ਘੱਟ ਇੱਕ ਬਰੈਕਟ ਉਪ-ਲੜੀ ਵਿੱਚ ਨੈਸਟਿਡ ਹੋਵੇ।\n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n","canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n","entry_point":"is_nested"}
{"task_id":"HumanEval\/133","prompt":"def sum_squares(lst):\n    \"\"\"ਤੁਹਾਨੂੰ ਇੱਕ ਸੂਚੀ ਦਿੱਤੀ ਗਈ ਹੈ।\n    ਤੁਹਾਨੂੰ ਦਿੱਤੀ ਗਈ ਸੂਚੀ ਵਿੱਚ ਵਰਗਾਂ ਦੀ ਰਾਸ਼ੀ ਦਾ ਜੋੜ ਮੁੜਨਾ ਪਵੇਗਾ,\n    ਸੂਚੀ ਵਿੱਚ ਹਰ ਇੱਕ ਅੰਸ਼ ਨੂੰ ਪਹਿਲਾਂ ਉੱਪਰ ਪੂਰਾ ਅੰਕ (ਸਿਲਿੰਗ) ਵਿੱਚ ਗੋਲ ਕਰੋ।\n    ਉਦਾਹਰਣਾਂ:\n    ਜੇ lst = [1,2,3] ਹੈ ਤਾਂ ਆਉਟਪੁਟ 14 ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ\n    ਜੇ lst = [1,4,9] ਹੈ ਤਾਂ ਆਉਟਪੁਟ 98 ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ\n    ਜੇ lst = [1,3,5,7] ਹੈ ਤਾਂ ਆਉਟਪੁਟ 84 ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ\n    ਜੇ lst = [1.4,4.2,0] ਹੈ ਤਾਂ ਆਉਟਪੁਟ 29 ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ\n    ਜੇ lst = [-2.4,1,1] ਹੈ ਤਾਂ ਆਉਟਪੁਟ 6 ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ\n    \n    \"\"\"\n","canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"sum_squares"}
{"task_id":"HumanEval\/134","prompt":"def check_if_last_char_is_a_letter(txt):\n    '''\n    ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਸੱਚ ਮੁੜਾਉਂਦਾ ਹੈ ਜੇਕਰ ਦਿੱਤੀ ਗਈ ਸਟਰਿੰਗ ਦਾ ਆਖਰੀ ਅੱਖਰ ਵਰਣਮਾਲਾ ਦਾ ਅੱਖਰ ਹੈ ਅਤੇ ਕਿਸੇ ਸ਼ਬਦ ਦਾ ਹਿੱਸਾ ਨਹੀਂ ਹੈ, ਅਤੇ ਨਹੀਂ ਤਾਂ ਝੂਠਾ।\n    ਨੋਟ: \"ਸ਼ਬਦ\" ਇੱਕ ਸਮੂਹ ਹੈ ਜੋ ਖਾਲੀ ਥਾਂ ਨਾਲ ਵੱਖ ਹੁੰਦਾ ਹੈ।\n\n    ਉਦਾਹਰਣ:\n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n","canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"check_if_last_char_is_a_letter"}
{"task_id":"HumanEval\/135","prompt":"def can_arrange(arr):\n    \"\"\"ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਉਸ ਤੱਤ ਦਾ ਸਭ ਤੋਂ ਵੱਡਾ ਇੰਡੈਕਸ ਮੁੜ ਕੇ ਦਿੰਦਾ ਹੈ ਜੋ ਇਸ ਤੋਂ ਪਹਿਲਾਂ ਆਉਣ ਵਾਲੇ ਤੱਤ ਤੋਂ ਵੱਡਾ ਜਾਂ ਬਰਾਬਰ ਨਹੀਂ ਹੈ। ਜੇਕਰ ਅਜਿਹਾ ਕੋਈ ਤੱਤ ਮੌਜੂਦ ਨਹੀਂ ਹੈ ਤਾਂ -1 ਮੁੜ ਕੇ ਦਿਓ। ਦਿੱਤੀ ਗਈ ਐਰੇ ਵਿੱਚ ਦੁਹਰਾਏ ਗਏ ਮੁੱਲ ਸ਼ਾਮਲ ਨਹੀਂ ਹੋਣਗੇ।\n\n    ਉਦਾਹਰਣਾਂ:\n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"","canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n","entry_point":"can_arrange"}
{"task_id":"HumanEval\/136","prompt":"def largest_smallest_integers(lst):\n    '''\n    ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਇੱਕ ਟਪਲ (a, b) ਵਾਪਸ ਕਰਦਾ ਹੈ, ਜਿੱਥੇ 'a' \n    ਨੈਗੇਟਿਵ ਪੂਰਨ ਅੰਕਾਂ ਵਿੱਚੋਂ ਸਭ ਤੋਂ ਵੱਡਾ ਹੈ, ਅਤੇ 'b' ਪਾਜ਼ੀਟਿਵ ਪੂਰਨ ਅੰਕਾਂ ਵਿੱਚੋਂ ਸਭ ਤੋਂ ਛੋਟਾ ਹੈ।\n    ਜੇਕਰ ਕੋਈ ਨੈਗੇਟਿਵ ਜਾਂ ਪਾਜ਼ੀਟਿਵ ਪੂਰਨ ਅੰਕ ਨਹੀਂ ਹਨ, ਤਾਂ ਉਹਨਾਂ ਨੂੰ None ਵਜੋਂ ਵਾਪਸ ਕਰੋ।\n\n    ਉਦਾਹਰਣ:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n","canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n","entry_point":"largest_smallest_integers"}
{"task_id":"HumanEval\/137","prompt":"def compare_one(a, b):\n    \"\"\"\n    ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਪੂਰਨਾਂਕ, ਫਲੋਟ, ਜਾਂ ਅਸਲੀ ਸੰਖਿਆਵਾਂ ਨੂੰ ਦਰਸਾਉਂਦੇ ਸਟਰਿੰਗਾਂ ਨੂੰ ਲੈਂਦਾ ਹੈ, ਅਤੇ ਦਿੱਤੇ ਗਏ ਵੇਰੀਏਬਲ ਦੀ ਕਿਸਮ ਵਿੱਚ ਵੱਡਾ ਵੇਰੀਏਬਲ ਵਾਪਸ ਕਰਦਾ ਹੈ।\n    ਜੇ ਮੁੱਲ ਬਰਾਬਰ ਹਨ ਤਾਂ None ਵਾਪਸ ਕਰੋ।\n    ਨੋਟ: ਜੇ ਕੋਈ ਅਸਲੀ ਸੰਖਿਆ ਸਟਰਿੰਗ ਦੇ ਰੂਪ ਵਿੱਚ ਦਰਸਾਈ ਗਈ ਹੈ, ਤਾਂ ਫਲੋਟਿੰਗ ਪੁਆਇੰਟ . ਜਾਂ , ਹੋ ਸਕਦਾ ਹੈ।\n\n    compare_one(1, 2.5) ➞ 2.5\n    compare_one(1, \"2,3\") ➞ \"2,3\"\n    compare_one(\"5,1\", \"6\") ➞ \"6\"\n    compare_one(\"1\", 1) ➞ None\n    \"\"\"\n","canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"compare_one"}
{"task_id":"HumanEval\/138","prompt":"def is_equal_to_sum_even(n):\n    \"\"\"ਪਤਾ ਲਗਾਓ ਕਿ ਦਿੱਤਾ ਗਿਆ ਨੰਬਰ n ਬਿਲਕੁਲ 4 ਸਕਾਰਾਤਮਕ ਜੋੜੀ ਨੰਬਰਾਂ ਦੇ ਜੋੜ ਵਜੋਂ ਲਿਖਿਆ ਜਾ ਸਕਦਾ ਹੈ ਜਾਂ ਨਹੀਂ\n    ਉਦਾਹਰਣ\n    is_equal_to_sum_even(4) == False\n    is_equal_to_sum_even(6) == False\n    is_equal_to_sum_even(8) == True\n    \"\"\"","canonical_solution":"    return n%2 == 0 and n >= 8\n","test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n","entry_point":"is_equal_to_sum_even"}
{"task_id":"HumanEval\/139","prompt":"def special_factorial(n):\n    \"\"\"ਬ੍ਰਾਜ਼ੀਲੀਅਨ ਫੈਕਟੋਰੀਅਲ ਇਸ ਤਰ੍ਹਾਂ ਪਰਿਭਾਸ਼ਿਤ ਕੀਤਾ ਗਿਆ ਹੈ:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    ਜਿੱਥੇ n > 0\n\n    ਉਦਾਹਰਣ ਲਈ:\n    >>> special_factorial(4)\n    288\n\n    ਇਹ ਫੰਕਸ਼ਨ ਇੱਕ ਪੂਰਨ ਅੰਕ ਨੂੰ ਇੰਪੁੱਟ ਵਜੋਂ ਪ੍ਰਾਪਤ ਕਰੇਗਾ ਅਤੇ ਇਸ ਪੂਰਨ ਅੰਕ ਦੇ ਖਾਸ ਫੈਕਟੋਰੀਅਲ ਨੂੰ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ।\n    \"\"\"","canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n","entry_point":"special_factorial"}
{"task_id":"HumanEval\/140","prompt":"def fix_spaces(text):\n    \"\"\"\n    ਇੱਕ string text ਦਿੱਤੀ ਗਈ ਹੈ, ਇਸ ਵਿੱਚ ਸਾਰੀਆਂ ਖਾਲੀ ਥਾਂਵਾਂ ਨੂੰ ਅੰਡਰਸਕੋਰਜ਼ ਨਾਲ ਬਦਲੋ,\n    ਅਤੇ ਜੇਕਰ ਕਿਸੇ string ਵਿੱਚ 2 ਤੋਂ ਵੱਧ ਲਗਾਤਾਰ ਖਾਲੀ ਥਾਂਵਾਂ ਹਨ,\n    ਤਾਂ ਸਾਰੀਆਂ ਲਗਾਤਾਰ ਖਾਲੀ ਥਾਂਵਾਂ ਨੂੰ - ਨਾਲ ਬਦਲੋ\n\n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"\n","canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n","entry_point":"fix_spaces"}
{"task_id":"HumanEval\/141","prompt":"def file_name_check(file_name):\n    \"\"\"ਇੱਕ ਫੰਕਸ਼ਨ ਬਣਾਓ ਜੋ ਫਾਇਲ ਦੇ ਨਾਮ ਨੂੰ ਦਰਸਾਉਂਦੀ ਸਟਰਿੰਗ ਲੈਂਦਾ ਹੈ, ਅਤੇ ਜੇਕਰ ਫਾਇਲ ਦਾ ਨਾਮ ਵੈਧ ਹੈ ਤਾਂ 'Yes' ਨੂੰ ਵਾਪਸ ਕਰਦਾ ਹੈ, ਅਤੇ ਨਹੀਂ ਤਾਂ 'No' ਨੂੰ ਵਾਪਸ ਕਰਦਾ ਹੈ।\n    ਇੱਕ ਫਾਇਲ ਦਾ ਨਾਮ ਤਦੋਂ ਹੀ ਵੈਧ ਮੰਨਿਆ ਜਾਂਦਾ ਹੈ ਜੇਕਰ ਹੇਠ ਲਿਖੇ ਸਾਰੇ ਹਾਲਾਤ ਪੂਰੇ ਹੋਣ:\n    - ਫਾਇਲ ਦੇ ਨਾਮ ਵਿੱਚ ਤਿੰਨ ਤੋਂ ਵੱਧ ਅੰਕ ('0'-'9') ਨਹੀਂ ਹੋਣੇ ਚਾਹੀਦੇ।\n    - ਫਾਇਲ ਦੇ ਨਾਮ ਵਿੱਚ ਠੀਕ ਇੱਕ ਬਿੰਦੀ '.' ਹੋਣੀ ਚਾਹੀਦੀ ਹੈ।\n    - ਬਿੰਦੀ ਤੋਂ ਪਹਿਲਾਂ ਦਾ ਸਬਸਟਰਿੰਗ ਖਾਲੀ ਨਹੀਂ ਹੋਣਾ ਚਾਹੀਦਾ, ਅਤੇ ਇਹ ਲਾਤੀਨੀ ਵਰਣਮਾਲਾ ('a'-'z' ਅਤੇ 'A'-'Z') ਤੋਂ ਇੱਕ ਅੱਖਰ ਨਾਲ ਸ਼ੁਰੂ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ।\n    - ਬਿੰਦੀ ਤੋਂ ਬਾਅਦ ਦਾ ਸਬਸਟਰਿੰਗ ਇਨ੍ਹਾਂ ਵਿੱਚੋਂ ਇੱਕ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ: ['txt', 'exe', 'dll']\n    ਉਦਾਹਰਣ:\n    file_name_check(\"example.txt\") # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (ਨਾਮ ਲਾਤੀਨੀ ਵਰਣਮਾਲਾ ਦੇ ਅੱਖਰ ਨਾਲ ਸ਼ੁਰੂ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ)\n    \"\"\"","canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n","entry_point":"file_name_check"}
{"task_id":"HumanEval\/142","prompt":"def sum_squares(lst):\n    \"\"\"\"\n    ਇਹ ਫੰਕਸ਼ਨ ਇੱਕ ਸੂਚੀ ਲਵੇਗਾ ਜਿਸ ਵਿੱਚ ਪੂਰਨਾਂਕ ਹੋਣਗੇ। ਸੂਚੀ ਵਿੱਚ ਹਰ ਇੱਕ ਐਂਟਰੀ ਲਈ, ਜੇਕਰ ਉਸਦਾ ਇੰਡੈਕਸ 3 ਦਾ ਗੁਣਾਂਕ ਹੈ ਤਾਂ ਫੰਕਸ਼ਨ ਉਸ ਪੂਰਨਾਂਕ ਨੂੰ ਵਰਗ ਕਰੇਗਾ ਅਤੇ ਜੇਕਰ ਇੰਡੈਕਸ 4 ਦਾ ਗੁਣਾਂਕ ਹੈ ਪਰ 3 ਦਾ ਗੁਣਾਂਕ ਨਹੀਂ ਹੈ ਤਾਂ ਉਸ ਪੂਰਨਾਂਕ ਨੂੰ ਘਣਾ ਕਰੇਗਾ। ਫੰਕਸ਼ਨ ਉਹ ਐਂਟਰੀਆਂ ਨੂੰ ਨਹੀਂ ਬਦਲੇਗਾ ਜਿਨ੍ਹਾਂ ਦੇ ਇੰਡੈਕਸ 3 ਜਾਂ 4 ਦੇ ਗੁਣਾਂਕ ਨਹੀਂ ਹਨ। ਫਿਰ ਫੰਕਸ਼ਨ ਸਾਰੀਆਂ ਐਂਟਰੀਆਂ ਦਾ ਜੋੜ ਵਾਪਸ ਕਰੇਗਾ।\n    \n    ਉਦਾਹਰਣਾਂ:\n    ਜੇਕਰ lst = [1,2,3] ਹੈ ਤਾਂ ਆਉਟਪੁਟ 6 ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ\n    ਜੇਕਰ lst = [] ਹੈ ਤਾਂ ਆਉਟਪੁਟ 0 ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ\n    ਜੇਕਰ lst = [-1,-5,2,-1,-5] ਹੈ ਤਾਂ ਆਉਟਪੁਟ -126 ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ\n    \"\"\"","canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n","entry_point":"sum_squares"}
{"task_id":"HumanEval\/143","prompt":"def words_in_sentence(sentence):\n    \"\"\"\n    ਤੁਹਾਨੂੰ ਇੱਕ ਸਟਰਿੰਗ ਦਿੱਤੀ ਗਈ ਹੈ ਜੋ ਕਿ ਇੱਕ ਵਾਕ ਨੂੰ ਦਰਸਾਉਂਦੀ ਹੈ,\n    ਇਸ ਵਾਕ ਵਿੱਚ ਕੁਝ ਸ਼ਬਦ ਹਨ ਜੋ ਕਿ ਇੱਕ ਖਾਲੀ ਥਾਂ ਦੁਆਰਾ ਵੱਖ ਕੀਤੇ ਗਏ ਹਨ,\n    ਅਤੇ ਤੁਹਾਨੂੰ ਇੱਕ ਸਟਰਿੰਗ ਵਾਪਸ ਕਰਨੀ ਹੈ ਜਿਸ ਵਿੱਚ ਉਹ ਸ਼ਬਦ ਹੋਣ ਜੋ ਮੂਲ ਵਾਕ ਵਿੱਚੋਂ ਹਨ,\n    ਜਿਨ੍ਹਾਂ ਦੀਆਂ ਲੰਬਾਈਆਂ ਪ੍ਰਾਈਮ ਨੰਬਰ ਹਨ,\n    ਨਵੀਂ ਸਟਰਿੰਗ ਵਿੱਚ ਸ਼ਬਦਾਂ ਦਾ ਕ੍ਰਮ ਉਹੀ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ ਜੋ ਮੂਲ ਵਿੱਚ ਸੀ।\n\n    ਉਦਾਹਰਣ 1:\n        ਇੰਪੁੱਟ: sentence = \"This is a test\"\n        ਆਉਟਪੁੱਟ: \"is\"\n\n    ਉਦਾਹਰਣ 2:\n        ਇੰਪੁੱਟ: sentence = \"lets go for swimming\"\n        ਆਉਟਪੁੱਟ: \"go for\"\n\n    ਬੰਦਿਸ਼ਾਂ:\n        * 1 <= len(sentence) <= 100\n        * sentence ਵਿੱਚ ਸਿਰਫ ਅੱਖਰ ਹੀ ਹੋਣ\n    \"\"\"","canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n","entry_point":"words_in_sentence"}
{"task_id":"HumanEval\/144","prompt":"def simplify(x, n):\n    \"\"\"ਤੁਹਾਡਾ ਕੰਮ ਇੱਕ ਫੰਕਸ਼ਨ ਨੂੰ ਲਾਗੂ ਕਰਨਾ ਹੈ ਜੋ ਕਿ ਸਮੀਕਰਨ\n    x * n ਨੂੰ ਸਰਲ ਕਰੇਗਾ। ਜੇ x * n ਪੂਰੀ ਸੰਖਿਆ ਵਿੱਚ ਮੁੱਲਾਂਕਣ ਕਰਦਾ ਹੈ ਤਾਂ ਫੰਕਸ਼ਨ True ਵਾਪਸ ਕਰਦਾ ਹੈ ਅਤੇ ਨਹੀਂ ਤਾਂ False।\n    x ਅਤੇ n, ਦੋਵੇਂ ਅੰਸ਼ ਦੇ ਸਟਰਿੰਗ ਪ੍ਰਤੀਨਿਧਤਵ ਹਨ, ਅਤੇ ਇਸ ਫਾਰਮੈਟ ਦੇ ਹਨ,\n    <ਅੰਸ਼ਕ>\/<ਹਰ> ਜਿੱਥੇ ਅੰਸ਼ਕ ਅਤੇ ਹਰ ਦੋਵੇਂ ਸਕਾਰਾਤਮਕ ਪੂਰੀ ਸੰਖਿਆਵਾਂ ਹਨ।\n\n    ਤੁਸੀਂ ਮੰਨ ਸਕਦੇ ਹੋ ਕਿ x, ਅਤੇ n ਵੈਧ ਅੰਸ਼ ਹਨ, ਅਤੇ ਇਨ੍ਹਾਂ ਦੇ ਹਰ ਵਿੱਚ ਜ਼ੀਰੋ ਨਹੀਂ ਹੈ।\n\n    simplify(\"1\/5\", \"5\/1\") = True\n    simplify(\"1\/6\", \"2\/1\") = False\n    simplify(\"7\/10\", \"10\/2\") = False\n    \"\"\"\n","canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n","entry_point":"simplify"}
{"task_id":"HumanEval\/145","prompt":"def order_by_points(nums):\n    \"\"\"\n    ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਦਿੱਤੀ ਗਈ ਪੂਰੀ ਸੰਖਿਆਵਾਂ ਦੀ ਸੂਚੀ ਨੂੰ ਉਨ੍ਹਾਂ ਦੇ ਅੰਕਾਂ ਦੇ ਜੋੜ ਅਨੁਸਾਰ ਚੜ੍ਹਦੇ ਕ੍ਰਮ ਵਿੱਚ ਛਾਂਟਦਾ ਹੈ।\n    ਨੋਟ: ਜੇ ਕਈ ਆਈਟਮਾਂ ਦਾ ਅੰਕਾਂ ਦਾ ਜੋੜ ਇਕੋ ਜਿਹਾ ਹੈ, ਤਾਂ ਉਹਨਾਂ ਨੂੰ ਮੂਲ ਸੂਚੀ ਵਿੱਚ ਉਨ੍ਹਾਂ ਦੇ ਸੂਚਕ ਅਨੁਸਾਰ ਵਿਵਸਥਿਤ ਕਰੋ।\n\n    ਉਦਾਹਰਣ ਲਈ:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n","canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"order_by_points"}
{"task_id":"HumanEval\/146","prompt":"def specialFilter(nums):\n    \"\"\"ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਨੰਬਰਾਂ ਦੀ ਐਰੇ ਨੂੰ ਇੰਪੁੱਟ ਵਜੋਂ ਲੈਂਦਾ ਹੈ ਅਤੇ ਉਹ ਐਰੇ ਵਿੱਚ ਉਹਨਾਂ ਅੰਸ਼ਾਂ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰਦਾ ਹੈ ਜੋ 10 ਤੋਂ ਵੱਡੇ ਹਨ ਅਤੇ ਜਿਨ੍ਹਾਂ ਦੇ ਨੰਬਰ ਦਾ ਪਹਿਲਾ ਅਤੇ ਆਖਰੀ ਅੰਕ ਵਿਸ਼ਮ (1, 3, 5, 7, 9) ਹੈ।\n    ਉਦਾਹਰਣ ਵਜੋਂ:\n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"","canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n","entry_point":"specialFilter"}
{"task_id":"HumanEval\/147","prompt":"def get_max_triples(n):\n    \"\"\"\n    ਤੁਹਾਨੂੰ ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ n ਦਿੱਤਾ ਗਿਆ ਹੈ। ਤੁਹਾਨੂੰ n ਲੰਬਾਈ ਦਾ ਇੱਕ ਪੂਰਨ ਅੰਕ ਐਰੇ a ਬਣਾਉਣਾ ਹੈ।\n        ਹਰੇਕ i (1 ≤ i ≤ n) ਲਈ, a[i] ਦਾ ਮੁੱਲ = i * i - i + 1 ਹੁੰਦਾ ਹੈ।\n        ਉਹ ਤਿੰਨਾਂ ਦੀ ਗਿਣਤੀ ਵਾਪਸ ਕਰੋ (a[i], a[j], a[k]) ਜਿੱਥੇ i < j < k, \n    ਅਤੇ a[i] + a[j] + a[k] 3 ਦਾ ਗੁਣਾਂਕ ਹੈ।\n\n    ਉਦਾਹਰਣ :\n        ਇੰਪੁੱਟ: n = 5\n        ਆਉਟਪੁੱਟ: 1\n        ਵਿਆਖਿਆ: \n        a = [1, 3, 7, 13, 21]\n        ਇੱਕੋ ਇੱਕ ਵੈਧ ਤਿੰਨਾਂ ਹੈ (1, 7, 13)।\n    \"\"\"\n","canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n","test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n","entry_point":"get_max_triples"}
{"task_id":"HumanEval\/148","prompt":"def bf(planet1, planet2):\n    '''\n    ਸਾਡੇ ਸੌਰ ਮੰਡਲ ਵਿੱਚ ਅੱਠ ਗ੍ਰਹਿ ਹਨ: ਸੂਰਜ ਦੇ ਨੇੜਲੇ ਗ੍ਰਹਿ ਦਾ ਨਾਮ ਬੁੱਧ ਹੈ, ਅਗਲਾ ਸ਼ੁੱਕਰ ਹੈ, ਫਿਰ ਧਰਤੀ, ਮੰਗਲ, ਬ੍ਰਹਸਪਤਿ, ਸ਼ਨੀ, ਅਰੁਣ ਅਤੇ ਵਰੁਣ।\n    ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਦੋ ਗ੍ਰਹਿਆਂ ਦੇ ਨਾਮ ਸਟਰਿੰਗ planet1 ਅਤੇ planet2 ਵਜੋਂ ਲੈਂਦਾ ਹੈ। \n    ਇਹ ਫੰਕਸ਼ਨ ਇੱਕ ਟਪਲ ਵਾਪਸ ਕਰੇਗਾ ਜਿਸ ਵਿੱਚ ਉਹ ਸਾਰੇ ਗ੍ਰਹਿ ਸ਼ਾਮਲ ਹੋਣਗੇ ਜਿਨ੍ਹਾਂ ਦੇ ਕੱਕਰ planet1 ਅਤੇ planet2 ਦੇ ਕੱਕਰ ਦੇ ਵਿਚਕਾਰ ਸਥਿਤ ਹਨ, ਸੂਰਜ ਦੇ ਨੇੜਤਾ ਅਨੁਸਾਰ ਕ੍ਰਮਬੱਧ। \n    ਜੇ planet1 ਜਾਂ planet2 ਸਹੀ ਗ੍ਰਹਿ ਦੇ ਨਾਮ ਨਹੀਂ ਹਨ ਤਾਂ ਫੰਕਸ਼ਨ ਇੱਕ ਖਾਲੀ ਟਪਲ ਵਾਪਸ ਕਰੇਗਾ। \n    ਉਦਾਹਰਣ\n    bf(\"ਬ੍ਰਹਸਪਤਿ\", \"ਵਰੁਣ\") ==> (\"ਸ਼ਨੀ\", \"ਅਰੁਣ\")\n    bf(\"ਧਰਤੀ\", \"ਬੁੱਧ\") ==> (\"ਸ਼ੁੱਕਰ\")\n    bf(\"ਬੁੱਧ\", \"ਅਰੁਣ\") ==> (\"ਸ਼ੁੱਕਰ\", \"ਧਰਤੀ\", \"ਮੰਗਲ\", \"ਬ੍ਰਹਸਪਤਿ\", \"ਸ਼ਨੀ\")\n    '''\n","canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n","entry_point":"bf"}
{"task_id":"HumanEval\/149","prompt":"def sorted_list_sum(lst):\n    \"\"\"ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਇੱਕ ਸਟਰਿੰਗਾਂ ਦੀ ਸੂਚੀ ਨੂੰ ਪੈਰਾਮੀਟਰ ਵਜੋਂ ਸਵੀਕਾਰ ਕਰਦਾ ਹੈ,\n    ਇਸ ਵਿੱਚੋਂ ਅਜੀਬ ਲੰਬਾਈ ਵਾਲੀਆਂ ਸਟਰਿੰਗਾਂ ਨੂੰ ਮਿਟਾਉਂਦਾ ਹੈ,\n    ਅਤੇ ਇੱਕ ਕ੍ਰਮਬੱਧ ਕ੍ਰਮ ਨਾਲ ਨਤੀਜਾ ਸੂਚੀ ਵਾਪਸ ਕਰਦਾ ਹੈ,\n    ਸੂਚੀ ਹਮੇਸ਼ਾ ਸਟਰਿੰਗਾਂ ਦੀ ਸੂਚੀ ਹੁੰਦੀ ਹੈ ਅਤੇ ਕਦੇ ਵੀ ਅੰਕੜਿਆਂ ਦੀ ਲੜੀ ਨਹੀਂ ਹੁੰਦੀ,\n    ਅਤੇ ਇਸ ਵਿੱਚ ਨਕਲਾਂ ਸ਼ਾਮਲ ਹੋ ਸਕਦੀਆਂ ਹਨ।\n    ਸੂਚੀ ਦਾ ਕ੍ਰਮ ਹਰ ਸ਼ਬਦ ਦੀ ਲੰਬਾਈ ਦੇ ਅਨੁਸਾਰ ਚੜ੍ਹਦਾ ਹੋਣਾ ਚਾਹੀਦਾ ਹੈ, ਅਤੇ ਤੁਸੀਂ\n    ਉਸ ਨਿਯਮ ਦੁਆਰਾ ਕ੍ਰਮਬੱਧ ਸੂਚੀ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ।\n    ਜੇ ਦੋ ਸ਼ਬਦਾਂ ਦੀ ਲੰਬਾਈ ਇੱਕੋ ਜਿਹੀ ਹੋਵੇ, ਤਾਂ ਸੂਚੀ ਨੂੰ ਵਰਣਮਾਲਾ ਕ੍ਰਮ ਅਨੁਸਾਰ ਕ੍ਰਮਬੱਧ ਕਰੋ।\n    ਫੰਕਸ਼ਨ ਨੂੰ ਕ੍ਰਮਬੱਧ ਕ੍ਰਮ ਵਿੱਚ ਸਟਰਿੰਗਾਂ ਦੀ ਇੱਕ ਸੂਚੀ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ।\n    ਤੁਸੀਂ ਮਾਨ ਸਕਦੇ ਹੋ ਕਿ ਸਾਰੇ ਸ਼ਬਦ ਇੱਕੋ ਜਿਹੀ ਲੰਬਾਈ ਦੇ ਹੋਣਗੇ।\n    ਉਦਾਹਰਣ ਲਈ:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n","canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n","entry_point":"sorted_list_sum"}
{"task_id":"HumanEval\/150","prompt":"def x_or_y(n, x, y):\n    \"\"\"ਇੱਕ ਸਧਾਰਣ ਪ੍ਰੋਗਰਾਮ ਜੋ ਕਿ n ਇੱਕ ਪ੍ਰਾਈਮ ਨੰਬਰ ਹੈ ਤਾਂ x ਦੀ ਵੈਲਯੂ ਨੂੰ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਅਤੇ ਬਾਕੀ ਸਥਿਤੀਆਂ ਵਿੱਚ y ਦੀ ਵੈਲਯੂ ਨੂੰ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ।\n\n    ਉਦਾਹਰਣਾਂ:\n    x_or_y(7, 34, 12) == 34 ਲਈ\n    x_or_y(15, 8, 5) == 5 ਲਈ\n    \n    \"\"\"","canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n","entry_point":"x_or_y"}
{"task_id":"HumanEval\/151","prompt":"def double_the_difference(lst):\n    '''\n    ਇੱਕ ਸੂਚੀ ਵਿੱਚ ਦਿੱਤੇ ਗਏ ਅੰਕਾਂ ਦੇ ਵਰਗਾਂ ਦਾ ਜੋੜ ਵਾਪਸ ਕਰੋ, ਜੋ ਸੂਚੀ ਵਿੱਚ ਵਿਸ਼ਮ ਹਨ। ਨਕਾਰਾਤਮਕ ਜਾਂ ਪੂਰਨਾਂਕ ਨਾ ਹੋਣ ਵਾਲੇ ਅੰਕਾਂ ਨੂੰ ਨਜ਼ਰਅੰਦਾਜ਼ ਕਰੋ।\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n    \n    ਜੇਕਰ ਇੰਪੁੱਟ ਸੂਚੀ ਖਾਲੀ ਹੈ, ਤਾਂ 0 ਵਾਪਸ ਕਰੋ।\n    '''","canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n","entry_point":"double_the_difference"}
{"task_id":"HumanEval\/152","prompt":"def compare(game,guess):\n    \"\"\"ਮੈਨੂੰ ਲਗਦਾ ਹੈ ਕਿ ਅਸੀਂ ਸਾਰੇ ਉਸ ਭਾਵਨਾ ਨੂੰ ਯਾਦ ਕਰਦੇ ਹਾਂ ਜਦੋਂ ਕਿਸੇ ਲੰਬੇ ਸਮੇਂ ਤੋਂ ਉਡੀਕੀ ਜਾ ਰਹੀ ਘਟਨਾ ਦਾ ਨਤੀਜਾ ਅਖੀਰਕਾਰ ਜਾਣਿਆ ਜਾਂਦਾ ਹੈ। ਉਸ ਪਲ ਵਿੱਚ ਤੁਹਾਡੀਆਂ ਭਾਵਨਾਵਾਂ ਅਤੇ ਵਿਚਾਰ ਜ਼ਰੂਰ ਨੋਟ ਕਰਨ ਲਾਇਕ ਅਤੇ ਤੁਲਨਾ ਕਰਨ ਲਾਇਕ ਹਨ।\n    ਤੁਹਾਡਾ ਕੰਮ ਇਹ ਨਿਰਧਾਰਿਤ ਕਰਨਾ ਹੈ ਕਿ ਕੀ ਕਿਸੇ ਵਿਅਕਤੀ ਨੇ ਕਈ ਮੈਚਾਂ ਦੇ ਨਤੀਜਿਆਂ ਦਾ ਸਹੀ ਅਨੁਮਾਨ ਲਗਾਇਆ ਹੈ।\n    ਤੁਹਾਨੂੰ ਸਕੋਰਾਂ ਅਤੇ ਅਨੁਮਾਨਾਂ ਦੇ ਦੋ ਸਮਾਨ ਲੰਬਾਈ ਵਾਲੇ arrays ਦਿੱਤੇ ਜਾਂਦੇ ਹਨ, ਜਿੱਥੇ ਹਰ ਇੰਡੈਕਸ ਇੱਕ ਮੈਚ ਦਿਖਾਉਂਦਾ ਹੈ। \n    ਹਰੇਕ ਅਨੁਮਾਨ ਦੀ ਕਿੰਨੀ ਦੂਰੀ ਹੈ ਇਸ ਨੂੰ ਦਰਸਾਉਂਦੀ ਉਸੇ ਲੰਬਾਈ ਵਾਲੀ ਇੱਕ array ਵਾਪਸ ਕਰੋ। ਜੇ ਉਹਨਾਂ ਨੇ ਸਹੀ ਅਨੁਮਾਨ ਲਗਾਇਆ ਹੈ,\n    ਤਾਂ ਮੁੱਲ 0 ਹੈ, ਅਤੇ ਜੇ ਨਹੀਂ, ਤਾਂ ਮੁੱਲ ਅਨੁਮਾਨ ਅਤੇ ਸਕੋਰ ਵਿਚਕਾਰ ਦੇ ਅਸਲ ਫਰਕ ਦੀ ਹੈ।\n    \n    \n    ਉਦਾਹਰਣ:\n\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n    \"\"\"\n","canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"compare"}
{"task_id":"HumanEval\/153","prompt":"def Strongest_Extension(class_name, extensions):\n    \"\"\"ਤੁਹਾਨੂੰ ਇੱਕ ਕਲਾਸ ਦਾ ਨਾਮ (ਇੱਕ ਸਟਰਿੰਗ) ਅਤੇ ਇੱਕ ਐਕਸਟੈਂਸ਼ਨਾਂ ਦੀ ਸੂਚੀ ਦਿੱਤੀ ਜਾਵੇਗੀ।\n    ਐਕਸਟੈਂਸ਼ਨਾਂ ਨੂੰ ਕਲਾਸ ਵਿੱਚ ਹੋਰ ਕਲਾਸਾਂ ਨੂੰ ਲੋਡ ਕਰਨ ਲਈ ਵਰਤਿਆ ਜਾਣਾ ਹੈ। ਐਕਸਟੈਂਸ਼ਨ ਦੀ ਤਾਕਤ ਇਸ ਪ੍ਰਕਾਰ ਹੈ: ਐਕਸਟੈਂਸ਼ਨ ਦੇ ਨਾਮ ਵਿੱਚ ਅੱਪਰਕੇਸ ਅੱਖਰਾਂ ਦੀ ਗਿਣਤੀ ਨੂੰ CAP ਕਹੀਏ ਅਤੇ ਲੋਅਰਕੇਸ ਅੱਖਰਾਂ ਦੀ ਗਿਣਤੀ ਨੂੰ SM ਕਹੀਏ, ਤਾਕਤ ਇਸ ਅਨੁਪਾਤ ਦੁਆਰਾ ਦਿੱਤੀ ਜਾਂਦੀ ਹੈ CAP - SM। \n    ਤੁਹਾਨੂੰ ਸਭ ਤੋਂ ਤਾਕਤਵਰ ਐਕਸਟੈਂਸ਼ਨ ਲੱਭਣੀ ਚਾਹੀਦੀ ਹੈ ਅਤੇ ਇਸ ਫਾਰਮੈਟ ਵਿੱਚ ਇੱਕ ਸਟਰਿੰਗ ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ: ClassName.StrongestExtensionName.\n    ਜੇ ਦੋ ਜਾਂ ਦੋ ਤੋਂ ਵੱਧ ਐਕਸਟੈਂਸ਼ਨਾਂ ਦੀ ਤਾਕਤ ਇੱਕੋ ਜਿਹੀ ਹੋਵੇ, ਤਾਂ ਤੁਹਾਨੂੰ ਉਸ ਨੂੰ ਚੁਣਨਾ ਚਾਹੀਦਾ ਹੈ ਜੋ ਸੂਚੀ ਵਿੱਚ ਪਹਿਲਾਂ ਆਉਂਦਾ ਹੈ।\n    ਉਦਾਹਰਣ ਵਜੋਂ, ਜੇ ਤੁਹਾਨੂੰ \"Slices\" ਕਲਾਸ ਦਿੱਤੀ ਗਈ ਹੈ ਅਤੇ ਐਕਸਟੈਂਸ਼ਨਾਂ ਦੀ ਸੂਚੀ: ['SErviNGSliCes', 'Cheese', 'StuFfed'] ਤਾਂ ਤੁਹਾਨੂੰ 'Slices.SErviNGSliCes' ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ ਕਿਉਂਕਿ 'SErviNGSliCes' ਸਭ ਤੋਂ ਤਾਕਤਵਰ ਐਕਸਟੈਂਸ਼ਨ ਹੈ \n    (ਇਸ ਦੀ ਤਾਕਤ -1 ਹੈ)।\n    ਉਦਾਹਰਣ:\n    Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA' ਲਈ\n    \"\"\"\n","canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n","entry_point":"Strongest_Extension"}
{"task_id":"HumanEval\/154","prompt":"def cycpattern_check(a , b):\n    \"\"\"ਤੁਹਾਨੂੰ 2 ਸ਼ਬਦ ਦਿੱਤੇ ਗਏ ਹਨ। ਤੁਹਾਨੂੰ True ਵਾਪਸ ਕਰਨਾ ਹੈ ਜੇ ਦੂਜਾ ਸ਼ਬਦ ਜਾਂ ਉਸਦੇ ਕਿਸੇ ਵੀ ਘੁੰਮਾਉ ਨੂੰ ਪਹਿਲੇ ਸ਼ਬਦ ਵਿੱਚ ਉਪ-ਸ਼ਬਦ ਵਜੋਂ ਮਿਲਦਾ ਹੈ\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"","canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n","test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n","entry_point":"cycpattern_check"}
{"task_id":"HumanEval\/155","prompt":"def even_odd_count(num):\n    \"\"\"ਇੱਕ ਪੂਰਨਾਂਕ ਦਿੱਤਾ ਗਿਆ ਹੈ। ਇੱਕ ਟਪਲ ਵਾਪਸ ਕਰੋ ਜਿਸ ਵਿੱਚ ਸਮਾਨ ਅਤੇ ਵਿਸਮ ਅੰਕਾਂ ਦੀ ਗਿਣਤੀ ਕ੍ਰਮਵਾਰ ਹੋਵੇ।\n\n     ਉਦਾਹਰਣ:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"","canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"even_odd_count"}
{"task_id":"HumanEval\/156","prompt":"def int_to_mini_roman(number):\n    \"\"\"\n    ਇੱਕ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦਿੱਤਾ ਗਿਆ ਹੈ, ਇਸਦਾ ਰੋਮਨ ਅੰਕਾਂ ਵਿੱਚ ਬਰਾਬਰ ਲੱਭੋ, ਅਤੇ ਇਸਨੂੰ ਛੋਟੇ ਅੱਖਰਾਂ ਵਿੱਚ ਸਟਰਿੰਗ ਦੇ ਰੂਪ ਵਿੱਚ ਵਾਪਸ ਕਰੋ।\n    ਪਾਬੰਦੀਆਂ: 1 <= ਨੰਬਰ <= 1000\n\n    ਉਦਾਹਰਣਾਂ:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"","canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"int_to_mini_roman"}
{"task_id":"HumanEval\/157","prompt":"def right_angle_triangle(a, b, c):\n    '''\n    ਤਿੰਨ ਪਾਸਿਆਂ ਦੀਆਂ ਲੰਬਾਈਆਂ ਦੇ ਨਾਲ ਇੱਕ ਤਿਕੋਣ ਦਿੱਤਾ ਗਿਆ ਹੈ। ਜੇ ਤਿੰਨ ਪਾਸੇ ਸੱਜੇ ਕੋਣ ਵਾਲਾ ਤਿਕੋਣ ਬਣਾਉਂਦੇ ਹਨ ਤਾਂ True ਵਾਪਸ ਕਰੋ, ਨਹੀਂ ਤਾਂ False।\n    ਸੱਜੇ ਕੋਣ ਵਾਲਾ ਤਿਕੋਣ ਉਹ ਹੁੰਦਾ ਹੈ ਜਿਸ ਵਿੱਚ ਇੱਕ ਕੋਣ ਸੱਜਾ ਕੋਣ ਜਾਂ 90 ਡਿਗਰੀ ਹੁੰਦਾ ਹੈ।\n    ਉਦਾਹਰਣ:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n","canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n","entry_point":"right_angle_triangle"}
{"task_id":"HumanEval\/158","prompt":"def find_max(words):\n    \"\"\"ਇੱਕ ਫੰਕਸ਼ਨ ਲਿਖੋ ਜੋ ਸਟਰਿੰਗਾਂ ਦੀ ਇੱਕ ਸੂਚੀ ਨੂੰ ਸਵੀਕਾਰ ਕਰਦਾ ਹੈ।\n    ਸੂਚੀ ਵਿੱਚ ਵੱਖ-ਵੱਖ ਸ਼ਬਦ ਹਨ। ਅਦਵਿਤੀਯ ਅੱਖਰਾਂ ਦੀ ਵੱਧ ਤੋਂ ਵੱਧ ਗਿਣਤੀ ਵਾਲਾ ਸ਼ਬਦ ਵਾਪਸ ਕਰੋ। ਜੇਕਰ ਕਈ ਸਟਰਿੰਗਾਂ ਵਿੱਚ ਅਦਵਿਤੀਯ ਅੱਖਰਾਂ ਦੀ ਵੱਧ ਤੋਂ ਵੱਧ ਗਿਣਤੀ ਹੋਵੇ, ਤਾਂ ਉਹ ਵਾਪਸ ਕਰੋ ਜੋ ਲੈਕਸੀਕੋਗ੍ਰਾਫਿਕਲ ਕ੍ਰਮ ਵਿੱਚ ਪਹਿਲਾਂ ਆਉਂਦਾ ਹੈ।\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"aaaaaaa\"\n    \"\"\"","canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n","entry_point":"find_max"}
{"task_id":"HumanEval\/159","prompt":"def eat(number, need, remaining):\n    \"\"\"\n    ਤੁਸੀਂ ਇੱਕ ਭੁੱਖਾ ਖਰਗੋਸ਼ ਹੋ, ਅਤੇ ਤੁਸੀਂ ਪਹਿਲਾਂ ਹੀ ਕੁਝ ਗਾਜਰਾਂ ਖਾ ਲਈਆਂ ਹਨ,\n    ਪਰ ਹੁਣ ਤੁਹਾਨੂੰ ਦਿਨ ਦੇ ਭੋਜਨ ਪੂਰੇ ਕਰਨ ਲਈ ਹੋਰ ਗਾਜਰਾਂ ਖਾਣ ਦੀ ਲੋੜ ਹੈ।\n    ਤੁਸੀਂ ਇੱਕ array ਵਾਪਸ ਕਰਨੀ ਚਾਹੀਦੀ ਹੈ [ ਤੁਹਾਡੇ ਭੋਜਨ ਤੋਂ ਬਾਅਦ ਖਾਧੀਆਂ ਗਾਜਰਾਂ ਦੀ ਕੁੱਲ ਗਿਣਤੀ,\n                                    ਤੁਹਾਡੇ ਭੋਜਨ ਤੋਂ ਬਾਅਦ ਬਚੀਆਂ ਗਾਜਰਾਂ ਦੀ ਗਿਣਤੀ ]\n    ਜੇ ਬਚੀਆਂ ਗਾਜਰਾਂ ਕਾਫੀ ਨਹੀਂ ਹਨ, ਤਾਂ ਤੁਸੀਂ ਸਾਰੀਆਂ ਬਚੀਆਂ ਗਾਜਰਾਂ ਖਾ ਲਵੋਗੇ, ਪਰ ਫਿਰ ਵੀ ਭੁੱਖੇ ਰਹੋਗੇ।\n    \n    ਉਦਾਹਰਣ:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    ਵੇਰੀਏਬਲ:\n    @number : ਪੂਰਨਾਂਕ\n        ਗਾਜਰਾਂ ਦੀ ਗਿਣਤੀ ਜੋ ਤੁਸੀਂ ਖਾ ਚੁੱਕੇ ਹੋ।\n    @need : ਪੂਰਨਾਂਕ\n        ਗਾਜਰਾਂ ਦੀ ਗਿਣਤੀ ਜੋ ਤੁਹਾਨੂੰ ਖਾਣ ਦੀ ਲੋੜ ਹੈ।\n    @remaining : ਪੂਰਨਾਂਕ\n        ਸਟਾਕ ਵਿੱਚ ਮੌਜੂਦ ਬਚੀਆਂ ਗਾਜਰਾਂ ਦੀ ਗਿਣਤੀ\n    \n    ਬੰਦਿਸ਼:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    ਮਜ਼ੇ ਕਰੋ :)\n    \"\"\"\n","canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n","entry_point":"eat"}
{"task_id":"HumanEval\/160","prompt":"def do_algebra(operator, operand):\n    \"\"\"\n    ਦੋ ਸੂਚੀਆਂ operator ਅਤੇ operand ਦਿੱਤੀਆਂ ਗਈਆਂ ਹਨ। ਪਹਿਲੀ ਸੂਚੀ ਵਿੱਚ ਬੁਨਿਆਦੀ ਬੀਜਗਣਿਤ ਕਾਰਜ ਹਨ, ਅਤੇ \n    ਦੂਜੀ ਸੂਚੀ ਵਿੱਚ ਪੂਰਨਾਂਕ ਹਨ। ਦਿੱਤੀਆਂ ਗਈਆਂ ਦੋ ਸੂਚੀਆਂ ਨੂੰ ਵਰਤ ਕੇ ਬੀਜਗਣਿਤ ਸਮੀਕਰਣ ਬਣਾਓ ਅਤੇ ਇਸ ਸਮੀਕਰਣ ਦਾ ਮੁੱਲਾਂਕਣ ਕਰ ਕੇ ਵਾਪਸ ਕਰੋ।\n\n    ਬੁਨਿਆਦੀ ਬੀਜਗਣਿਤ ਕਾਰਜ:\n    ਜੋੜ ( + ) \n    ਘਟਾਓ ( - ) \n    ਗੁਣਾ ( * ) \n    ਫਰਸ਼ ਵਿਭਾਜਨ ( \/\/ ) \n    ਘਾਤਾਂਕ ( ** ) \n\n    ਉਦਾਹਰਣ:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    ਨੋਟ:\n        operator ਸੂਚੀ ਦੀ ਲੰਬਾਈ operand ਸੂਚੀ ਦੀ ਲੰਬਾਈ ਤੋਂ ਇੱਕ ਘਟ ਹੁੰਦੀ ਹੈ।\n        Operand ਇੱਕ ਗੈਰ-ਨਕਾਰਾਤਮਕ ਪੂਰਨਾਂਕਾਂ ਦੀ ਸੂਚੀ ਹੈ।\n        Operator ਸੂਚੀ ਵਿੱਚ ਘੱਟੋ-ਘੱਟ ਇੱਕ ਕਾਰਜ ਹੁੰਦਾ ਹੈ, ਅਤੇ operand ਸੂਚੀ ਵਿੱਚ ਘੱਟੋ-ਘੱਟ ਦੋ operands ਹੁੰਦੇ ਹਨ।\n\n    \"\"\"","canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"do_algebra"}
{"task_id":"HumanEval\/161","prompt":"def solve(s):\n    \"\"\"ਤੁਹਾਨੂੰ ਇੱਕ ਸਟਰਿੰਗ s ਦਿੱਤੀ ਗਈ ਹੈ।\n    ਜੇ s[i] ਇੱਕ ਅੱਖਰ ਹੈ, ਤਾਂ ਇਸਦਾ ਕੇਸ ਛੋਟੇ ਤੋਂ ਵੱਡੇ ਜਾਂ ਇਸਦੇ ਉਲਟ ਕਰੋ,\n    ਨਹੀਂ ਤਾਂ ਇਸਨੂੰ ਜਿਵੇਂ ਹੈ ਵੈਸੇ ਹੀ ਰੱਖੋ।\n    ਜੇ ਸਟਰਿੰਗ ਵਿੱਚ ਕੋਈ ਅੱਖਰ ਨਹੀਂ ਹੈ, ਤਾਂ ਸਟਰਿੰਗ ਨੂੰ ਉਲਟ ਦਿਓ।\n    ਫੰਕਸ਼ਨ ਨਤੀਜੇ ਵਾਲੀ ਸਟਰਿੰਗ ਨੂੰ ਵਾਪਸ ਕਰਨਾ ਚਾਹੀਦਾ ਹੈ।\n    ਉਦਾਹਰਣ\n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"","canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n","entry_point":"solve"}
{"task_id":"HumanEval\/162","prompt":"def string_to_md5(text):\n    \"\"\"\n    ਜੇਕਰ 'text' ਇੱਕ ਸਟਰਿੰਗ ਹੈ, ਤਾਂ ਇਸਦੇ md5 ਹੈਸ਼ ਬਰਾਬਰ ਸਟਰਿੰਗ ਨੂੰ ਵਾਪਸ ਕਰੋ।\n    ਜੇ 'text' ਇੱਕ ਖਾਲੀ ਸਟਰਿੰਗ ਹੈ, ਤਾਂ None ਨੂੰ ਵਾਪਸ ਕਰੋ।\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"","canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"string_to_md5"}
{"task_id":"HumanEval\/163","prompt":"def generate_integers(a, b):\n    \"\"\"\n    ਦੋ ਸਕਾਰਾਤਮਕ ਪੂਰਨ ਅੰਕ ਦਿੱਤੇ ਗਏ ਹਨ a ਅਤੇ b, a ਅਤੇ b ਦੇ ਵਿਚਕਾਰ ਦੇ ਸਮਾਨ ਅੰਕਾਂ ਨੂੰ ਚੜ੍ਹਦੇ ਕ੍ਰਮ ਵਿੱਚ ਵਾਪਸ ਕਰੋ।\n\n    ਉਦਾਹਰਣ ਲਈ:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n","canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"generate_integers"}
