{"task_id":"HumanEval\/0","prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" جانچیں کہ دی گئی نمبروں کی فہرست میں، کیا کوئی دو نمبر ایک دوسرے کے مقابلے میں دی گئی دہلیز سے زیادہ قریب ہیں۔\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n","canonical_solution":"    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n","entry_point":"has_close_elements"}
{"task_id":"HumanEval\/1","prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" اس فنکشن کو دی جانے والی ان پٹ ایک ایسی سٹرنگ ہے جس میں متعدد گروپس کے نسٹڈ قوسین ہوتے ہیں۔ آپ کا مقصد ہے کہ\n    ان گروپس کو الگ الگ سٹرنگز میں تقسیم کریں اور ان کی فہرست واپس کریں۔\n    الگ گروپس متوازن ہوتے ہیں (ہر کھلا قوس مناسب طریقے سے بند ہوتا ہے) اور ایک دوسرے کے اندر نسٹڈ نہیں ہوتے\n    ان پٹ سٹرنگ میں کسی بھی جگہ کو نظرانداز کریں۔\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n","canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n","entry_point":"separate_paren_groups"}
{"task_id":"HumanEval\/2","prompt":"\ndef truncate_number(number: float) -> float:\n    \"\"\" ایک مثبت فلوٹنگ پوائنٹ نمبر کو دو حصوں میں تقسیم کیا جا سکتا ہے\n    ایک عددی حصہ (دی گئی نمبر سے بڑا سب سے بڑا عدد) اور اعشاریہ\n    (باقی حصہ ہمیشہ 1 سے کم ہوتا ہے).\n\n    نمبر کا اعشاریہ حصہ واپس کریں۔\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n","canonical_solution":"    return number % 1.0\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n","entry_point":"truncate_number"}
{"task_id":"HumanEval\/3","prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" آپ کو ایک بینک اکاؤنٹ کی جمع اور نکالنے کی فہرست دی گئی ہے جو کہ\n    صفر بیلنس سے شروع ہوتی ہے۔ آپ کا کام یہ پتہ لگانا ہے کہ کسی بھی مقام پر اکاؤنٹ کا بیلنس صفر سے نیچے چلا جاتا ہے، اور\n    اس مقام پر فنکشن کو True واپس کرنا چاہیے۔ بصورت دیگر اسے False واپس کرنا چاہیے۔\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"\n","canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n","entry_point":"below_zero"}
{"task_id":"HumanEval\/4","prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" دی گئی فہرست کے اعداد کے لیے، اوسط مطلق انحراف کا حساب لگائیں\n    جو کہ اس ڈیٹا سیٹ کے اوسط کے گرد ہوتا ہے۔\n    اوسط مطلق انحراف ہر عنصر اور مرکزی نقطہ (اس معاملے میں اوسط) کے درمیان\n    اوسط مطلق فرق ہوتا ہے:\n    MAD = اوسط | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n","canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n","entry_point":"mean_absolute_deviation"}
{"task_id":"HumanEval\/5","prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" ان پٹ لسٹ 'numbers' کے ہر دو متواتر عناصر کے درمیان ایک نمبر 'delimeter' داخل کریں\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n","canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n","entry_point":"intersperse"}
{"task_id":"HumanEval\/6","prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" اس فنکشن کی ان پٹ ایک ایسی سٹرنگ ہے جو متعدد گروپس کو ظاہر کرتی ہے جو نیسٹڈ پیرنتھیسز سے بنی ہوئی ہیں اور جگہ جگہ سے الگ ہوتی ہیں۔\n    ہر ایک گروپ کے لئے، پیرنتھیسز کی گہرائی کی سب سے زیادہ سطح کو آؤٹ پٹ کریں۔\n    مثال کے طور پر (()()) میں زیادہ سے زیادہ دو سطح کی گہرائی ہے جبکہ ((())) میں تین ہیں۔\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n","canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n","entry_point":"parse_nested_parens"}
{"task_id":"HumanEval\/7","prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" ان پٹ کی فہرست میں سے صرف ان سٹرنگز کو فلٹر کریں جو دی گئی سبسٹرنگ کو موجود ہوں\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n","canonical_solution":"    return [x for x in strings if substring in x]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n","entry_point":"filter_by_substring"}
{"task_id":"HumanEval\/8","prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" دی گئی فہرست کے عددی اعداد کے لئے، ایک جوڑی واپس کریں جس میں فہرست میں موجود تمام عددی اعداد کا مجموعہ اور ضرب شامل ہو۔\n    خالی مجموعہ کو 0 کے برابر اور خالی ضرب کو 1 کے برابر ہونا چاہئے۔\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n","canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n","entry_point":"sum_product"}
{"task_id":"HumanEval\/9","prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" دی گئی فہرست میں سے اعداد کی فہرست بنائیں، جس میں ہر مقام تک پہنچنے والے سلسلے میں اب تک کی سب سے بڑی عدد کو دکھایا گیا ہو۔\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n","canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n","entry_point":"rolling_max"}
{"task_id":"HumanEval\/10","prompt":"\ndef is_palindrome(string: str) -> bool:\n    \"\"\" یہ چیک کریں کہ دی گئی سٹرنگ ایک پیلنڈروم ہے یا نہیں \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" ایک مختصر ترین پیلنڈروم بنائیں جو دی گئی سٹرنگ سے شروع ہوتا ہے۔\n    الگورتھم کا خیال سادہ ہے:\n    - دی گئی سٹرنگ کا سب سے طویل پوسٹفکس تلاش کریں جو کہ ایک پیلنڈروم ہو۔\n    - سٹرنگ کے آخر میں اس پریفکس کا الٹا جوڑیں جو پیلنڈرومک سفکس سے پہلے آتا ہے۔\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"","canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n","entry_point":"make_palindrome"}
{"task_id":"HumanEval\/11","prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" دو سٹرنگز a اور b کا ان پٹ ہے جو صرف 1s اور 0s پر مشتمل ہوتی ہیں۔\n    ان ان پٹس پر بائنری XOR کا عمل کریں اور نتیجہ بھی ایک سٹرنگ کے طور پر واپس کریں۔\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n","canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n","entry_point":"string_xor"}
{"task_id":"HumanEval\/12","prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" فہرست میں سے سب سے طویل سٹرنگ واپس کریں۔ اگر متعدد سٹرنگز ایک ہی لمبائی کے ہوں تو پہلی والی واپس کریں۔ اگر ان پٹ کی فہرست خالی ہو تو None واپس کریں۔\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n","canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n","entry_point":"longest"}
{"task_id":"HumanEval\/13","prompt":"\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" دو عددی صحیح اعداد a اور b کا سب سے بڑا مشترکہ مقسوم الیہ واپس کریں\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"","canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n","entry_point":"greatest_common_divisor"}
{"task_id":"HumanEval\/14","prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" دی گئی سٹرنگ کے تمام پریفکسز کی فہرست مختصر سے طویل تر تک واپس کریں\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n","canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n","entry_point":"all_prefixes"}
{"task_id":"HumanEval\/15","prompt":"def string_sequence(n: int) -> str:\n    \"\"\" 0 سے شروع ہو کر n تک کی جگہ سے محدود اعداد پر مشتمل ایک سٹرنگ واپس کریں۔\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"","canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n","entry_point":"string_sequence"}
{"task_id":"HumanEval\/16","prompt":"def count_distinct_characters(string: str) -> int:\n    \"\"\" دی گئی ایک سٹرنگ میں یہ معلوم کریں کہ کتنے مختلف حروف (کیس کی پرواہ کیے بغیر) شامل ہیں\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"","canonical_solution":"    return len(set(string.lower()))\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n","entry_point":"count_distinct_characters"}
{"task_id":"HumanEval\/17","prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" اس فنکشن کو دی جانے والی ان پٹ ایک خاص ASCII فارمیٹ میں موسیقی کے نوٹوں کی نمائندگی کرنے والی ایک سٹرنگ ہے۔\n    آپ کا کام اس سٹرنگ کو پارس کرنا اور ایک ایسی فہرست واپس کرنا ہے جو ہر نوٹ کے لیے بیٹس کی تعداد کو ظاہر کرتی ہو۔\n\n    یہاں ایک لیجنڈ ہے:\n    'o' - پورا نوٹ، چار بیٹس تک رہتا ہے\n    'o|' - آدھا نوٹ، دو بیٹس تک رہتا ہے\n    '.|' - چوتھائی نوٹ، ایک بیٹ تک رہتا ہے\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n","canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n","entry_point":"parse_music"}
{"task_id":"HumanEval\/18","prompt":"\ndef how_many_times(string: str, substring: str) -> int:\n    \"\"\" معلوم کریں کہ دی گئی ذیلی سٹرنگ اصل سٹرنگ میں کتنی بار پائی جاتی ہے۔ اوورلیپنگ کیسز کو بھی شمار کریں۔\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n","canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n","entry_point":"how_many_times"}
{"task_id":"HumanEval\/19","prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" ان پٹ ایک جگہ سے محدود سٹرنگ ہے جس میں 'zero' سے 'nine' تک کے اعداد ہوتے ہیں۔\n    درست انتخاب 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' اور 'nine' ہیں۔\n    سب سے چھوٹے سے لے کر سب سے بڑے تک نمبروں کو ترتیب دے کر سٹرنگ واپس کریں\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n","canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n","entry_point":"sort_numbers"}
{"task_id":"HumanEval\/20","prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" فراہم کردہ نمبروں کی فہرست سے (جس کی لمبائی کم از کم دو ہو) دو ایسے نمبر منتخب کریں اور واپس کریں جو ایک دوسرے کے قریب ترین ہوں\n    اور انہیں ترتیب میں واپس کریں (چھوٹا نمبر، بڑا نمبر).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n","canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n","entry_point":"find_closest_elements"}
{"task_id":"HumanEval\/21","prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" دی گئی نمبروں کی فہرست (کم از کم دو عناصر کی) کو ایک لکیری تبدیلی کا اطلاق کریں،\n    ایسا کہ سب سے چھوٹا نمبر 0 بن جائے گا اور سب سے بڑا 1 بن جائے گا\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n","canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n","entry_point":"rescale_to_unit"}
{"task_id":"HumanEval\/22","prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" دی گئی کسی بھی پائتھون ویلیوز کی فہرست کو صرف عدد صحیح کے لئے فلٹر کریں\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n","canonical_solution":"    return [x for x in values if isinstance(x, int)]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n","entry_point":"filter_integers"}
{"task_id":"HumanEval\/23","prompt":"\ndef strlen(string: str) -> int:\n    \"\"\" دی گئی سٹرنگ کی لمبائی واپس کریں\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"","canonical_solution":"    return len(string)\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n","entry_point":"strlen"}
{"task_id":"HumanEval\/24","prompt":"\ndef largest_divisor(n: int) -> int:\n    \"\"\" دی گئی عدد n کے لئے، سب سے بڑی عدد تلاش کریں جو n کو برابر تقسیم کرتا ہے، n سے چھوٹا\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n","canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n","entry_point":"largest_divisor"}
{"task_id":"HumanEval\/25","prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" دی گئی عدد کے اول عوامل کی فہرست کو چھوٹے سے بڑے ترتیب میں واپس کریں۔\n    ہر عامل کو اتنی بار درج کیا جانا چاہئے جتنی بار وہ عاملیت میں ظاہر ہوتا ہے۔\n    ان پٹ نمبر ان تمام عوامل کی مصنوع کے برابر ہونا چاہئے\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n","canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n","entry_point":"factorize"}
{"task_id":"HumanEval\/26","prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" ایک فہرست میں سے تمام عناصر کو ہٹا دیں جو ایک سے زیادہ بار آتے ہیں۔\n    باقی عناصر کا ترتیب وہی رکھیں جو ان پٹ میں ہے۔\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n","canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n","entry_point":"remove_duplicates"}
{"task_id":"HumanEval\/27","prompt":"\ndef flip_case(string: str) -> str:\n    \"\"\" ایک دی گئی سٹرنگ کے لئے، چھوٹے حروف کو بڑے حروف میں اور بڑے حروف کو چھوٹے حروف میں بدل دیں۔\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"","canonical_solution":"    return string.swapcase()\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n","entry_point":"flip_case"}
{"task_id":"HumanEval\/28","prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" فہرست میں موجود تمام سٹرنگز کو ایک سنگل سٹرنگ میں ملا دیں\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n","canonical_solution":"    return ''.join(strings)\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n","entry_point":"concatenate"}
{"task_id":"HumanEval\/29","prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" ایک دی گئی پریفکس کے ساتھ شروع ہونے والی سٹرنگز کے لیے ان پٹ لسٹ کو فلٹر کریں۔\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n","canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n","entry_point":"filter_by_prefix"}
{"task_id":"HumanEval\/30","prompt":"\ndef get_positive(l: list):\n    \"\"\"فہرست میں موجود صرف مثبت اعداد واپس کریں۔\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n","canonical_solution":"    return [e for e in l if e > 0]\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n","entry_point":"get_positive"}
{"task_id":"HumanEval\/31","prompt":"def is_prime(n):\n    \"\"\"ایک دی گئی نمبر کے اول ہونے کی صورت میں سچ اور بصورت دیگر جھوٹ واپس کریں۔\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"","canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n","entry_point":"is_prime"}
{"task_id":"HumanEval\/32","prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    ایک نقطہ x پر xs کے عددی سر والے کثیر رکنی کی قیمت کا حساب لگائیں۔\n    واپسی xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs ایک کثیر رکنی کے عددی سر ہیں۔\n    find_zero ایسا x تلاش کرتا ہے کہ poly(x) = 0 ہو۔\n    find_zero صرف ایک صفر نقطہ واپس کرتا ہے، چاہے وہاں کئی ہوں۔\n    مزید برآں، find_zero صرف ایسی xs کی فہرست لیتا ہے جس میں جفت تعداد کے عددی سر ہوں\n    اور سب سے بڑا غیر صفر عددی سر ہو کیونکہ یہ حل کی ضمانت دیتا ہے۔\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n","canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n","entry_point":"find_zero"}
{"task_id":"HumanEval\/33","prompt":"def sort_third(l: list):\n    \"\"\"یہ فنکشن ایک لسٹ l لیتا ہے اور ایک لسٹ l' واپس کرتا ہے ایسے کہ\n    l' بالکل l کے مطابق ہے ان انڈیکسز پر جو تین سے قابل تقسیم نہیں ہیں، جبکہ اس کی قیمتیں ان انڈیکسز پر جو تین سے قابل تقسیم ہیں\n    l کے مطابقتی انڈیکسز کی قیمتوں کے برابر ہیں، لیکن ترتیب دی گئی ہیں۔\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"","canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n","entry_point":"sort_third"}
{"task_id":"HumanEval\/34","prompt":"\ndef unique(l: list):\n    \"\"\"فہرست میں موجود منفرد عناصر کو ترتیب دے کر واپس کریں\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n","canonical_solution":"    return sorted(list(set(l)))\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n","entry_point":"unique"}
{"task_id":"HumanEval\/35","prompt":"def max_element(l: list):\n    \"\"\"فہرست میں سب سے بڑا عنصر واپس کریں۔\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"","canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n","entry_point":"max_element"}
{"task_id":"HumanEval\/36","prompt":"\ndef fizz_buzz(n: int):\n    \"\"\"n سے کم عددی اعداد میں ہندسہ 7 کتنی بار آتا ہے جو 11 یا 13 سے قابل تقسیم ہیں کی تعداد واپس کریں۔\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"","canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n","entry_point":"fizz_buzz"}
{"task_id":"HumanEval\/37","prompt":"def sort_even(l: list):\n    \"\"\"یہ فنکشن ایک لسٹ l لیتا ہے اور ایک لسٹ l' واپس کرتا ہے ایسے کہ\n    l' کی طاق انڈیکسز پر l کے مطابق ہوتی ہے، جبکہ اس کی قیمتیں جفت انڈیکسز پر\n    l کے جفت انڈیکسز کی قیمتوں کے مطابق ہوتی ہیں، لیکن ترتیب شدہ ہوتی ہیں۔\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n","canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n","entry_point":"sort_even"}
{"task_id":"HumanEval\/38","prompt":"def encode_cyclic(s: str):\n    \"\"\"\n    تین حروف کے گروپوں کو سائیکل کرکے انکوڈ شدہ سٹرنگ واپس کرتا ہے۔\n    \"\"\"\n    # سٹرنگ کو گروپوں میں تقسیم کریں۔ ہر ایک کی لمبائی 3 ہے۔\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # ہر گروپ میں عناصر کو سائیکل کریں۔ سوائے اس کے جب گروپ میں عناصر 3 سے کم ہوں۔\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    انکوڈ سائیکل فنکشن کے ساتھ انکوڈ کی گئی سٹرنگ کو ان پٹ کے طور پر لیتا ہے۔ ڈیکوڈ شدہ سٹرنگ واپس کرتا ہے۔\n    \"\"\"","canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n","entry_point":"decode_cyclic"}
{"task_id":"HumanEval\/39","prompt":"\ndef prime_fib(n: int):\n    \"\"\"\n    prime_fib وہ n-ویں نمبر واپس کرتا ہے جو کہ فیبونیکی نمبر ہے اور یہ ایک اول نمبر بھی ہے۔\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n","canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n","entry_point":"prime_fib"}
{"task_id":"HumanEval\/40","prompt":"\ndef triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero ایک ایسی فہرست کو بطور ان پٹ لیتا ہے جس میں صرف عدد ہوتے ہیں۔\n    اگر فہرست میں تین مختلف عناصر ایسے ہوں جن کا مجموعہ صفر کے برابر ہو، تو یہ True واپس کرتا ہے،\n    ورنہ False واپس کرتا ہے۔\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n","canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n","entry_point":"triples_sum_to_zero"}
{"task_id":"HumanEval\/41","prompt":"\ndef car_race_collision(n: int):\n    \"\"\"\n    تصور کریں کہ ایک سڑک ہے جو ایک بالکل سیدھی لامحدود طویل لکیر ہے۔\n    n کاریں بائیں سے دائیں جا رہی ہیں؛ اسی طرح، ایک مختلف سیٹ کی n کاریں\n    دائیں سے بائیں جا رہی ہیں۔ دونوں سیٹ کی کاریں ایک دوسرے سے بہت دور شروع ہوتی ہیں۔\n    تمام کاریں ایک ہی رفتار سے حرکت کر رہی ہیں۔ جب ایک کار جو بائیں سے دائیں جا رہی ہو\n    ایک کار سے ٹکرا جاتی ہے جو دائیں سے بائیں جا رہی ہو تو کہا جاتا ہے کہ کاریں ٹکرا گئی ہیں۔\n    تاہم، کاریں لامحدود مضبوط اور مستحکم ہیں؛ نتیجتاً، وہ اپنے راستے میں ایسے حرکت کرتی رہتی ہیں\n    جیسے انہوں نے ٹکرایا ہی نہ ہو۔\n\n    یہ فنکشن ایسی ٹکراؤں کی تعداد کو آؤٹ پٹ کرتا ہے۔\n    \"\"\"\n","canonical_solution":"    return n**2\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n","entry_point":"car_race_collision"}
{"task_id":"HumanEval\/42","prompt":"def incr_list(l: list):\n    \"\"\"فہرست کے عناصر کو ایک سے بڑھا کر واپس کریں۔\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n","canonical_solution":"    return [(e + 1) for e in l]\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n","entry_point":"incr_list"}
{"task_id":"HumanEval\/43","prompt":"\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero ایک انٹیجرز کی فہرست کو ان پٹ کے طور پر لیتا ہے۔\n    اگر فہرست میں دو مختلف عناصر ہیں جو صفر کے برابر جمع ہوتے ہیں، تو یہ True واپس کرتا ہے،\n    اور بصورت دیگر False واپس کرتا ہے۔\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n","canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n","entry_point":"pairs_sum_to_zero"}
{"task_id":"HumanEval\/44","prompt":"def change_base(x: int, base: int):\n    \"\"\"دی گئی عدد x کی نمائندگی کو دی گئی بنیاد base پر تبدیل کریں۔\n    تبدیلی کے بعد کی string نمائندگی واپس کریں۔\n    بنیاد کی عددیں 10 سے کم ہیں۔\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"","canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n","entry_point":"change_base"}
{"task_id":"HumanEval\/45","prompt":"\ndef triangle_area(a, h):\n    \"\"\"ایک ضلع اور اونچائی کی لمبائی دی گئی ہے، ایک مثلث کا رقبہ واپس کریں۔\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n","canonical_solution":"    return a * h \/ 2.0\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n","entry_point":"triangle_area"}
{"task_id":"HumanEval\/46","prompt":"\ndef fib4(n: int):\n    \"\"\"Fib4 نمبر سیکوئنس ایک ایسی سیریز ہے جو فبونیکی سیکوئنس کی طرح ہے جس کی تعریف مندرجہ ذیل ہے:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    براہ کرم ایک ایسا فنکشن لکھیں جو fib4 نمبر سیریز کے n-ویں عنصر کو موثر طریقے سے حساب کرے۔ استعمال نہ کریں دوبارہ آنے والی کال (recursion).\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"","canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n","entry_point":"fib4"}
{"task_id":"HumanEval\/47","prompt":"def median(l: list):\n    \"\"\"فہرست l میں عناصر کا وسطانیہ واپس کریں۔\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"","canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n","entry_point":"median"}
{"task_id":"HumanEval\/48","prompt":"\ndef is_palindrome(text: str):\n    \"\"\"\n    یہ چیک کرتا ہے کہ دی گئی سٹرنگ ایک پیلنڈروم ہے یا نہیں\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n","canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n","entry_point":"is_palindrome"}
{"task_id":"HumanEval\/49","prompt":"\ndef modp(n: int, p: int):\n    \"\"\"2^n ko p se modulo kar k wapis karein (numeric issues ka khayal rakhein).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"","canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n","entry_point":"modp"}
{"task_id":"HumanEval\/50","prompt":"\ndef encode_shift(s: str):\n    \"\"\"\n    ہر حرف کو الفباء میں 5 کی شفٹ کے ساتھ خفیہ کردہ سٹرنگ واپس کرتا ہے۔\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    ان پٹ سٹرنگ کو لیتا ہے جو encode_shift فنکشن کے ساتھ خفیہ کی گئی ہو۔ خفیہ کردہ سٹرنگ واپس کرتا ہے۔\n    \"\"\"","canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n","entry_point":"decode_shift"}
{"task_id":"HumanEval\/51","prompt":"\ndef remove_vowels(text):\n    \"\"\"\n    remove_vowels ایک ایسا فنکشن ہے جو ایک سٹرنگ لیتا ہے اور واپس سٹرنگ بغیر حروفِ علت کے لوٹاتا ہے۔\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n","canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n","entry_point":"remove_vowels"}
{"task_id":"HumanEval\/52","prompt":"\ndef below_threshold(l: list, t: int):\n    \"\"\"اگر فہرست l میں تمام نمبرز دہلیز t سے نیچے ہیں تو True واپس کریں۔\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n","canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n","entry_point":"below_threshold"}
{"task_id":"HumanEval\/53","prompt":"\ndef add(x: int, y: int):\n    \"\"\"دو نمبرز x اور y کو جمع کریں\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n","canonical_solution":"    return x + y\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n","entry_point":"add"}
{"task_id":"HumanEval\/54","prompt":"\ndef same_chars(s0: str, s1: str):\n    \"\"\"\n    یہ چیک کریں کہ دو الفاظ میں یکساں حروف ہیں یا نہیں۔\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n","canonical_solution":"    return set(s0) == set(s1)\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n","entry_point":"same_chars"}
{"task_id":"HumanEval\/55","prompt":"\ndef fib(n: int):\n    \"\"\"n-th Fibonacci number wapas karein.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"","canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n","entry_point":"fib"}
{"task_id":"HumanEval\/56","prompt":"def correct_bracketing(brackets: str):\n    \"\"\" brackets ایک ایسی سٹرنگ ہے جس میں \"<\" اور \">\" شامل ہیں۔\n    اگر ہر کھلنے والے بریکٹ کا مطابقتی بند بریکٹ ہو تو True واپس کریں۔\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"","canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n","entry_point":"correct_bracketing"}
{"task_id":"HumanEval\/57","prompt":"\ndef monotonic(l: list):\n    \"\"\"فہرست کے عناصر اگر مسلسل بڑھتے یا گھٹتے ہوں تو True واپس کریں۔\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"","canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n","entry_point":"monotonic"}
{"task_id":"HumanEval\/58","prompt":"\ndef common(l1: list, l2: list):\n    \"\"\"دو فہرستوں کے لئے مشترکہ منفرد عناصر کو مرتب کر کے واپس کریں۔\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"","canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n","entry_point":"common"}
{"task_id":"HumanEval\/59","prompt":"\ndef largest_prime_factor(n: int):\n    \"\"\"n کا سب سے بڑا اول عنصر واپس کریں۔ فرض کریں کہ n > 1 ہے اور اول نہیں ہے۔\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n","canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n","entry_point":"largest_prime_factor"}
{"task_id":"HumanEval\/60","prompt":"\ndef sum_to_n(n: int):\n    \"\"\"sum_to_n ایک ایسا فنکشن ہے جو 1 سے n تک کے اعداد کا مجموعہ کرتا ہے۔\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"","canonical_solution":"    return sum(range(n + 1))\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n","entry_point":"sum_to_n"}
{"task_id":"HumanEval\/61","prompt":"def correct_bracketing(brackets: str):\n    \"\"\" brackets ایک ایسی سٹرنگ ہے جس میں \"(\" اور \")\" شامل ہیں۔\n    اگر ہر کھلنے والے بریکٹ کا مطابقتی بند بریکٹ ہو تو True واپس کریں۔\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"","canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n","entry_point":"correct_bracketing"}
{"task_id":"HumanEval\/62","prompt":"def derivative(xs: list):\n    \"\"\" xs ایک کثیر رقمی کے عددی سر ہیں۔\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     اس کثیر رقمی کا تفرق اسی شکل میں واپس کریں۔\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"","canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n","entry_point":"derivative"}
{"task_id":"HumanEval\/63","prompt":"def fibfib(n: int):\n    \"\"\"FibFib نمبر سیکوئنس ایک ایسی سیریز ہے جو فبونیکی سیکوئنس کی طرح ہے جس کی تعریف مندرجہ ذیل ہے:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    براہ کرم ایک فنکشن لکھیں جو فیب فیب نمبر سیریز کے n-ویں عنصر کو موثر طریقے سے حساب کرے۔\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"","canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n","entry_point":"fibfib"}
{"task_id":"HumanEval\/64","prompt":"FIX = \"\"\"\nمزید ٹیسٹ کیسز شامل کریں۔\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"ایک فنکشن vowels_count لکھیں جو ایک لفظ کو ظاہر کرنے والی ایک سٹرنگ کو ان پٹ کے طور پر لیتا ہے اور سٹرنگ میں موجود حروفِ علت کی تعداد کو واپس کرتا ہے۔\n    اس کیس میں حروفِ علت 'a', 'e', 'i', 'o', 'u' ہیں۔ یہاں، 'y' بھی ایک حرفِ علت ہے، لیکن صرف جب وہ دیے گئے لفظ کے آخر میں ہو۔\n\n    مثال:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n","canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"vowels_count"}
{"task_id":"HumanEval\/65","prompt":"def circular_shift(x, shift):\n    \"\"\"عددی صحیح x کے ہندسوں کو دائرہ کار شفٹ کریں، ہندسوں کو دائیں طرف shift کے حساب سے شفٹ کریں\n    اور نتیجہ کو ایک سٹرنگ کے طور پر واپس کریں۔\n    اگر shift ہندسوں کی تعداد سے زیادہ ہو، تو ہندسوں کو الٹ کر واپس کریں۔\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"","canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"circular_shift"}
{"task_id":"HumanEval\/66","prompt":"def digitSum(s):\n    \"\"\"Task\n    ایک فنکشن لکھیں جو ایک سٹرنگ کو ان پٹ کے طور پر لے اور صرف اوپر کے حروف کے ASCII کوڈز کا مجموعہ واپس کرے۔\n\n    مثالیں:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n    \"\"\"","canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n","entry_point":"digitSum"}
{"task_id":"HumanEval\/67","prompt":"def fruit_distribution(s,n):\n    \"\"\"\n    اس کام میں، آپ کو ایک ایسی سٹرنگ دی جائے گی جو ایک ٹوکری میں بانٹے گئے سیبوں اور سنتروں کی تعداد کو ظاہر کرتی ہے \n    اس ٹوکری میں سیب، سنترے، اور آم شامل ہیں۔ سیبوں اور سنتروں کی کل تعداد کو ظاہر کرنے والی سٹرنگ اور ایک عددی \n    جو ٹوکری میں پھلوں کی کل تعداد کو ظاہر کرتا ہے، دی گئی ہے، ٹوکری میں آموں کی تعداد واپس کریں۔\n    مثال کے طور پر:\n    fruit_distribution(\"5 apples and 6 oranges\", 19) -> 19 - 5 - 6 = 8\n    fruit_distribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n    fruit_distribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n    fruit_distribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n    \"\"\"\n","canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n","entry_point":"fruit_distribution"}
{"task_id":"HumanEval\/68","prompt":"def pluck(arr):\n    \"\"\"\n    \"ایک ایسے درخت کی شاخ کی نمائندگی کرنے والی ایک صف دی گئی ہے جس میں غیر منفی عددی نوڈز ہیں\n    آپ کا کام ایک نوڈ کو چن کر واپس کرنا ہے۔\n    چنا گیا نوڈ وہ نوڈ ہونا چاہیے جس کی جفت قیمت سب سے کم ہو۔\n    اگر سب سے کم جفت قیمت والے متعدد نوڈز پائے جاتے ہیں تو وہ نوڈ واپس کریں جس کا انڈیکس سب سے کم ہو۔\n\n    چنے گئے نوڈ کو ایک فہرست میں واپس کیا جانا چاہیے، [ سب سے کم قیمت, اس کا انڈیکس ],\n    اگر کوئی جفت قیمتیں نہیں ہیں یا دی گئی صف خالی ہے، تو [] واپس کریں۔\n\n    مثال 1:\n        ان پٹ: [4,2,3]\n        آؤٹ پٹ: [2, 1]\n        وضاحت: 2 کی جفت قیمت سب سے کم ہے، اور 2 کا انڈیکس سب سے کم ہے۔\n\n    مثال 2:\n        ان پٹ: [1,2,3]\n        آؤٹ پٹ: [2, 1]\n        وضاحت: 2 کی جفت قیمت سب سے کم ہے، اور 2 کا انڈیکس سب سے کم ہے۔ \n\n    مثال 3:\n        ان پٹ: []\n        آؤٹ پٹ: []\n    \n    مثال 4:\n        ان پٹ: [5, 0, 3, 0, 4, 2]\n        آؤٹ پٹ: [0, 1]\n        وضاحت: 0 سب سے کم قیمت ہے، لیکن وہاں دو صفر ہیں،\n                     اس لیے ہم پہلے صفر کا انتخاب کریں گے، جس کا انڈیکس سب سے کم ہے۔\n\n    پابندیاں:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n","canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n","entry_point":"pluck"}
{"task_id":"HumanEval\/69","prompt":"def search(lst):\n    '''\n    آپ کو ایک غیر خالی فہرست دی گئی ہے جس میں مثبت عددیں ہیں۔ ایسا سب سے بڑا عدد واپس کریں جو صفر سے زیادہ ہو، \n    اور جس کی تعدد اس عدد کی قیمت کے برابر یا اس سے زیادہ ہو۔ \n    کسی عدد کی تعدد اس کی فہرست میں موجودگی کی تعداد ہوتی ہے۔\n    اگر ایسا کوئی عدد موجود نہیں ہے، تو -1 واپس کریں۔\n    مثال کے طور پر:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''\n","canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n","test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n","entry_point":"search"}
{"task_id":"HumanEval\/70","prompt":"def strange_sort_list(lst):\n    '''\n    دی گئی انٹیجرز کی فہرست کو عجیب ترتیب میں واپس کریں۔\n    عجیب ترتیب، وہ ہے جب آپ کم سے کم قیمت سے شروع کرتے ہیں،\n    پھر باقی انٹیجرز میں سے زیادہ سے زیادہ قیمت، پھر کم سے کم اور اسی طرح۔\n\n    مثالیں:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n","canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"strange_sort_list"}
{"task_id":"HumanEval\/71","prompt":"def triangle_area(a, b, c):\n    '''\n    تین اطراف کی لمبائیوں کے ساتھ ایک مثلث دی گئی ہے۔ اگر تینوں اطراف ایک درست مثلث بناتے ہیں تو مثلث کا رقبہ دو عشاریہ نقاط تک گول کرکے واپس کریں۔\n    بصورت دیگر -1 واپس کریں۔\n    تین اطراف اس وقت ایک درست مثلث بناتے ہیں جب کسی بھی دو اطراف کا مجموعہ تیسری طرف سے زیادہ ہو۔\n    مثال:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n","canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n","entry_point":"triangle_area"}
{"task_id":"HumanEval\/72","prompt":"def will_it_fly(q,w):\n    '''\n    ایک فنکشن لکھیں جو یہ واپس کرے کہ اگر چیز q اڑے گی تو True ہو، ورنہ False ہو۔\n    چیز q اڑے گی اگر وہ متوازن ہو (یہ ایک پیلنڈرومک لسٹ ہو) اور اس کے عناصر کا مجموعہ زیادہ سے زیادہ ممکنہ وزن w سے کم یا برابر ہو۔\n\n    مثال:\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2 زیادہ سے زیادہ ممکنہ وزن سے کم ہے، لیکن یہ غیر متوازن ہے۔\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n    # یہ متوازن ہے، لیکن 3+2+3 زیادہ سے زیادہ ممکنہ وزن سے زیادہ ہے۔\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3 زیادہ سے زیادہ ممکنہ وزن سے کم ہے، اور یہ متوازن ہے۔\n\n    will_it_fly([3], 5) ➞ True\n    # 3 زیادہ سے زیادہ ممکنہ وزن سے کم ہے، اور یہ متوازن ہے۔\n    '''\n","canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n","entry_point":"will_it_fly"}
{"task_id":"HumanEval\/73","prompt":"def smallest_change(arr):\n    \"\"\"\n    ایک انٹیجرز کی ارے arr دی گئی ہے، اس ارے کو پیلنڈرومک بنانے کے لئے کم سے کم کتنے عناصر کو تبدیل کرنے کی ضرورت ہے تلاش کریں۔ ایک پیلنڈرومک ارے وہ ارے ہوتی ہے جو پیچھے اور آگے دونوں طرف سے پڑھنے میں ایک جیسی ہوتی ہے۔ ایک تبدیلی میں، آپ ایک عنصر کو کسی بھی دوسرے عنصر سے تبدیل کر سکتے ہیں۔\n\n    مثال کے طور پر:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n","canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n","entry_point":"smallest_change"}
{"task_id":"HumanEval\/74","prompt":"def total_match(lst1, lst2):\n    '''\n    ایک فنکشن لکھیں جو دو فہرستوں کو قبول کرتا ہے جو سٹرنگز کی ہوتی ہیں اور وہ فہرست واپس کرتا ہے جس میں \n    تمام سٹرنگز کے حروف کی کل تعداد دوسری فہرست سے کم ہوتی ہے۔\n\n    اگر دونوں فہرستوں میں حروف کی تعداد ایک جیسی ہو، تو پہلی فہرست واپس کریں۔\n\n    مثالیں\n    total_match([], []) ➞ []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n    '''\n","canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n","entry_point":"total_match"}
{"task_id":"HumanEval\/75","prompt":"def is_multiply_prime(a):\n    \"\"\"ایک ایسا فنکشن لکھیں جو یہ چیک کرے کہ دی گئی نمبر تین اول نمبروں کا ضرب ہے یا نہیں\n    اگر ہو تو true واپس کرے اور بصورت دیگر false.\n    معلوم ہو کہ (a) 100 سے کم ہے.\n    مثال:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"","canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n","test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n","entry_point":"is_multiply_prime"}
{"task_id":"HumanEval\/76","prompt":"def is_simple_power(x, n):\n    \"\"\"آپ کا کام ایک ایسا فنکشن لکھنا ہے جو یہ چیک کرے کہ کوئی نمبر x n کی سادہ طاقت ہے یا نہیں۔\n    اگر n**int=x ہو تو x n کی سادہ طاقت ہے۔\n    مثال کے طور پر:\n    is_simple_power(1, 4) => true\n    is_simple_power(2, 2) => true\n    is_simple_power(8, 2) => true\n    is_simple_power(3, 2) => false\n    is_simple_power(3, 1) => false\n    is_simple_power(5, 3) => false\n    \"\"\"","canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"is_simple_power"}
{"task_id":"HumanEval\/77","prompt":"def iscube(a):\n    '''\n    ایک فنکشن لکھیں جو ایک عدد a لے اور True واپس کرے \n    اگر یہ عدد کسی عدد کا کیوب ہو۔\n    نوٹ: آپ یہ مان سکتے ہیں کہ ان پٹ ہمیشہ درست ہوتا ہے۔\n    مثالیں:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n","canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n","entry_point":"iscube"}
{"task_id":"HumanEval\/78","prompt":"def hex_key(num):\n    \"\"\"آپ کو ایک فنکشن لکھنے کا کام دیا گیا ہے جو ایک ہیکساڈیسمل نمبر کو \n    ایک سٹرنگ کے طور پر وصول کرتا ہے اور ہیکساڈیسمل ہندسوں کی تعداد گنتا ہے \n    جو اعداد اول ہیں (اعداد اول، یا ایک اول، ایک قدرتی نمبر ہے جو 1 سے زیادہ ہے \n    جو دو چھوٹے قدرتی نمبروں کا مصنوع نہیں ہے).\n    ہیکساڈیسمل ہندسے 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F ہیں.\n    اعداد اول 2, 3, 5, 7, 11, 13, 17,... ہیں.\n    لہذا آپ کو مندرجہ ذیل ہندسوں کی تعداد کا تعین کرنا ہوگا: 2, 3, 5, 7, \n    B (=دسیمل 11), D (=دسیمل 13).\n    نوٹ: آپ یہ مان سکتے ہیں کہ ان پٹ ہمیشہ درست یا خالی سٹرنگ ہوتا ہے، \n    اور علامات A,B,C,D,E,F ہمیشہ بڑے حروف میں ہوتے ہیں.\n    مثالیں:\n    نم = \"AB\" کے لئے آؤٹ پٹ 1 ہونا چاہئے.\n    نم = \"1077E\" کے لئے آؤٹ پٹ 2 ہونا چاہئے.\n    نم = \"ABED1A33\" کے لئے آؤٹ پٹ 4 ہونا چاہئے.\n    نم = \"123456789ABCDEF0\" کے لئے آؤٹ پٹ 6 ہونا چاہئے.\n    نم = \"2020\" کے لئے آؤٹ پٹ 2 ہونا چاہئے.\n    \"\"\"","canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n","entry_point":"hex_key"}
{"task_id":"HumanEval\/79","prompt":"def decimal_to_binary(decimal):\n    \"\"\"آپ کو دسی نمبر دیا جائے گا اور آپ کا کام اسے بائنری فارمیٹ میں تبدیل کرنا ہے۔ فنکشن کو ایک سٹرنگ واپس کرنی چاہیے، جس میں ہر کردار بائنری نمبر کی نمائندگی کرتا ہے۔ سٹرنگ میں ہر کردار '0' یا '1' ہوگا۔\n\n    سٹرنگ کی شروعات اور آخر میں 'db' کے اضافی جوڑے کے کردار ہوں گے۔ اضافی کردار فارمیٹ کی مدد کے لیے ہیں۔\n\n    مثالیں:\n    decimal_to_binary(15)   # \"db1111db\" واپس کرتا ہے\n    decimal_to_binary(32)   # \"db100000db\" واپس کرتا ہے\n    \"\"\"","canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"decimal_to_binary"}
{"task_id":"HumanEval\/80","prompt":"def is_happy(s):\n    \"\"\"آپ کو ایک سٹرنگ s دی گئی ہے۔\n    آپ کا کام یہ چیک کرنا ہے کہ سٹرنگ خوش ہے یا نہیں۔\n    ایک سٹرنگ خوش ہوتی ہے اگر اس کی لمبائی کم از کم 3 ہو اور ہر 3 متواتر حروف مختلف ہوں\n    مثال کے طور پر:\n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"","canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n","entry_point":"is_happy"}
{"task_id":"HumanEval\/81","prompt":"def numerical_letter_grade(grades):\n    \"\"\"یہ سمسٹر کا آخری ہفتہ ہے اور استاد کو طلباء کو گریڈ دینے ہیں۔\n    استاد نے اپنا گریڈنگ کا الگورتھم بنایا ہوا ہے۔\n    صرف ایک مسئلہ ہے، اس نے گریڈنگ کے لئے استعمال کیا گیا کوڈ کھو دیا ہے۔\n    اس نے آپ کو کچھ طلباء کے GPA کی فہرست دی ہے اور آپ کو ایک فنکشن لکھنا ہے \n    جو مندرجہ ذیل ٹیبل کا استعمال کرتے ہوئے گریڈ کی فہرست کا نتیجہ دے سکتا ہے:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    مثال:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"","canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"numerical_letter_grade"}
{"task_id":"HumanEval\/82","prompt":"def prime_length(string):\n    \"\"\"ایک فنکشن لکھیں جو ایک سٹرنگ لے اور اگر سٹرنگ کی لمبائی ایک اول عدد ہے تو True واپس کرے، بصورت دیگر False\n    مثالیں\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"","canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n","entry_point":"prime_length"}
{"task_id":"HumanEval\/83","prompt":"def starts_one_ends(n):\n    \"\"\"\n    ایک مثبت عدد n دی گئی ہے، ایسے n ہندسوں کی مثبت عداد کی تعداد واپس کریں جو 1 سے شروع یا ختم ہوتی ہیں۔\n    \"\"\"\n","canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"starts_one_ends"}
{"task_id":"HumanEval\/84","prompt":"def solve(N):\n    \"\"\"ایک مثبت عددی صحیح N دی گئی ہے، اس کے ہر ہندسے کا مجموعہ بائنری میں واپس کریں۔\n    \n    مثال\n        اگر N = 1000 ہے، تو ہندسوں کا مجموعہ 1 ہوگا اور آؤٹ پٹ \"1\" ہونا چاہیے۔\n        اگر N = 150 ہے، تو ہندسوں کا مجموعہ 6 ہوگا اور آؤٹ پٹ \"110\" ہونا چاہیے۔\n        اگر N = 147 ہے، تو ہندسوں کا مجموعہ 12 ہوگا اور آؤٹ پٹ \"1100\" ہونا چاہیے۔\n    \n    متغیرات:\n        @N عددی صحیح\n             پابندیاں: 0 ≤ N ≤ 10000.\n    آؤٹ پٹ:\n         ایک بائنری نمبر کی سٹرنگ\n    \"\"\"","canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n","entry_point":"solve"}
{"task_id":"HumanEval\/85","prompt":"def add(lst):\n    \"\"\"ایک غیر خالی فہرست دی گئی ہے جس میں عدد صحیح lst ہیں۔ طاق انڈیکسز پر موجود جفت عناصر کا مجموعہ کریں۔\n\n\n    مثالیں:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"","canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n","entry_point":"add"}
{"task_id":"HumanEval\/86","prompt":"def anti_shuffle(s):\n    \"\"\"\n    ایک فنکشن لکھیں جو ایک سٹرنگ لے کر اس کا ترتیب شدہ ورژن واپس کرے۔\n    سٹرنگ کا ترتیب شدہ ورژن، ایک ایسی سٹرنگ ہے جس میں تمام الفاظ (جو جگہ کی بنیاد پر علیحدہ ہوتے ہیں)\n    ایک نئے لفظ سے تبدیل کر دیے جاتے ہیں جہاں تمام حروف کو\n    ایسکی ویلیو کی بنیاد پر ترتیب دیا گیا ہوتا ہے۔\n    نوٹ: آپ کو جملے میں الفاظ اور خالی جگہوں کے ترتیب کو برقرار رکھنا چاہیے۔\n\n    مثال کے طور پر:\n    anti_shuffle('Hi') 'Hi' واپس کرتا ہے\n    anti_shuffle('hello') 'ehllo' واپس کرتا ہے\n    anti_shuffle('Hello World!!!') 'Hello !!!Wdlor' واپس کرتا ہے\n    \"\"\"","canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"anti_shuffle"}
{"task_id":"HumanEval\/87","prompt":"def get_row(lst, x):\n    \"\"\"\n    آپ کو دو جہتی ڈیٹا دیا گیا ہے، جو کہ نیسٹڈ لسٹس کی شکل میں ہے،\n    جو کہ میٹرکس کے مشابہ ہے، تاہم، میٹرکس کے برعکس،\n    ہر رو میں مختلف تعداد میں کالم ہو سکتے ہیں۔\n    دی گئی lst، اور عددی x کو دیکھتے ہوئے، لسٹ میں عددی x کو تلاش کریں،\n    اور ٹپلز کی لسٹ واپس کریں، [(x1, y1), (x2, y2) ...] ایسے کہ\n    ہر ٹپل ایک کوآرڈینیٹ ہو - (رو، کالم)، 0 سے شروع ہوتا ہے۔\n    کوآرڈینیٹس کو پہلے رو کے لحاظ سے بڑھتے ہوئے ترتیب دیں۔\n    اس کے علاوہ، رو کے کوآرڈینیٹس کو کالم کے لحاظ سے گھٹتے ہوئے ترتیب دیں۔\n    \n    مثالیں:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n","canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"get_row"}
{"task_id":"HumanEval\/88","prompt":"def sort_array(array):\n    \"\"\"\n    ایک غیر منفی عددی قیمتوں کی ایک صف دی گئی ہے، دی گئی صف کی ایک کاپی واپس کریں جسے ترتیب دیا گیا ہو،\n    اگر پہلے انڈیکس کی قیمت اور آخری انڈیکس کی قیمت کا مجموعہ طاق ہو تو دی گئی صف کو اسکینڈنگ آرڈر میں ترتیب دیں،\n    یا اگر مجموعہ جفت ہو تو اسے ڈیسینڈنگ آرڈر میں ترتیب دیں۔\n\n    نوٹ:\n    * دی گئی صف کو تبدیل نہ کریں۔\n\n    مثالیں:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n","canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n","entry_point":"sort_array"}
{"task_id":"HumanEval\/89","prompt":"def encrypt(s):\n    \"\"\"ایک فنکشن بنائیں جو ایک سٹرنگ کو ارگیومنٹ کے طور پر لے اور \n    الفبا کو گھما کر اس سٹرنگ کو خفیہ بنا کر واپس کرے۔\n    الفبا کو اس طرح گھمایا جانا چاہئے کہ حروف دو کی دوگنا جگہوں سے نیچے شفٹ ہو جائیں۔\n    مثال کے طور پر:\n    encrypt('hi') واپس کرتا ہے 'lm'\n    encrypt('asdfghjkl') واپس کرتا ہے 'ewhjklnop'\n    encrypt('gf') واپس کرتا ہے 'kj'\n    encrypt('et') واپس کرتا ہے 'ix'\n    \"\"\"","canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"encrypt"}
{"task_id":"HumanEval\/90","prompt":"def next_smallest(lst):\n    \"\"\"\n    آپ کو ایک فہرست دی گئی ہے جس میں صحیح اعداد ہیں۔\n    ایک فنکشن next_smallest() لکھیں جو فہرست کا دوسرا سب سے چھوٹا عنصر واپس کرتا ہے۔\n    اگر ایسا کوئی عنصر نہیں ہے تو None واپس کریں۔\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"\n","canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"next_smallest"}
{"task_id":"HumanEval\/91","prompt":"def is_bored(S):\n    \"\"\"\n    آپ کو الفاظ کی ایک سٹرنگ دی جائے گی، اور آپ کا کام بوریت کی تعداد کو گننا ہے۔ بوریت ایک جملہ ہے جو \"I\" لفظ سے شروع ہوتا ہے۔\n    جملے '.'، '?' یا '!' سے محدود ہیں۔\n   \n    مثال کے طور پر:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"","canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"is_bored"}
{"task_id":"HumanEval\/92","prompt":"def any_int(x, y, z):\n    '''\n    ایک ایسا فنکشن بنائیں جو 3 نمبر لیتا ہے۔\n    اگر ان میں سے ایک نمبر دوسرے دو نمبروں کے جمع کے برابر ہو اور تمام نمبر صحیح ہوں تو سچ ریٹرن کریں۔\n    دیگر تمام صورتوں میں جھوٹ ریٹرن کریں۔\n    \n    مثالیں\n    any_int(5, 2, 7) ➞ سچ\n    \n    any_int(3, 2, 2) ➞ جھوٹ\n\n    any_int(3, -2, 1) ➞ سچ\n    \n    any_int(3.6, -2.2, 2) ➞ جھوٹ\n  \n\n    \n    '''\n","canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n","entry_point":"any_int"}
{"task_id":"HumanEval\/93","prompt":"def encode(message):\n    \"\"\"\n    ایک ایسا فنکشن لکھیں جو ایک پیغام لے، اور اسے اس طرح سے خفیہ کرے \n    کہ تمام حروف کی کیس کو تبدیل کر دے، اور پیغام میں تمام حروفِ علت کو \n    انگریزی حروفِ تہجی میں اس حرف کے ساتھ بدل دے جو اس حرفِ علت سے \n    دو جگہ آگے آتا ہے۔\n    فرض کریں کہ صرف حروف ہیں۔\n    \n    مثالیں:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n","canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"encode"}
{"task_id":"HumanEval\/94","prompt":"def skjkasdkd(lst):\n    \"\"\"آپ کو ایک انٹیجرز کی فہرست دی گئی ہے۔\n    آپ کو سب سے بڑی اول قیمت تلاش کرنی ہوگی اور اس کے ہندسوں کا مجموعہ واپس کرنا ہوگا۔\n\n    مثال کے طور پر:\n    اگر lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] ہو تو جواب 10 ہونا چاہیے\n    اگر lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] ہو تو جواب 25 ہونا چاہیے\n    اگر lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] ہو تو جواب 13 ہونا چاہیے\n    اگر lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] ہو تو جواب 11 ہونا چاہیے\n    اگر lst = [0,81,12,3,1,21] ہو تو جواب 3 ہونا چاہیے\n    اگر lst = [0,8,1,2,1,7] ہو تو جواب 7 ہونا چاہیے\n    \"\"\"","canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n","entry_point":"skjkasdkd"}
{"task_id":"HumanEval\/95","prompt":"def check_dict_case(dict):\n    \"\"\"\n    ایک ڈکشنری دی گئی ہے، اگر تمام کلیدیں چھوٹے حروف میں ہیں یا تمام کلیدیں بڑے حروف میں ہیں تو True واپس کریں، \n    ورنہ False واپس کریں۔\n    اگر دی گئی ڈکشنری خالی ہے تو فنکشن کو False واپس کرنا چاہیے۔\n    مثالیں:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) کو True واپس کرنا چاہیے۔\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) کو False واپس کرنا چاہیے۔\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) کو False واپس کرنا چاہیے۔\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) کو False واپس کرنا چاہیے۔\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) کو True واپس کرنا چاہیے۔\n    \"\"\"\n","canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n","entry_point":"check_dict_case"}
{"task_id":"HumanEval\/96","prompt":"def count_up_to(n):\n    \"\"\"ایک فنکشن کو نافذ کریں جو ایک غیر منفی عدد لیتا ہے اور پہلے n عددوں کی ایک صف دیتا ہے جو ابتدائی عدد ہیں اور n سے کم ہیں۔\n    مثال کے طور پر:\n    count_up_to(5) => [2,3]\n    count_up_to(11) => [2,3,5,7]\n    count_up_to(0) => []\n    count_up_to(20) => [2,3,5,7,11,13,17,19]\n    count_up_to(1) => []\n    count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n","canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n","test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n","entry_point":"count_up_to"}
{"task_id":"HumanEval\/97","prompt":"def multiply(a, b):\n    \"\"\"دو عدد صحیح کو لے کر ان کے یکائی ہندسوں کا حاصل ضرب واپس کرنے والے فنکشن کو مکمل کریں۔\n    فرض کریں کہ ان پٹ ہمیشہ درست ہے۔\n    مثالیں:\n    multiply(148, 412) کا نتیجہ 16 ہونا چاہیے۔\n    multiply(19, 28) کا نتیجہ 72 ہونا چاہیے۔\n    multiply(2020, 1851) کا نتیجہ 0 ہونا چاہیے۔\n    multiply(14,-15) کا نتیجہ 20 ہونا چاہیے۔\n    \"\"\"","canonical_solution":"    return abs(a % 10) * abs(b % 10)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n","entry_point":"multiply"}
{"task_id":"HumanEval\/98","prompt":"def count_upper(s):\n    \"\"\"\n    ایک سٹرنگ s دی گئی ہے، جفت انڈیکسز پر موجود بڑے حروف کے واولز کی تعداد گنیں۔\n    \n    مثال کے طور پر:\n    count_upper('aBCdEf') واپس کرتا ہے 1\n    count_upper('abcdefg') واپس کرتا ہے 0\n    count_upper('dBBE') واپس کرتا ہے 0\n    \"\"\"","canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"count_upper"}
{"task_id":"HumanEval\/99","prompt":"def closest_integer(value):\n    '''\n    ایک ایسا فنکشن بنائیں جو ایک قیمت (سٹرنگ) لے جو ایک نمبر کی نمائندگی کرتا ہو\n    اور اس کے قریب ترین عدد صحیح کو واپس کرے۔ اگر نمبر دو عدد صحیح کے درمیان برابر فاصلے پر ہو،\n    تو اسے صفر سے دور کرکے گول کریں۔\n\n    مثالیں\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    نوٹ:\n    صفر سے دور گول کرنے کا مطلب ہے کہ اگر دیا گیا نمبر دو عدد صحیح کے درمیان برابر فاصلے پر ہو،\n    تو آپ کو جو عدد صحیح واپس کرنا چاہئے وہ وہ ہونا چاہئے جو صفر سے سب سے زیادہ دور ہو۔\n    مثال کے طور پر closest_integer(\"14.5\") کو 15 واپس کرنا چاہئے اور closest_integer(\"-14.5\") کو -15 واپس کرنا چاہئے۔\n    '''\n","canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n","entry_point":"closest_integer"}
{"task_id":"HumanEval\/100","prompt":"def make_a_pile(n):\n    \"\"\"\n    ایک مثبت عدد صحیح n دی گئی ہے، آپ کو n سطحوں کا ایک ڈھیر بنانا ہے جس میں پتھر ہوں۔\n    پہلی سطح میں n پتھر ہوتے ہیں۔\n    اگلی سطح میں پتھروں کی تعداد یہ ہوتی ہے:\n        - اگر n طاق ہو تو اگلا طاق عدد۔\n        - اگر n جفت ہو تو اگلا جفت عدد۔\n    ہر سطح میں پتھروں کی تعداد کو ایک فہرست میں واپس کریں، جہاں انڈیکس پر عنصر\n    i سطح (i+1) میں پتھروں کی تعداد کو ظاہر کرتا ہے۔\n\n    مثالیں:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"\n","canonical_solution":"    return [n + 2*i for i in range(n)]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"make_a_pile"}
{"task_id":"HumanEval\/101","prompt":"def words_string(s):\n    \"\"\"\n    آپ کو الفاظ کی ایک سٹرنگ دی جائے گی جو کہ کوما یا خالی جگہوں سے جدا ہوتی ہیں۔ آپ کا کام\n    اس سٹرنگ کو الفاظ میں تقسیم کرنا اور الفاظ کی ایک ارے واپس کرنا ہے۔\n    \n    مثال کے طور پر:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n","canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n","entry_point":"words_string"}
{"task_id":"HumanEval\/102","prompt":"def choose_num(x, y):\n    \"\"\"یہ فنکشن دو مثبت نمبرز x اور y لیتا ہے اور واپس کرتا ہے\n    سب سے بڑا جفت عدد جو کہ [x, y] کی حد میں شامل ہے۔ اگر\n    ایسا کوئی نمبر نہیں ہے، تو فنکشن کو -1 واپس کرنا چاہیے۔\n\n    مثال کے طور پر:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"","canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n","entry_point":"choose_num"}
{"task_id":"HumanEval\/103","prompt":"def rounded_avg(n, m):\n    \"\"\"آپ کو دو مثبت عدد n اور m دیے گئے ہیں، اور آپ کا کام n سے m تک کے عددوں کا\n    اوسط نکالنا ہے (n اور m شامل ہیں).\n    جواب کو قریب ترین عدد تک گول کریں اور اسے بائنری میں تبدیل کریں.\n    اگر n m سے بڑا ہو، تو -1 واپس کریں.\n    مثال:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"","canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n","entry_point":"rounded_avg"}
{"task_id":"HumanEval\/104","prompt":"def unique_digits(x):\n    \"\"\"ایک مثبت عددوں کی فہرست x دی گئی ہے۔ ان تمام عناصر کی ایک ترتیب شدہ فہرست واپس کریں جس میں کوئی بھی جفت عدد نہیں ہے۔\n\n    نوٹ: واپس کی گئی فہرست کو بڑھتے ہوئے ترتیب میں ترتیب دیا جانا چاہئے۔\n    \n    مثال کے طور پر:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n","canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"unique_digits"}
{"task_id":"HumanEval\/105","prompt":"def by_length(arr):\n    \"\"\"\n    ایک انٹیجرز کی ارے دی گئی ہے، ان انٹیجرز کو جو 1 سے 9 تک ہیں، ان کو ترتیب دیں،\n    پھر حاصل شدہ ارے کو الٹ دیں، اور پھر ہر ہندسے کو اس کے مطابقت نام سے بدل دیں\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    مثال کے طور پر:\n      arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> arr کو ترتیب دیں -> [1, 1, 2, 2, 3, 4, 5, 8] \n            -> arr کو الٹ دیں -> [8, 5, 4, 3, 2, 2, 1, 1]\n      واپسی [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n    \n      اگر ارے خالی ہو تو خالی ارے واپس کریں:\n      arr = []\n      واپسی []\n    \n      اگر ارے میں کوئی عجیب نمبر ہو تو اسے نظرانداز کریں:\n      arr = [1, -1 , 55] \n            -> arr کو ترتیب دیں -> [-1, 1, 55]\n            -> arr کو الٹ دیں -> [55, 1, -1]\n      واپسی = ['One']\n    \"\"\"","canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n","entry_point":"by_length"}
{"task_id":"HumanEval\/106","prompt":"def f(n):\n    \"\"\" فنکشن f کو ایسے نافذ کریں جو n کو پیرامیٹر کے طور پر لیتا ہے،\n    اور ایک ایسی فہرست واپس کرتا ہے جس کا سائز n ہوتا ہے، ایسے کہ انڈیکس i پر عنصر کی قیمت i کا فیکٹوریل ہو اگر i جفت ہو\n    یا پھر 1 سے i تک کے اعداد کا مجموعہ ہو اگر دوسری صورت میں.\n    i کی شروعات 1 سے ہوتی ہے.\n    i کا فیکٹوریل 1 سے i تک کے اعداد کی ضرب ہوتا ہے (1 * 2 * ... * i).\n    مثال:\n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n","canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n","test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n","entry_point":"f"}
{"task_id":"HumanEval\/107","prompt":"def even_odd_palindrome(n):\n    \"\"\"\n    ایک مثبت عدد صحیح n دی گئی ہے، ایک جوڑا واپس کریں جس میں جفت اور طاق عدد صحیح کے پیلنڈروم کی تعداد ہو جو دائرہ کار (1, n) کے اندر آتے ہیں، شامل ہیں۔\n\n    مثال 1:\n\n        ان پٹ: 3\n        آؤٹ پٹ: (1, 2)\n        وضاحت:\n        عدد صحیح پیلنڈروم 1، 2، 3 ہیں۔ ان میں سے ایک جفت ہے، اور دو طاق ہیں۔\n\n    مثال 2:\n\n        ان پٹ: 12\n        آؤٹ پٹ: (4, 6)\n        وضاحت:\n        عدد صحیح پیلنڈروم 1، 2، 3، 4، 5، 6، 7، 8، 9، 11 ہیں۔ ان میں سے چار جفت ہیں، اور 6 طاق ہیں۔\n\n    نوٹ:\n        1. 1 <= n <= 10^3\n        2. واپس آنے والے جوڑے میں جفت اور طاق عدد صحیح پیلنڈروم کی تعداد بالترتیب ہوتی ہے۔\n    \"\"\"","canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"even_odd_palindrome"}
{"task_id":"HumanEval\/108","prompt":"def count_nums(arr):\n    \"\"\"\n    ایک فنکشن count_nums لکھیں جو ایک انٹیجرز کی اررے لیتا ہے اور ان عناصر کی تعداد واپس کرتا ہے جن کا ہندسوں کا مجموعہ > 0 ہوتا ہے۔\n    اگر کوئی نمبر منفی ہے، تو اس کا پہلا نشان زدہ ہندسہ منفی ہوگا:\n    مثال کے طور پر -123 کے نشان زدہ ہندسے -1، 2، اور 3 ہیں۔\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n","canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"count_nums"}
{"task_id":"HumanEval\/109","prompt":"def move_one_ball(arr):\n    \"\"\"ہمارے پاس N عددی انٹیجرز کی ایک اررے 'arr' ہے جس میں arr[1], arr[2], ..., arr[N] ہیں۔\n    اررے میں نمبرز بے ترتیب ہوں گے۔ آپ کا کام یہ ہے کہ تعین کریں کہ کیا دی گئی اررے پر درج ذیل آپریشن کر کے\n    غیر گھٹتے ہوئے ترتیب میں اررے حاصل کرنا ممکن ہے:\n        آپ کو کسی بھی تعداد میں دائیں شفٹ آپریشن کرنے کی اجازت ہے۔\n    \n    ایک دائیں شفٹ آپریشن کا مطلب ہے کہ اررے کے تمام عناصر کو دائیں سمت میں ایک پوزیشن تک شفٹ کرنا۔\n    اررے کا آخری عنصر اررے کے شروعاتی پوزیشن یعنی 0 ویں انڈیکس پر منتقل ہو جائے گا۔\n\n    اگر دی گئی اررے کو اوپر دیے گئے آپریشن کو انجام دے کر ترتیب میں لانا ممکن ہو تو True ورنہ False واپس کریں۔\n    اگر دی گئی اررے خالی ہو تو True واپس کریں۔\n\n    نوٹ: دی گئی فہرست میں منفرد عناصر ہونے کی ضمانت ہے۔\n\n    مثال کے طور پر:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    وضاحت: 2 دائیں شفٹ آپریشنز کو انجام دے کر، غیر گھٹتے ہوئے ترتیب کو دی گئی اررے کے لیے حاصل کیا جا سکتا ہے۔\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    وضاحت: کسی بھی تعداد میں دائیں شفٹ آپریشنز کو انجام دے کر دی گئی اررے کے لیے غیر گھٹتے ہوئے ترتیب حاصل کرنا ممکن نہیں ہے۔\n                \n    \"\"\"","canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n","entry_point":"move_one_ball"}
{"task_id":"HumanEval\/110","prompt":"def exchange(lst1, lst2):\n    \"\"\"اس مسئلے میں، آپ ایک فنکشن بنائیں گے جو دو فہرستوں کے اعداد لیتا ہے،\n    اور یہ تعین کرتا ہے کہ کیا ان کے درمیان عناصر کا تبادلہ کرنا ممکن ہے\n    تاکہ lst1 کو صرف جفت اعداد کی فہرست بنایا جا سکے۔\n    lst1 اور lst2 کے درمیان تبادلہ کردہ عناصر کی تعداد پر کوئی حد نہیں ہے۔\n    اگر lst1 اور lst2 کے درمیان عناصر کا تبادلہ کرکے\n    lst1 کے تمام عناصر کو جفت بنانا ممکن ہو، تو \"YES\" واپس کریں۔\n    بصورت دیگر، \"NO\" واپس کریں۔\n    مثال کے طور پر:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    یہ مانا جاتا ہے کہ داخل کی گئی فہرستیں خالی نہیں ہوں گی۔\n    \"\"\"","canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n","entry_point":"exchange"}
{"task_id":"HumanEval\/111","prompt":"def histogram(test):\n    \"\"\"ایک سٹرنگ دی گئی ہے جو کہ خالی جگہ سے جدا ہوئے چھوٹے حروف پر مشتمل ہے، ایک لغت واپس کریں\n    جس میں سب سے زیادہ دہرائے گئے حرف کے ساتھ مطابقتی تعداد بھی شامل ہو۔\n    اگر کئی حروف کی تعداد برابر ہو، تو ان سب کو واپس کریں۔\n    \n    مثال:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n\n    \"\"\"","canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n","entry_point":"histogram"}
{"task_id":"HumanEval\/112","prompt":"def reverse_delete(s,c):\n    \"\"\"Task\n    ہمیں دو سٹرنگز s اور c دی گئی ہیں، آپ کو s میں موجود تمام حروف کو حذف کرنا ہے جو c میں موجود کسی بھی حرف کے برابر ہیں\n    پھر چیک کریں کہ نتیجہ سٹرنگ پیلنڈروم ہے یا نہیں۔\n    ایک سٹرنگ کو پیلنڈروم کہا جاتا ہے اگر وہ پیچھے کی طرف پڑھنے میں بھی سامنے کی طرف کی طرح ہی ہو۔\n    آپ کو نتیجہ سٹرنگ اور چیک کے لئے True\/False پر مشتمل ایک ٹپل واپس کرنا چاہئے۔\n    مثال\n    اگر s = \"abcde\", c = \"ae\" ہو، تو نتیجہ ('bcd',False) ہونا چاہئے\n    اگر s = \"abcdef\", c = \"b\" ہو تو نتیجہ ('acdef',False) ہونا چاہئے\n    اگر s = \"abcdedcba\", c = \"ab\" ہو، تو نتیجہ ('cdedc',True) ہونا چاہئے\n    \"\"\"","canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n","test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n","entry_point":"reverse_delete"}
{"task_id":"HumanEval\/113","prompt":"def odd_count(lst):\n    \"\"\"ایک فہرست دی گئی ہے جس میں ہر سٹرنگ صرف ہندسوں پر مشتمل ہوتی ہے، ایک فہرست واپس کریں۔\n    آؤٹ پٹ کا ہر عنصر i \"ان پٹ کے سٹرنگ i میں طاق عناصر کی تعداد\" ہونا چاہئے۔ جہاں تمام i کو ان پٹ کے i ویں سٹرنگ میں طاق ہندسوں کی تعداد سے بدل دیا جانا چاہئے۔\n\n    >>> odd_count(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n","canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"odd_count"}
{"task_id":"HumanEval\/114","prompt":"def minSubArraySum(nums):\n    \"\"\"\n    ایک صحیح اعداد کی اررے nums دی گئی ہے، کسی بھی غیر خالی ذیلی اررے کا کم سے کم مجموعہ تلاش کریں۔\n    مثال\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"","canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n","entry_point":"minSubArraySum"}
{"task_id":"HumanEval\/115","prompt":"def max_fill(grid, capacity):\n    import math\n    \"\"\"\n    آپ کو ایک مستطیل شکل کنووں کا جال دیا گیا ہے۔ ہر قطار ایک کنواں کی نمائندگی کرتی ہے،\n    اور قطار میں ہر 1 ایک یونٹ پانی کی نمائندگی کرتا ہے۔\n    ہر کنواں کے ساتھ ایک بالٹی موجود ہے جس کا استعمال کر کے اس سے پانی نکالا جا سکتا ہے،\n    اور تمام بالٹیوں کی گنجائش ایک جیسی ہے۔\n    آپ کا کام ہے کہ بالٹیوں کا استعمال کر کے کنووں کو خالی کریں۔\n    آپ کو کتنی بار بالٹیوں کو نیچے اتارنے کی ضرورت ہے، اس کی تعداد بتائیں۔\n\n    مثال 1:\n        ان پٹ: \n            گرڈ : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            بالٹی کی گنجائش : 1\n        آؤٹ پٹ: 6\n\n    مثال 2:\n        ان پٹ: \n            گرڈ : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            بالٹی کی گنجائش : 2\n        آؤٹ پٹ: 5\n    \n    مثال 3:\n        ان پٹ: \n            گرڈ : [[0,0,0], [0,0,0]]\n            بالٹی کی گنجائش : 5\n        آؤٹ پٹ: 0\n\n    پابندیاں:\n        * تمام کنویں کی لمبائی ایک جیسی ہے\n        * 1 <= گرڈ کی لمبائی <= 10^2\n        * 1 <= گرڈ[:,1] کی لمبائی <= 10^2\n        * گرڈ[i][j] -> 0 | 1\n        * 1 <= گنجائش <= 10\n    \"\"\"\n","canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n","test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n","entry_point":"max_fill"}
{"task_id":"HumanEval\/116","prompt":"def sort_array(arr):\n    \"\"\"\n    اس کاتا میں، آپ کو غیر منفی عدد کی ایک صف کو ان کی بائنری نمائندگی میں ونز کی تعداد کے مطابق ترتیب دینا ہے،\n    جس کا ترتیب اضافی ہو۔\n    ونز کی ملتی جلتی تعداد کے لئے، دسی قیمت کی بنیاد پر ترتیب دیں۔\n\n    اسے اس طرح نافذ کرنا چاہئے:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n","canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"sort_array"}
{"task_id":"HumanEval\/117","prompt":"def select_words(s, n):\n    \"\"\"ایک سٹرنگ s اور ایک قدرتی عدد n دیا گیا ہے، آپ کو ایک فنکشن بنانے کا کام دیا گیا ہے جو سٹرنگ s میں سے ان تمام الفاظ کی فہرست واپس کرتا ہے جن میں بالکل \n    n حروف صحیح ہوتے ہیں، اس ترتیب میں جس ترتیب میں یہ الفاظ سٹرنگ s میں نظر آتے ہیں۔\n    اگر سٹرنگ s خالی ہے تو فنکشن کو خالی فہرست واپس کرنی چاہیے۔\n    نوٹ: آپ یہ مان سکتے ہیں کہ ان پٹ سٹرنگ میں صرف حروف اور جگہیں ہوتی ہیں۔\n    مثالیں:\n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"","canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n","entry_point":"select_words"}
{"task_id":"HumanEval\/118","prompt":"def get_closest_vowel(word):\n    \"\"\"آپ کو ایک لفظ دیا گیا ہے۔ آپ کا کام یہ ہے کہ لفظ کے دائیں طرف سے دو حروف صحیح کے درمیان کھڑے قریب ترین حرف علت کو تلاش کریں۔\n    \n    شروع اور اختتام میں حروف علت شمار نہیں ہوتے۔ اگر آپ کو کوئی حرف علت نہیں ملا جو اوپر دی گئی شرط کو پورا کرتا ہو تو خالی سٹرنگ واپس کریں۔\n\n    آپ یہ مان کر چل سکتے ہیں کہ دی گئی سٹرنگ میں صرف انگریزی حروف ہیں۔\n\n    مثال:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"","canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"get_closest_vowel"}
{"task_id":"HumanEval\/119","prompt":"def match_parens(lst):\n    '''\n    آپ کو دو سٹرنگز پر مشتمل ایک فہرست دی گئی ہے، دونوں سٹرنگز میں صرف کھلے\n    قوسین '(' یا بند قوسین ')' ہوتے ہیں۔\n    آپ کا کام یہ چیک کرنا ہے کہ کیا دونوں سٹرنگز کو کسی ترتیب میں ملا کر\n    ایک اچھی سٹرنگ بنانا ممکن ہے یا نہیں۔\n    ایک سٹرنگ S کو اچھا سمجھا جاتا ہے اگر اور صرف اگر S میں تمام قوسین متوازن ہوں۔ مثال کے طور پر: سٹرنگ '(())()' اچھی ہے، جبکہ سٹرنگ\n    '())' اچھی نہیں ہے۔\n    اگر اچھی سٹرنگ بنانے کا کوئی طریقہ ہو تو 'Yes' واپس کریں، اور بصورت دیگر 'No' واپس کریں۔\n\n    مثالیں:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n","canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n","entry_point":"match_parens"}
{"task_id":"HumanEval\/120","prompt":"def maximum(arr, k):\n    \"\"\"\n    ایک انٹیجرز کی ارے arr اور ایک مثبت عددی k دی گئی ہے، arr میں سے زیادہ سے زیادہ k نمبروں کی ایک ترتیب شدہ فہرست واپس کریں\n    جس کی لمبائی k ہو۔\n\n    مثال 1:\n\n        داخلہ: arr = [-3, -4, 5], k = 3\n        خارجہ: [-4, -3, 5]\n\n    مثال 2:\n\n        داخلہ: arr = [4, -4, 4], k = 2\n        خارجہ: [4, 4]\n\n    مثال 3:\n\n        داخلہ: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        خارجہ: [2]\n\n    نوٹ:\n        1. ارے کی لمبائی [1, 1000] کی حد میں ہوگی۔\n        2. ارے میں عناصر کی حد [-1000, 1000] ہوگی۔\n        3. 0 <= k <= len(arr)\n    \"\"\"","canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n","entry_point":"maximum"}
{"task_id":"HumanEval\/121","prompt":"def solution(lst):\n    \"\"\"ایک غیر خالی فہرست جس میں صرف عدد ہوں، ان تمام طاق عناصر کا مجموعہ واپس کریں جو جفت پوزیشنوں میں ہوں۔\n    \n\n    مثالیں\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"","canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n","entry_point":"solution"}
{"task_id":"HumanEval\/122","prompt":"def add_elements(arr, k):\n    \"\"\"\n    ایک غیر خالی صحیح عددوں کی فہرست arr اور ایک صحیح عدد k دیا گیا ہے، arr کے پہلے k عناصر میں سے زیادہ سے زیادہ دو ہندسوں والے عناصر کا مجموعہ واپس کریں۔\n\n    مثال:\n\n        ان پٹ: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        آؤٹ پٹ: 24 # 21 + 3 کا مجموعہ\n\n    پابندیاں:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \"\"\"","canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"add_elements"}
{"task_id":"HumanEval\/123","prompt":"def get_odd_collatz(n):\n    \"\"\"\n    ایک مثبت عدد صحیح n دی گئی ہے، ایک ترتیب شدہ فہرست واپس کریں جس میں کولیٹز تسلسل میں طاق عدد ہوں۔\n\n    کولیٹز قیاس ایک ریاضیاتی قیاس ہے جو ایک تسلسل سے متعلق ہے جو اس طرح سے معین کی گئی ہے: کسی بھی مثبت عدد صحیح n سے شروع کریں۔ پھر ہر اصطلاح کو پچھلی اصطلاح سے اس طرح حاصل کیا جاتا ہے: اگر پچھلی اصطلاح جفت ہو، تو اگلی اصطلاح پچھلی اصطلاح کی نصف ہوتی ہے۔ اگر پچھلی اصطلاح طاق ہو، تو اگلی اصطلاح پچھلی اصطلاح کا تین گنا پلس ایک ہوتی ہے۔ قیاس یہ ہے کہ کوئی بھی n کی قیمت کیوں نہ ہو، تسلسل ہمیشہ 1 تک پہنچ جائے گی۔\n\n    نوٹ: \n        1. کولیٹز(1) [1] ہے۔\n        2. واپس کی گئی فہرست ترتیب میں بڑھتی ہوئی ہوتی ہے۔\n\n    مثال کے طور پر:\n    get_odd_collatz(5) [1, 5] واپس کرتا ہے # 5 کے لئے کولیٹز تسلسل [5, 16, 8, 4, 2, 1] ہے، لہذا طاق عدد صرف 1 اور 5 ہیں۔\n    \"\"\"\n","canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"get_odd_collatz"}
{"task_id":"HumanEval\/124","prompt":"def valid_date(date):\n    \"\"\"آپ کو ایک فنکشن لکھنا ہے جو دی گئی تاریخ کی سٹرنگ کو جانچتا ہے اور\n    اگر تاریخ درست ہو تو True ورنہ False واپس کرتا ہے۔\n    تاریخ درست ہے اگر مندرجہ ذیل تمام قواعد پورے ہوں:\n    1. تاریخ کی سٹرنگ خالی نہ ہو۔\n    2. دنوں کی تعداد 1 سے کم یا مہینوں 1,3,5,7,8,10,12 کے لیے 31 دنوں سے زیادہ نہ ہو۔ اور مہینوں 4,6,9,11 کے لیے دنوں کی تعداد 1 سے کم یا 30 دنوں سے زیادہ نہ ہو۔ اور، مہینہ 2 کے لیے دنوں کی تعداد 1 سے کم یا 29 سے زیادہ نہ ہو۔\n    3. مہینے 1 سے کم یا 12 سے زیادہ نہ ہوں۔\n    4. تاریخ کا فارمیٹ یہ ہونا چاہیے: mm-dd-yyyy\n\n    مثال کے طور پر: \n    valid_date('03-11-2000') => True\n\n    valid_date('15-01-2012') => False\n\n    valid_date('04-0-2040') => False\n\n    valid_date('06-04-2020') => True\n\n    valid_date('06\/04\/2020') => False\n    \"\"\"","canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n","entry_point":"valid_date"}
{"task_id":"HumanEval\/125","prompt":"def split_words(txt):\n    '''\n    ایک سٹرنگ جو کہ الفاظ پر مشتمل ہوتی ہے، اسے وائٹ اسپیس پر تقسیم کر کے الفاظ کی فہرست واپس کریں، اگر ٹیکسٹ میں کوئی وائٹ اسپیس موجود نہیں ہے تو\n    آپ کو کوما ',' پر تقسیم کرنا چاہیے، اگر کوئی کوما موجود نہیں ہے تو آپ کو ان چھوٹے حروف کی تعداد واپس کرنی چاہیے جو الفبائی ترتیب میں طاق نمبر پر ہیں، ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    مثالیں\n    split_words(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n","canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n","test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n","entry_point":"split_words"}
{"task_id":"HumanEval\/126","prompt":"def is_sorted(lst):\n    '''\n    دی گئی فہرست میں نمبروں کو دیکھ کر بتائیں کہ آیا وہ ترتیب وار بڑھتے ہوئے ترتیب میں ہیں یا نہیں۔ اگر فہرست میں ایک ہی نمبر کی ایک سے زیادہ نقول ہیں تو، جواب False ہوگا۔ منفی نمبروں اور صرف عدد صحیح کو مان لیں۔\n\n    مثالیں\n    is_sorted([5]) ➞ True\n    is_sorted([1, 2, 3, 4, 5]) ➞ True\n    is_sorted([1, 3, 2, 4, 5]) ➞ False\n    is_sorted([1, 2, 3, 4, 5, 6]) ➞ True\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) ➞ True\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) ➞ False\n    is_sorted([1, 2, 2, 3, 3, 4]) ➞ True\n    is_sorted([1, 2, 2, 2, 3, 4]) ➞ False\n    '''\n","canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n","entry_point":"is_sorted"}
{"task_id":"HumanEval\/127","prompt":"def intersection(interval1, interval2):\n    \"\"\"آپ کو دو وقفے دیے گئے ہیں،\n    جہاں ہر وقفہ ایک جوڑی کا عدد ہے۔ مثال کے طور پر، وقفہ = (شروع، ختم) = (1, 2)۔\n    دیے گئے وقفے بند ہیں جس کا مطلب ہے کہ وقفہ (شروع، ختم)\n    دونوں شروع اور ختم کو شامل کرتا ہے۔\n    ہر دیے گئے وقفے کے لیے، یہ مانا جاتا ہے کہ اس کا شروع اس کے ختم کے برابر یا کم ہے۔\n    آپ کا کام یہ ہے کہ آپ ان دو وقفوں کے تقاطع کی لمبائی کا تعین کریں کہ آیا وہ ایک اول عدد ہے۔\n    مثال کے طور پر، وقفوں (1, 3)، (2, 4) کا تقاطع (2, 3) ہے\n    جس کی لمبائی 1 ہے، جو کہ ایک اول عدد نہیں ہے۔\n    اگر تقاطع کی لمبائی ایک اول عدد ہے، تو \"YES\" واپس کریں،\n    ورنہ، \"NO\" واپس کریں۔\n    اگر دو وقفے تقاطع نہیں کرتے، تو \"NO\" واپس کریں۔\n\n\n    [input\/output] نمونے:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"","canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n","entry_point":"intersection"}
{"task_id":"HumanEval\/128","prompt":"def prod_signs(arr):\n    \"\"\"\n    آپ کو ایک انٹیجرز کی اررے arr دی گئی ہے اور آپ کو انٹیجرز کی مقدار کا مجموعہ واپس کرنے کی ضرورت ہے\n    جو کہ اررے میں ہر نمبر کے علامتوں کی مصنوع سے ضرب کیا گیا ہے، جو کہ 1، -1 یا 0 سے نمائندگی کی جاتی ہے۔\n    نوٹ: اگر arr خالی ہو تو None واپس کریں۔\n\n    مثال:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n","canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"prod_signs"}
{"task_id":"HumanEval\/129","prompt":"def minPath(grid, k):\n    \"\"\"\n    ایک گرڈ دی گئی ہے جس میں N قطاریں اور N کالم ہیں (N >= 2) اور ایک مثبت عدد k، \n    گرڈ کے ہر خانے میں ایک قیمت موجود ہے۔ ہر عدد جو [1, N * N] کی حد میں آتا ہے\n    گرڈ کے خانوں پر بالکل ایک بار ظاہر ہوتا ہے۔\n\n    آپ کو گرڈ میں کم سے کم راستہ کی لمبائی k تلاش کرنی ہے۔ آپ کسی بھی خانے سے شروع کر سکتے ہیں،\n    اور ہر قدم میں آپ کسی بھی پڑوسی خانے میں جا سکتے ہیں،\n    یعنی آپ ان خانوں میں جا سکتے ہیں جو آپ کے موجودہ خانے کے ساتھ کنارہ شریک کرتے ہیں۔\n    براہ کرم نوٹ کریں کہ لمبائی k کا راستہ کا مطلب ہے بالکل k خانوں کا دورہ کرنا (ضروری نہیں کہ مختلف ہو)۔\n    آپ گرڈ سے باہر نہیں جا سکتے۔\n    ایک راستہ A (لمبائی k کا) ایک راستہ B (لمبائی k کا) سے کم سمجھا جاتا ہے اگر\n    ان خانوں پر موجود قیمتوں کی ترتیب شدہ فہرستیں بنانے کے بعد جن سے A اور B گزرتے ہیں (انہیں lst_A اور lst_B کہتے ہیں)، lst_A لغوی طور پر lst_B سے کم ہوتی ہے،\n    یعنی ایک عددی انڈیکس i (1 <= i <= k) ایسا موجود ہے کہ lst_A[i] < lst_B[i] اور کسی بھی j (1 <= j < i) کے لئے ہمارے پاس\n    lst_A[j] = lst_B[j] ہے۔\n    یہ ضمانت دی گئی ہے کہ جواب منفرد ہے۔\n    ان خانوں پر موجود قیمتوں کی ترتیب شدہ فہرست واپس کریں جن سے کم سے کم راستہ گزرتا ہے۔\n\n    مثالیں:\n\n        ان پٹ: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        آؤٹ پٹ: [1, 2, 1]\n\n        ان پٹ: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        آؤٹ پٹ: [1]\n    \"\"\"\n","canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n","test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n","entry_point":"minPath"}
{"task_id":"HumanEval\/130","prompt":"def tri(n):\n    \"\"\"ہر کوئی فیبونیکی تسلسل کو جانتا ہے، اس کا گزشتہ کئی صدیوں میں ریاضی دانوں نے گہرائی سے مطالعہ کیا ہے۔ تاہم، جو لوگ نہیں جانتے وہ ٹریبونیکی تسلسل ہے۔\n    ٹریبونیکی تسلسل کی تعریف مندرجہ ذیل واپسی سے کی گئی ہے:\n    tri(1) = 3\n    tri(n) = 1 + n \/ 2، اگر n جفت ہو۔\n    tri(n) = tri(n - 1) + tri(n - 2) + tri(n + 1)، اگر n طاق ہو۔\n    مثال کے طور پر:\n    tri(2) = 1 + (2 \/ 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    آپ کو ایک غیر منفی عددی نمبر n دیا گیا ہے، آپ کو ٹریبونیکی تسلسل کے پہلے n + 1 نمبروں کی فہرست واپس کرنی ہوگی۔\n    مثالیں:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"","canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n","test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n","entry_point":"tri"}
{"task_id":"HumanEval\/131","prompt":"def digits(n):\n    \"\"\"ایک مثبت عددی صحیح n دی گئی ہے، طاق عددوں کا حاصل ضرب واپس کریں۔\n    اگر تمام عددیں جفت ہوں تو 0 واپس کریں۔\n    مثال کے طور پر:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"","canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n","entry_point":"digits"}
{"task_id":"HumanEval\/132","prompt":"def is_nested(string):\n    '''\n    ایک ایسا فنکشن بنائیں جو صرف مربع قوسین پر مشتمل ایک سٹرنگ کو ان پٹ کے طور پر لے۔\n    فنکشن کو صرف اس صورت میں True واپس کرنا چاہیے جب کم از کم ایک قوس سب سیکوئنس میں نسٹڈ ہو۔\n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n","canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n","entry_point":"is_nested"}
{"task_id":"HumanEval\/133","prompt":"def sum_squares(lst):\n    \"\"\"آپ کو ایک فہرست دی گئی ہے جس میں نمبرز ہیں۔\n    آپ کو دی گئی فہرست میں موجود نمبروں کے مربع کا مجموعہ واپس کرنے کی ضرورت ہے،\n    فہرست میں ہر عنصر کو پہلے اوپر کی طرف پورا عدد (چھت) میں گول کریں۔\n    مثال کے طور پر:\n    lst = [1,2,3] کے لئے نتیجہ 14 ہونا چاہئے\n    lst = [1,4,9] کے لئے نتیجہ 98 ہونا چاہئے\n    lst = [1,3,5,7] کے لئے نتیجہ 84 ہونا چاہئے\n    lst = [1.4,4.2,0] کے لئے نتیجہ 29 ہونا چاہئے\n    lst = [-2.4,1,1] کے لئے نتیجہ 6 ہونا چاہئے\n    \n    \"\"\"","canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"sum_squares"}
{"task_id":"HumanEval\/134","prompt":"def check_if_last_char_is_a_letter(txt):\n    '''\n    ایک ایسا فنکشن بنائیں جو یہ چیک کرے کہ دی گئی سٹرنگ کا آخری کردار\n    ایک حرفی کردار ہے اور کسی لفظ کا حصہ نہیں ہے، اور اگر نہیں تو False واپس کرے۔\n    نوٹ: \"لفظ\" ایک ایسا گروپ ہے جو خلا کے ذریعے الگ کیا گیا ہو۔\n\n    مثالیں:\n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n","canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"check_if_last_char_is_a_letter"}
{"task_id":"HumanEval\/135","prompt":"def can_arrange(arr):\n    \"\"\"ایک ایسا فنکشن بنائیں جو ایک ایسے عنصر کا سب سے بڑا انڈیکس واپس کرے جو اس سے پہلے آنے والے عنصر سے بڑا یا اس کے برابر نہ ہو۔ اگر\n    ایسا کوئی عنصر موجود نہیں ہے تو -1 واپس کریں۔ دی گئی ارے میں ڈپلیکیٹ قدریں شامل نہیں ہوں گی۔\n\n    مثالیں:\n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"","canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n","entry_point":"can_arrange"}
{"task_id":"HumanEval\/136","prompt":"def largest_smallest_integers(lst):\n    '''\n    ایک ایسا فنکشن بنائیں جو ایک ٹپل (a, b) واپس کرے، جہاں 'a' منفی عددوں میں سب سے بڑا ہو،\n    اور 'b' مثبت عددوں میں سب سے چھوٹا ہو۔ اگر کوئی منفی یا مثبت عدد نہیں ہیں، تو انہیں None کے طور پر واپس کریں۔\n\n    مثالیں:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''\n","canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n","entry_point":"largest_smallest_integers"}
{"task_id":"HumanEval\/137","prompt":"def compare_one(a, b):\n    \"\"\"\n    ایک ایسا فنکشن بنائیں جو عدد صحیح، اعشاریہ، یا حقیقی نمبروں کو ظاہر کرنے والی سٹرنگز کو لے کر، دی گئی متغیر کی قسم میں بڑا متغیر واپس کرے۔\n    اگر قیمتیں برابر ہوں تو None واپس کریں۔\n    نوٹ: اگر حقیقی نمبر کو سٹرنگ کے طور پر پیش کیا گیا ہو، تو اعشاریہ نقطہ یا کوما ہو سکتا ہے۔\n\n    compare_one(1, 2.5) ➞ 2.5\n    compare_one(1, \"2,3\") ➞ \"2,3\"\n    compare_one(\"5,1\", \"6\") ➞ \"6\"\n    compare_one(\"1\", 1) ➞ None\n    \"\"\"\n","canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"compare_one"}
{"task_id":"HumanEval\/138","prompt":"def is_equal_to_sum_even(n):\n    \"\"\"یہ جانچیں کہ دی گئی نمبر n بالکل چار مثبت جفت نمبروں کے جمع کے برابر لکھی جا سکتی ہے یا نہیں\n    مثال\n    is_equal_to_sum_even(4) == False\n    is_equal_to_sum_even(6) == False\n    is_equal_to_sum_even(8) == True\n    \"\"\"","canonical_solution":"    return n%2 == 0 and n >= 8\n","test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n","entry_point":"is_equal_to_sum_even"}
{"task_id":"HumanEval\/139","prompt":"def special_factorial(n):\n    \"\"\"برازیلی فیکٹوریل کی تعریف یہ ہے:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    جہاں n > 0\n\n    مثال کے طور پر:\n    >>> special_factorial(4)\n    288\n\n    یہ فنکشن ایک عددی ان پٹ وصول کرے گا اور اس عدد کا خصوصی فیکٹوریل واپس کرے گا۔\n    \"\"\"","canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n","entry_point":"special_factorial"}
{"task_id":"HumanEval\/140","prompt":"def fix_spaces(text):\n    \"\"\"\n    ایک سٹرنگ ٹیکسٹ دی گئی ہے، اس میں تمام خالی جگہوں کو انڈرسکور کے ساتھ بدل دیں،\n    اور اگر ایک سٹرنگ میں 2 سے زیادہ مسلسل خالی جگہیں ہوں،\n    تو تمام مسلسل خالی جگہوں کو - کے ساتھ بدل دیں\n    \n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"\n","canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n","entry_point":"fix_spaces"}
{"task_id":"HumanEval\/141","prompt":"def file_name_check(file_name):\n    \"\"\"ایک فنکشن بنائیں جو فائل کے نام کی نمائندگی کرنے والی ایک سٹرنگ لے، اور اگر فائل کا نام درست ہے تو 'Yes' واپس کرے، اور بصورت دیگر 'No' واپس کرے۔\n    ایک فائل کا نام اس وقت تک درست سمجھا جاتا ہے جب تک کہ مندرجہ ذیل تمام شرائط پوری ہوں:\n    - فائل کے نام میں تین سے زیادہ ہندسے ('0'-'9') نہیں ہونے چاہئیں۔\n    - فائل کے نام میں بالکل ایک نقطہ '.' ہونا چاہئے۔\n    - نقطہ سے پہلے کا سبسٹرنگ خالی نہیں ہونا چاہئے، اور یہ لاطینی حروف تہجی ('a'-'z' اور 'A'-'Z') سے شروع ہونا چاہئے۔\n    - نقطہ کے بعد کا سبسٹرنگ ان میں سے ایک ہونا چاہئے: ['txt', 'exe', 'dll']\n    مثالیں:\n    file_name_check(\"example.txt\") # => 'Yes'\n    file_name_check(\"1example.dll\") # => 'No' (نام لاطینی حروف تہجی کے حرف سے شروع ہونا چاہئے)\n    \"\"\"","canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n","entry_point":"file_name_check"}
{"task_id":"HumanEval\/142","prompt":"def sum_squares(lst):\n    \"\"\"\n    یہ فنکشن ایک فہرست لے گا جس میں صرف عدد ہوں گے۔ فہرست میں موجود تمام اندراجات کے لئے، اگر اندراج کا انڈیکس 3 کا مضرب ہے تو فنکشن اس عدد کو مربع کرے گا، اور اگر اندراج کا انڈیکس 4 کا مضرب ہے لیکن 3 کا مضرب نہیں ہے تو فنکشن اس عدد کو مکعب کرے گا۔ فنکشن ان اندراجات کو تبدیل نہیں کرے گا جن کے انڈیکس 3 یا 4 کے مضرب نہیں ہیں۔ پھر فنکشن تمام اندراجات کا مجموعہ واپس کرے گا۔\n    \n    مثال کے طور پر:\n    اگر lst = [1,2,3] ہو تو اس کا نتیجہ 6 ہونا چاہئے\n    اگر lst = [] ہو تو اس کا نتیجہ 0 ہونا چاہئے\n    اگر lst = [-1,-5,2,-1,-5] ہو تو اس کا نتیجہ -126 ہونا چاہئے\n    \"\"\"","canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n","entry_point":"sum_squares"}
{"task_id":"HumanEval\/143","prompt":"def words_in_sentence(sentence):\n    \"\"\"\n    آپ کو ایک جملے کی نمائندگی کرنے والی ایک سٹرنگ دی گئی ہے،\n    جملے میں کچھ الفاظ ہیں جو ایک خلا کے ذریعے جدا کیے گئے ہیں،\n    اور آپ کو ایک ایسی سٹرنگ واپس کرنی ہوگی جس میں اصل جملے سے الفاظ ہوں،\n    جن کی لمبائیاں اول عداد ہیں،\n    نئی سٹرنگ میں الفاظ کا ترتیب اصل والے جیسا ہی ہونا چاہیے۔\n\n    مثال 1:\n        ان پٹ: sentence = \"This is a test\"\n        آؤٹ پٹ: \"is\"\n\n    مثال 2:\n        ان پٹ: sentence = \"lets go for swimming\"\n        آؤٹ پٹ: \"go for\"\n\n    پابندیاں:\n        * 1 <= len(sentence) <= 100\n        * sentence میں صرف حروف ہوتے ہیں\n    \"\"\"","canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n","entry_point":"words_in_sentence"}
{"task_id":"HumanEval\/144","prompt":"def simplify(x, n):\n    \"\"\"آپ کا کام ایک ایسے فنکشن کو نافذ کرنا ہے جو اظہار\n    x * n کو آسان بنائے۔ اگر x * n کا حساب کتاب ایک مکمل عدد کے طور پر ہو تو فنکشن True واپس کرتا ہے اور\n    بصورت دیگر False۔ x اور n، دونوں کسر کی سٹرنگ نمائندگی ہیں، اور ان کی درج ذیل فارمیٹ ہے،\n    <numerator>\/<denominator> جہاں numerator اور denominator دونوں مثبت مکمل اعداد ہیں۔\n\n    آپ یہ فرض کر سکتے ہیں کہ x، اور n معتبر کسر ہیں، اور ان کے مخرج میں صفر نہیں ہے۔\n\n    simplify(\"1\/5\", \"5\/1\") = True\n    simplify(\"1\/6\", \"2\/1\") = False\n    simplify(\"7\/10\", \"10\/2\") = False\n    \"\"\"","canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n","entry_point":"simplify"}
{"task_id":"HumanEval\/145","prompt":"def order_by_points(nums):\n    \"\"\"\n    ایک ایسا فنکشن لکھیں جو دی گئی فہرست کے عددی اعداد کو ان کے ہندسوں کے مجموعہ کے مطابق ترتیب دے۔\n    نوٹ: اگر کچھ اشیاء کے ہندسوں کا مجموعہ ملتا جلتا ہو، تو انہیں اصل فہرست میں ان کے انڈیکس کی بنیاد پر ترتیب دیں۔\n\n    مثال کے طور پر:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n","canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"order_by_points"}
{"task_id":"HumanEval\/146","prompt":"def specialFilter(nums):\n    \"\"\"ایک فنکشن لکھیں جو نمبروں کی ایک ارے کو ان پٹ کے طور پر لے اور ارے میں ان عناصر کی تعداد واپس کرے \n    جو دس سے زیادہ ہیں اور جن کے نمبر کا پہلا اور آخری ہندسہ طاق ہو (1, 3, 5, 7, 9).\n    مثال کے طور پر:\n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"","canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n","entry_point":"specialFilter"}
{"task_id":"HumanEval\/147","prompt":"def get_max_triples(n):\n    \"\"\"\n    آپ کو ایک مثبت عدد صحیح n دیا گیا ہے۔ آپ کو n لمبائی کا ایک عددی صف a بنانا ہے۔\n        ہر i (1 ≤ i ≤ n) کے لئے، a[i] کی قیمت = i * i - i + 1 ہوگی۔\n        ایسے تینوں (a[i], a[j], a[k]) کی تعداد واپس کریں جہاں i < j < k ہو، \n    اور a[i] + a[j] + a[k] 3 کا مضرب ہو۔\n\n    مثال :\n        ان پٹ: n = 5\n        آؤٹ پٹ: 1\n        وضاحت: \n        a = [1, 3, 7, 13, 21]\n        واحد درست تینوں (1, 7, 13) ہے۔\n    \"\"\"","canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n","test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n","entry_point":"get_max_triples"}
{"task_id":"HumanEval\/148","prompt":"def bf(planet1, planet2):\n    '''\n    ہمارے نظام شمسی میں آٹھ سیارے ہیں: سب سے قریب سورج کے \n    عطارد ہے، اس کے بعد زہرہ، پھر زمین، مریخ، مشتری، زحل، \n    یورینس، نیپچون.\n    ایک فنکشن لکھیں جو دو سیاروں کے نام سٹرنگز کے طور پر planet1 اور planet2 لیتا ہے.\n    فنکشن کو ایک ٹپل واپس کرنا چاہیے جس میں وہ تمام سیارے شامل ہوں جن کے مدار \n    planet1 اور planet2 کے مدار کے درمیان واقع ہیں، سورج کے قربت کے حساب سے ترتیب دیا گیا.\n    اگر planet1 یا planet2 درست سیارے کے نام نہیں ہیں تو فنکشن کو خالی ٹپل واپس کرنا چاہیے.\n    مثالیں\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n","canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n","entry_point":"bf"}
{"task_id":"HumanEval\/149","prompt":"def sorted_list_sum(lst):\n    \"\"\"ایک فنکشن لکھیں جو ایک فہرست کو سٹرنگز کے طور پر پیرامیٹر کے طور پر قبول کرتا ہے،\n    اس سے طاق لمبائی والی سٹرنگز کو حذف کرتا ہے،\n    اور حاصل شدہ فہرست کو ترتیب وار حالت میں واپس کرتا ہے،\n    فہرست ہمیشہ سٹرنگز کی فہرست ہوتی ہے اور کبھی بھی نمبروں کی ارے نہیں ہوتی،\n    اور اس میں نقول بھی شامل ہو سکتے ہیں۔\n    فہرست کا ترتیب ہر لفظ کی لمبائی کے حساب سے بڑھتی ہوئی ہونی چاہیے، اور آپ کو\n    اس قاعدے کے مطابق ترتیب دی ہوئی فہرست واپس کرنی چاہیے۔\n    اگر دو لفظوں کی لمبائی ایک جیسی ہو تو فہرست کو حروف تہجی کے حساب سے ترتیب دیں۔\n    فنکشن کو ترتیب وار حالت میں سٹرنگز کی فہرست واپس کرنی چاہیے۔\n    آپ یہ مان سکتے ہیں کہ تمام الفاظ کی لمبائی ایک جیسی ہوگی۔\n    مثال کے طور پر:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"\n","canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n","entry_point":"sorted_list_sum"}
{"task_id":"HumanEval\/150","prompt":"def x_or_y(n, x, y):\n    \"\"\"ایک سادہ پروگرام جو x کی قیمت واپس کرے اگر n ایک اول عدد ہو \n    اور بصورت دیگر y کی قیمت واپس کرے۔\n\n    مثالیں:\n    x_or_y(7, 34, 12) کے لئے 34 واپس کرے\n    x_or_y(15, 8, 5) کے لئے 5 واپس کرے\n    \n    \"\"\"","canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n","entry_point":"x_or_y"}
{"task_id":"HumanEval\/151","prompt":"def double_the_difference(lst):\n    '''\n    دی گئی ایک فہرست میں نمبروں کے مربع کا مجموعہ واپس کریں\n    جو فہرست میں طاق ہیں۔ منفی یا عدد صحیح نہ ہونے والے نمبروں کو نظرانداز کریں۔\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n    \n    اگر داخلی فہرست خالی ہے، تو 0 واپس کریں۔\n    '''\n","canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n","entry_point":"double_the_difference"}
{"task_id":"HumanEval\/152","prompt":"def compare(game,guess):\n    \"\"\"مجھے لگتا ہے کہ ہم سب کو وہ احساس یاد ہے جب کسی طویل انتظار کے واقعہ کا نتیجہ آخر کار معلوم ہوتا ہے۔ اس لمحے آپ کے جذبات اور خیالات یقینی طور پر قابل غور ہوتے ہیں اور ان کا موازنہ کرنا چاہئے۔\n    آپ کا کام یہ معلوم کرنا ہے کہ کیا کسی شخص نے کچھ میچوں کے نتائج کا صحیح اندازہ لگایا ہے۔\n    آپ کو دو اسکورز اور اندازوں کی برابر لمبائی کی ارریز دی گئی ہیں، جہاں ہر انڈیکس ایک میچ دکھاتا ہے۔ \n    ایک ایسی ارری کا نتیجہ واپس کریں جس کی لمبائی وہی ہو جو یہ بتاتی ہو کہ ہر اندازہ کتنا غلط تھا۔ اگر انہوں نے صحیح اندازہ لگایا ہے،\n    تو قیمت 0 ہے، اور اگر نہیں، تو قیمت اندازہ اور اسکور کے درمیان مطلق فرق ہے۔\n    \n    \n    مثال:\n\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n    \"\"\"","canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"compare"}
{"task_id":"HumanEval\/153","prompt":"def Strongest_Extension(class_name, extensions):\n    \"\"\"آپ کو ایک کلاس کا نام (ایک سٹرنگ) اور ایکسٹینشنز کی فہرست دی جائے گی۔\n    ایکسٹینشنز کا استعمال کلاس میں اضافی کلاسز لوڈ کرنے کے لیے کیا جائے گا۔ ایکسٹینشن کی طاقت مندرجہ ذیل ہے: \n    فرض کریں CAP ایکسٹینشن کے نام میں بڑے حروف کی تعداد ہے، اور SM چھوٹے حروف کی تعداد ہے، \n    طاقت کا حساب CAP - SM کے فرق سے لگایا جاتا ہے۔ آپ کو سب سے زیادہ طاقت والی ایکسٹینشن تلاش کرنی چاہیے \n    اور اس فارمیٹ میں ایک سٹرنگ واپس کرنی چاہیے: ClassName.StrongestExtensionName.\n    اگر دو یا دو سے زیادہ ایکسٹینشنز کی طاقت ایک جیسی ہو تو آپ کو اس میں سے وہ ایک منتخب کرنی چاہیے \n    جو فہرست میں سب سے پہلے آتی ہے۔\n    مثال کے طور پر، اگر آپ کو \"Slices\" کلاس کا نام دیا گیا ہے اور ایکسٹینشنز کی فہرست میں \n    ['SErviNGSliCes', 'Cheese', 'StuFfed'] شامل ہیں تو آپ کو 'Slices.SErviNGSliCes' واپس کرنا چاہیے \n    کیونکہ 'SErviNGSliCes' سب سے زیادہ طاقت والی ایکسٹینشن ہے (اس کی طاقت -1 ہے)۔\n    مثال:\n    Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"","canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n","entry_point":"Strongest_Extension"}
{"task_id":"HumanEval\/154","prompt":"def cycpattern_check(a , b):\n    \"\"\"آپ کو 2 لفظ دیے گئے ہیں۔ آپ کو True واپس کرنا ہوگا اگر دوسرا لفظ یا اس کی کوئی بھی گردش پہلے لفظ میں ذیلی لفظ ہو\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"","canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n","test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n","entry_point":"cycpattern_check"}
{"task_id":"HumanEval\/155","prompt":"def even_odd_count(num):\n    \"\"\"ایک عدد دی گئی ہے۔ ایک ٹپل واپس کریں جس میں بالترتیب جفت اور طاق اعداد کی تعداد ہو۔\n\n     مثال:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"","canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"even_odd_count"}
{"task_id":"HumanEval\/156","prompt":"def int_to_mini_roman(number):\n    \"\"\"\n    ایک مثبت عدد دی گئی ہے، اس کے رومن نمبر کے مساوی کو ایک سٹرنگ کے طور پر حاصل کریں،\n    اور اسے چھوٹے حروف میں واپس کریں۔\n    پابندیاں: 1 <= num <= 1000\n\n    مثالیں:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n","canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"int_to_mini_roman"}
{"task_id":"HumanEval\/157","prompt":"def right_angle_triangle(a, b, c):\n    '''\n    ایک مثلث کے تین اطراف کی لمبائی دی گئی ہے۔ اگر یہ تینوں اطراف ایک قائمہ مثلث بناتے ہیں تو True واپس کریں، بصورت دیگر False واپس کریں۔\n    ایک قائمہ مثلث وہ مثلث ہوتی ہے جس میں ایک زاویہ قائمہ یا 90 درجے کا ہوتا ہے۔\n    مثال:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n","canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n","entry_point":"right_angle_triangle"}
{"task_id":"HumanEval\/158","prompt":"def find_max(words):\n    \"\"\"ایک فنکشن لکھیں جو ایک فہرست کو قبول کرتا ہے جس میں مختلف الفاظ ہوتے ہیں۔\n    فہرست میں مختلف الفاظ شامل ہیں۔ اس لفظ کو واپس کریں جس میں منفرد حروف کی زیادہ سے زیادہ تعداد ہو۔\n    اگر متعدد سٹرنگز میں منفرد حروف کی زیادہ سے زیادہ تعداد ہو، تو وہ واپس کریں جو لغوی ترتیب میں پہلے آتا ہو۔\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"aaaaaaa\"\n    \"\"\"","canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n","entry_point":"find_max"}
{"task_id":"HumanEval\/159","prompt":"def eat(number, need, remaining):\n    \"\"\"\n    آپ ایک بھوکا خرگوش ہیں، اور آپ نے پہلے ہی کچھ گاجریں کھا لی ہیں،\n    لیکن اب آپ کو دن کے کھانے کو مکمل کرنے کے لئے مزید گاجریں کھانے کی ضرورت ہے۔\n    آپ کو ایک اررے واپس کرنا چاہئے جس میں [ آپ کے کھانے کے بعد کھائی گئی گاجریں کی کل تعداد،\n                                    آپ کے کھانے کے بعد باقی بچی گاجریں کی تعداد ]\n    اگر باقی بچی گاجریں کافی نہیں ہیں، تو آپ تمام باقی گاجریں کھا لیں گے، لیکن پھر بھی بھوکے رہیں گے۔\n    \n    مثال:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    متغیرات:\n    @number : عدد صحیح\n        گاجریں جو آپ نے کھا لی ہیں۔\n    @need : عدد صحیح\n        گاجریں جو آپ کو کھانے کی ضرورت ہے۔\n    @remaining : عدد صحیح\n        باقی بچی گاجریں جو اسٹاک میں موجود ہیں۔\n    \n    پابندی:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    مزہ کریں :)\n    \"\"\"","canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n","entry_point":"eat"}
{"task_id":"HumanEval\/160","prompt":"def do_algebra(operator, operand):\n    \"\"\"\n    دو فہرستوں operator اور operand کو دیا گیا ہے۔ پہلی فہرست میں بنیادی جبری عملیات ہیں، اور \n    دوسری فہرست میں عددی اعداد ہیں۔ دی گئی دو فہرستوں کو استعمال کرکے جبری \n    اظہار کو تعمیر کریں اور اس اظہار کی قیمت کا حساب لگا کر واپس کریں۔\n\n    بنیادی جبری عملیات:\n    جمع ( + ) \n    تفریق ( - ) \n    ضرب ( * ) \n    فرش تقسیم ( \/\/ ) \n    توانائی ( ** ) \n\n    مثال:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    نوٹ:\n        operator فہرست کی لمبائی operand فہرست کی لمبائی سے ایک کم ہے۔\n        Operand ایک غیر منفی عددی اعداد کی فہرست ہے۔\n        Operator فہرست میں کم از کم ایک عملیات ہوتا ہے، اور operand فہرست میں کم از کم دو عددی اعداد ہوتے ہیں۔\n\n    \"\"\"","canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"do_algebra"}
{"task_id":"HumanEval\/161","prompt":"def solve(s):\n    \"\"\"آپ کو ایک سٹرنگ s دی گئی ہے۔\n    اگر s[i] ایک حرف ہے، تو اس کی کیس کو لوئر سے اپر یا اس کے برعکس میں تبدیل کر دیں، \n    بصورت دیگر اسے جوں کا توں رہنے دیں۔\n    اگر سٹرنگ میں کوئی حروف نہیں ہیں، تو سٹرنگ کو الٹ دیں۔\n    فنکشن کو نتیجہ خیز سٹرنگ واپس کرنی چاہیے۔\n    مثالیں\n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n","canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n","entry_point":"solve"}
{"task_id":"HumanEval\/162","prompt":"def string_to_md5(text):\n    \"\"\"\n    ایک سٹرنگ 'text' دی گئی ہے، اس کا md5 ہیش مساوی سٹرنگ واپس کریں۔\n    اگر 'text' ایک خالی سٹرنگ ہے، تو None واپس کریں۔\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n","canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"string_to_md5"}
{"task_id":"HumanEval\/163","prompt":"def generate_integers(a, b):\n    \"\"\"\n    دو مثبت عددیں a اور b دی گئی ہیں، a اور b کے درمیان جفت عددوں کو ترتیب وار واپس کریں۔\n\n    مثال کے طور پر:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n","canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"generate_integers"}
