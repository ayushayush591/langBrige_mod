{"task_id":"HumanEval\/0","prompt":"from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Angalia kama katika orodha iliyotolewa ya nambari, kuna nambari yoyote mbili ambazo ziko karibu zaidi na kila mmoja kuliko\n    kizingiti kilichotolewa.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n","canonical_solution":"    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n","entry_point":"has_close_elements"}
{"task_id":"HumanEval\/1","prompt":"from typing import List\n\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Ingizo la kazi hii ni mnyororo unaokuwa na vikundi vingi vya mabano yaliyofungwa ndani ya kila moja. Lengo lako ni\n    kutenganisha vikundi hivyo katika mnyororo tofauti na kurudisha orodha ya hivyo.\n    Vikundi vilivyotenganishwa vina uwiano (kila kibano kilichofunguliwa kimefungwa ipasavyo) na havijafungwa ndani ya kila moja\n    Puuza nafasi zozote katika mnyororo wa ingizo.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n","canonical_solution":"    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [\n        '(()())', '((()))', '()', '((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))') == [\n        '()', '(())', '((()))', '(((())))'\n    ]\n    assert candidate('(()(())((())))') == [\n        '(()(())((())))'\n    ]\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n","entry_point":"separate_paren_groups"}
{"task_id":"HumanEval\/2","prompt":"def truncate_number(number: float) -> float:\n    \"\"\" Kwa kutumia namba nzima yenye pointi inayoelea, inaweza kugawanywa katika\n    sehemu ya integer (integer kubwa zaidi ambayo ni ndogo kuliko namba iliyotolewa) na desimali\n    (sehemu iliyobaki ambayo kila mara ni ndogo kuliko 1).\n\n    Rudisha sehemu ya desimali ya namba.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n","canonical_solution":"    return number % 1.0\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n","entry_point":"truncate_number"}
{"task_id":"HumanEval\/3","prompt":"from typing import List\n\n\ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Unapewa orodha ya shughuli za kuweka na kutoa pesa kwenye akaunti ya benki ambayo inaanza\n    na salio la sifuri. Kazi yako ni kugundua iwapo kuna wakati wowote salio la akaunti linashuka chini ya sifuri, na\n    katika wakati huo kazi inapaswa kurudisha Thibitisha. Vinginevyo inapaswa kurudisha Uongo.\n    >>> below_zero([1, 2, 3])\n    Uongo\n    >>> below_zero([1, 2, -4, 5])\n    Thibitisha\n    \"\"\"\n","canonical_solution":"    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n\n    return False\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == False\n    assert candidate([1, 2, -3, 1, 2, -3]) == False\n    assert candidate([1, 2, -4, 5, 6]) == True\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n","entry_point":"below_zero"}
{"task_id":"HumanEval\/4","prompt":"from typing import List\n\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Kwa orodha iliyotolewa ya namba za kuingiza, hesabu Uondoaji wa Wastani wa Kiasi\n    kuzunguka wastani wa seti hii ya data.\n    Uondoaji wa Wastani wa Kiasi ni wastani wa tofauti ya kiasi kati ya kila\n    elementi na kitovu (wastani katika kesi hii):\n    MAD = wastani | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n","canonical_solution":"    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ len(numbers)\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0]) - 2.0\/3.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0\/5.0) < 1e-6\n\n","entry_point":"mean_absolute_deviation"}
{"task_id":"HumanEval\/5","prompt":"from typing import List\n\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Weka namba 'delimeter' kati ya kila jozi ya vipengele vinavyofuatana katika orodha ya namba `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n","canonical_solution":"    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    result.append(numbers[-1])\n\n    return result\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 7) == []\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\n","entry_point":"intersperse"}
{"task_id":"HumanEval\/6","prompt":"from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Ingizo la kazi hii ni string inayowakilisha makundi mengi ya mabano yaliyotenganishwa kwa nafasi.\n    Kwa kila kundi, toa kiwango cha juu zaidi cha mabano yaliyofungwa ndani.\n    Kwa mfano, (()()) ina viwango viwili vya juu zaidi vya mabano yaliyofungwa ndani wakati ((())) ina vitatu.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n","canonical_solution":"    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                depth -= 1\n\n        return max_depth\n\n    return [parse_paren_group(x) for x in paren_string.split(' ') if x]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n","entry_point":"parse_nested_parens"}
{"task_id":"HumanEval\/7","prompt":"from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Chuja orodha ya ingizo la string kwa zile tu zinazocontain substring iliyotolewa\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n","canonical_solution":"    return [x for x in strings if substring in x]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n","entry_point":"filter_by_substring"}
{"task_id":"HumanEval\/8","prompt":"from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" Kwa orodha iliyotolewa ya namba za integer, rudisha tuple inayojumuisha jumla na bidhaa ya namba zote za integer katika orodha.\n    Jumla tupu inapaswa kuwa sawa na 0 na bidhaa tupu inapaswa kuwa sawa na 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n","canonical_solution":"    sum_value = 0\n    prod_value = 1\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)\n    assert candidate([10]) == (10, 10)\n","entry_point":"sum_product"}
{"task_id":"HumanEval\/9","prompt":"from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" Kutokana na orodha iliyotolewa ya namba za integer, tengeneza orodha ya kipengele cha juu zaidi kinachopatikana hadi wakati uliotolewa\n    katika mfululizo.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n","canonical_solution":"    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(running_max, n)\n\n        result.append(running_max)\n\n    return result\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n","entry_point":"rolling_max"}
{"task_id":"HumanEval\/10","prompt":"def is_palindrome(string: str) -> bool:\n    \"\"\" Pima kama string iliyotolewa ni palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Tafuta palindrome fupi zaidi inayoanza na string iliyotolewa.\n    Wazo la algorithm ni rahisi:\n    - Pata kiambishi kirefu zaidi cha string iliyotolewa ambacho ni palindrome.\n    - Ongeza mwishoni mwa string kinyume cha kiambishi awali kinachokuja kabla ya kiambishi cha palindrome.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"","canonical_solution":"    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(string[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n","entry_point":"make_palindrome"}
{"task_id":"HumanEval\/11","prompt":"from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Ingizo ni string mbili a na b zinazojumuisha 1 na 0 pekee.\n    Fanya XOR ya kibinari kwenye hizi ingizo na urudishe matokeo kama string pia.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n","canonical_solution":"    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    return ''.join(xor(x, y) for x, y in zip(a, b))\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n","entry_point":"string_xor"}
{"task_id":"HumanEval\/12","prompt":"from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Kati ya orodha ya misemo, rudi msemo mrefu zaidi. Rudi wa kwanza ikiwa kuna misemo mingi\n    yenye urefu sawa. Rudi None ikiwa orodha ya maingizo ni tupu.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n","canonical_solution":"    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) == maxlen:\n            return s\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == None\n    assert candidate(['x', 'y', 'z']) == 'x'\n    assert candidate(['x', 'yyy', 'zzzz', 'www', 'kkkk', 'abc']) == 'zzzz'\n","entry_point":"longest"}
{"task_id":"HumanEval\/13","prompt":"\ndef greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Rudi kipengele kikubwa zaidi cha pamoja cha integers mbili a na b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n","canonical_solution":"    while b:\n        a, b = b, a % b\n    return a\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3, 7) == 1\n    assert candidate(10, 15) == 5\n    assert candidate(49, 14) == 7\n    assert candidate(144, 60) == 12\n","entry_point":"greatest_common_divisor"}
{"task_id":"HumanEval\/14","prompt":"from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Rudi orodha ya viambishi vyote kutoka kifupi hadi kirefu zaidi cha stringi iliyoingizwa\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n","canonical_solution":"    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('asdfgh') == ['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh']\n    assert candidate('WWW') == ['W', 'WW', 'WWW']\n","entry_point":"all_prefixes"}
{"task_id":"HumanEval\/15","prompt":"def string_sequence(n: int) -> str:\n    \"\"\" Rudi na mfuatano wa namba zilizotenganishwa kwa nafasi kuanzia 0 hadi n pamoja.\n    >>> string_sequence(0)\n    '0'\n    >>> string_sequence(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n","canonical_solution":"    return ' '.join([str(x) for x in range(n + 1)])\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(0) == '0'\n    assert candidate(3) == '0 1 2 3'\n    assert candidate(10) == '0 1 2 3 4 5 6 7 8 9 10'\n","entry_point":"string_sequence"}
{"task_id":"HumanEval\/16","prompt":"def count_distinct_characters(string: str) -> int:\n    \"\"\" Kwa kutumia string, gundua ina herufi ngapi tofauti (bila kujali herufi kubwa au ndogo)\n    >>> count_distinct_characters('xyzXYZ')\n    3\n    >>> count_distinct_characters('Jerry')\n    4\n    \"\"\"","canonical_solution":"    return len(set(string.lower()))\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('abcde') == 5\n    assert candidate('abcde' + 'cade' + 'CADE') == 5\n    assert candidate('aaaaAAAAaaaa') == 1\n    assert candidate('Jerry jERRY JeRRRY') == 5\n","entry_point":"count_distinct_characters"}
{"task_id":"HumanEval\/17","prompt":"from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Ingizo la kazi hii ni string inayowakilisha noti za muziki katika mfumo maalum wa ASCII.\n    Kazi yako ni kuchanganua string hii na kurudisha orodha ya nambari za integer zinazoendana na idadi ya mapigo ambayo kila\n    noti hudumu.\n\n    Hii hapa ni hadithi:\n    'o' - noti nzima, hudumu mapigo manne\n    'o|' - noti nusu, hudumu mapigo mawili\n    '.|' - robo noti, hudumu pigo moja\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n","canonical_solution":"    note_map = {'o': 4, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == []\n    assert candidate('o o o o') == [4, 4, 4, 4]\n    assert candidate('.| .| .| .|') == [1, 1, 1, 1]\n    assert candidate('o| o| .| .| o o o o') == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('o| .| o| .| o o| o o|') == [2, 1, 2, 1, 4, 2, 4, 2]\n","entry_point":"parse_music"}
{"task_id":"HumanEval\/18","prompt":"def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Pata mara ngapi kipande kidogo cha maneno kinaweza kupatikana ndani ya mfululizo wa maneno wa asili. Hesabu hata kesi zinazoingiliana.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"","canonical_solution":"    times = 0\n\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('', 'x') == 0\n    assert candidate('xyxyxyx', 'x') == 4\n    assert candidate('cacacacac', 'cac') == 4\n    assert candidate('john doe', 'john') == 1\n","entry_point":"how_many_times"}
{"task_id":"HumanEval\/19","prompt":"from typing import List\n\n\ndef sort_numbers(numbers: str) -> str:\n    \"\"\" Ingizo ni string iliyo na nafasi kati ya namba kutoka 'zero' hadi 'nine'.\n    Chaguo halali ni 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' na 'nine'.\n    Rudi na string yenye namba zilizopangwa kutoka ndogo hadi kubwa\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n","canonical_solution":"    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('three') == 'three'\n    assert candidate('three five nine') == 'three five nine'\n    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'\n    assert candidate('six five four three two one zero') == 'zero one two three four five six'\n","entry_point":"sort_numbers"}
{"task_id":"HumanEval\/20","prompt":"from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" Kutoka kwenye orodha iliyotolewa ya namba (yenye urefu wa angalau mbili) chagua na urudishe mbili ambazo ni za karibu zaidi na\n    kila moja na uzirudishe kwa mpangilio (namba ndogo, namba kubwa).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n","canonical_solution":"    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance < distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0)\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0)\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1)\n\n","entry_point":"find_closest_elements"}
{"task_id":"HumanEval\/21","prompt":"from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Kwa kutumia orodha ya namba (yenye angalau vipengele viwili), tumia mabadiliko ya kimsingi kwenye orodha hiyo,\n    kiasi kwamba namba ndogo zaidi itakuwa 0 na kubwa zaidi itakuwa 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n","canonical_solution":"    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number - min_number) for x in numbers]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == [0.0, 1.0]\n    assert candidate([100.0, 49.9]) == [1.0, 0.0]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0]\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75]\n","entry_point":"rescale_to_unit"}
{"task_id":"HumanEval\/22","prompt":"from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Chuja orodha iliyotolewa ya thamani yoyote ya python kwa ajili ya integers pekee\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n","canonical_solution":"    return [x for x in values if isinstance(x, int)]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([4, {}, [], 23.2, 9, 'adasd']) == [4, 9]\n    assert candidate([3, 'c', 3, 3, 'a', 'b']) == [3, 3, 3]\n","entry_point":"filter_integers"}
{"task_id":"HumanEval\/23","prompt":"def strlen(string: str) -> int:\n    \"\"\" Rudi urefu wa string iliyotolewa\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\"","canonical_solution":"    return len(string)\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == 0\n    assert candidate('x') == 1\n    assert candidate('asdasnakj') == 9\n","entry_point":"strlen"}
{"task_id":"HumanEval\/24","prompt":"\ndef largest_divisor(n: int) -> int:\n    \"\"\" Kwa namba iliyotolewa n, pata namba kubwa zaidi ambayo inagawanya n kwa usawa, ikiwa ni ndogo kuliko n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n","canonical_solution":"    for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(3) == 1\n    assert candidate(7) == 1\n    assert candidate(10) == 5\n    assert candidate(100) == 50\n    assert candidate(49) == 7\n","entry_point":"largest_divisor"}
{"task_id":"HumanEval\/25","prompt":"from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Rudi orodha ya vipengele vya msingi vya namba iliyotolewa kuanzia ndogo hadi kubwa zaidi.\n    Kila kipengele kinapaswa kuorodheshwa idadi ya mara inayoendana na mara ngapi kinaonekana katika uchanganuzi.\n    Namba ya kuingiza inapaswa kuwa sawa na bidhaa ya vipengele vyote\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n","canonical_solution":"    import math\n    fact = []\n    i = 2\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate(2) == [2]\n    assert candidate(4) == [2, 2]\n    assert candidate(8) == [2, 2, 2]\n    assert candidate(3 * 19) == [3, 19]\n    assert candidate(3 * 19 * 3 * 19) == [3, 3, 19, 19]\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == [3, 3, 3, 19, 19, 19]\n    assert candidate(3 * 19 * 19 * 19) == [3, 19, 19, 19]\n    assert candidate(3 * 2 * 3) == [2, 3, 3]\n","entry_point":"factorize"}
{"task_id":"HumanEval\/26","prompt":"from typing import List\n\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" Kwenye orodha ya namba za integer, ondoa elementi zote zinazojirudia zaidi ya mara moja.\n    Weka utaratibu wa elementi zilizobaki kama ulivyo kwenye input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n","canonical_solution":"    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] <= 1]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5]\n","entry_point":"remove_duplicates"}
{"task_id":"HumanEval\/27","prompt":"\ndef flip_case(string: str) -> str:\n    \"\"\" Kwa string iliyotolewa, geuza herufi ndogo kuwa kubwa na herufi kubwa kuwa ndogo.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"","canonical_solution":"    return string.swapcase()\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n","entry_point":"flip_case"}
{"task_id":"HumanEval\/28","prompt":"from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Unganisha orodha ya misemo kuwa msemo mmoja\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"","canonical_solution":"    return ''.join(strings)\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([]) == ''\n    assert candidate(['x', 'y', 'z']) == 'xyz'\n    assert candidate(['x', 'y', 'z', 'w', 'k']) == 'xyzwk'\n","entry_point":"concatenate"}
{"task_id":"HumanEval\/29","prompt":"from typing import List\n\n\ndef filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Chuja orodha ya ingizo la string kwa zile tu zinazoanza na kiambishi awali kilichotolewa.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n","canonical_solution":"    return [x for x in strings if x.startswith(prefix)]\n","test":"\n\nMETADATA = {\n    'author': 'jt',\n    'dataset': 'test'\n}\n\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n","entry_point":"filter_by_prefix"}
{"task_id":"HumanEval\/30","prompt":"def get_positive(l: list):\n    \"\"\"Rudisha namba chanya pekee katika orodha.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n","canonical_solution":"    return [e for e in l if e > 0]\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == [4, 5, 6]\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\n    assert candidate([-1, -2]) == []\n    assert candidate([]) == []\n\n","entry_point":"get_positive"}
{"task_id":"HumanEval\/31","prompt":"\ndef is_prime(n):\n    \"\"\"Rudisha kweli ikiwa namba iliyotolewa ni namba ya msingi, na uongo vinginevyo.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"","canonical_solution":"    if n < 2:\n        return False\n    for k in range(2, n - 1):\n        if n % k == 0:\n            return False\n    return True\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(6) == False\n    assert candidate(101) == True\n    assert candidate(11) == True\n    assert candidate(13441) == True\n    assert candidate(61) == True\n    assert candidate(4) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(11) == True\n    assert candidate(17) == True\n    assert candidate(5 * 17) == False\n    assert candidate(11 * 7) == False\n    assert candidate(13441 * 19) == False\n\n","entry_point":"is_prime"}
{"task_id":"HumanEval\/32","prompt":"import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Inakokotoa polynomial yenye viwango xs katika nukta x.\n    inarudisha xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef find_zero(xs: list):\n    \"\"\" xs ni viwango vya polynomial.\n    find_zero inatafuta x ambayo poly(x) = 0.\n    find_zero inarudisha nukta moja tu ya sifuri, hata kama kuna nyingi.\n    Zaidi ya hayo, find_zero inachukua tu orodha xs yenye idadi ya viwango vya usawa\n    na kiwango kikubwa kisicho sifuri kwani inahakikisha\n    suluhisho.\n    >>> round(find_zero([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(find_zero([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"","canonical_solution":"    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) \/ 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 4)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        solution = candidate(copy.deepcopy(coeffs))\n        assert math.fabs(poly(coeffs, solution)) < 1e-4\n\n","entry_point":"find_zero"}
{"task_id":"HumanEval\/33","prompt":"def sort_third(l: list):\n    \"\"\"Kazi ya kazi hii ni kupokea orodha l na kurejesha orodha l' ambapo\n    l' inafanana na l katika viashiria ambavyo havigawanyiki kwa tatu, huku thamani zake katika viashiria ambavyo vinagawanyika kwa tatu zikiwa sawa\n    na thamani za viashiria husika vya l, lakini zikiwa zimepangwa.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"","canonical_solution":"    l = list(l)\n    l[::3] = sorted(l[::3])\n    return l\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple(sort_third([1, 2, 3]))\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple(sort_third([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]))\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple(sort_third([5, 8, -12, 4, 23, 2, 3, 11, 12, -10]))\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2])) == tuple([2, 6, 3, 4, 8, 9, 5])\n    assert tuple(candidate([5, 8, 3, 4, 6, 9, 2])) == tuple([2, 8, 3, 4, 6, 9, 5])\n    assert tuple(candidate([5, 6, 9, 4, 8, 3, 2])) == tuple([2, 6, 9, 4, 8, 3, 5])\n    assert tuple(candidate([5, 6, 3, 4, 8, 9, 2, 1])) == tuple([2, 6, 3, 4, 8, 9, 5, 1])\n\n","entry_point":"sort_third"}
{"task_id":"HumanEval\/34","prompt":"def unique(l: list):\n    \"\"\"Rudisha vipengele vya kipekee vilivyopangwa kwa utaratibu katika orodha\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n","canonical_solution":"    return sorted(list(set(l)))\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n","entry_point":"unique"}
{"task_id":"HumanEval\/35","prompt":"def max_element(l: list):\n    \"\"\"Rudisha elementi kubwa zaidi katika orodha.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"","canonical_solution":"    m = l[0]\n    for e in l:\n        if e > m:\n            m = e\n    return m\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 3]) == 3\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10]) == 124\n","entry_point":"max_element"}
{"task_id":"HumanEval\/36","prompt":"\ndef fizz_buzz(n: int):\n    \"\"\"Rudisha idadi ya mara tarakimu 7 inaonekana katika namba ndogo kuliko n ambazo zinagawanyika kwa 11 au 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n","canonical_solution":"    ns = []\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(50) == 0\n    assert candidate(78) == 2\n    assert candidate(79) == 3\n    assert candidate(100) == 3\n    assert candidate(200) == 6\n    assert candidate(4000) == 192\n    assert candidate(10000) == 639\n    assert candidate(100000) == 8026\n\n","entry_point":"fizz_buzz"}
{"task_id":"HumanEval\/37","prompt":"\ndef sort_even(l: list):\n    \"\"\"Kazi ya kazi hii ni kupokea orodha l na kurejesha orodha l' ambapo\n    l' inafanana na l katika viashiria vya kipekee, huku thamani zake katika viashiria vya shufwa\n    zikiwa sawa na thamani za viashiria vya shufwa vya l, lakini zikiwa zimepangwa.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n","canonical_solution":"    evens = l[::2]\n    odds = l[1::2]\n    evens.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3])) == tuple([1, 2, 3])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])) == tuple([-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123])\n    assert tuple(candidate([5, 8, -12, 4, 23, 2, 3, 11, 12, -10])) == tuple([-12, 8, 3, 4, 5, 2, 12, 11, 23, -10])\n\n","entry_point":"sort_even"}
{"task_id":"HumanEval\/38","prompt":"def encode_cyclic(s: str):\n    \"\"\"\n    inarudisha string iliyosimbwa kwa kuzungusha makundi ya herufi tatu.\n    \"\"\"\n    # gawanya string katika makundi. Kila moja lenye urefu wa herufi 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # zungusha elementi katika kila kundi. Isipokuwa kundi lina herufi chache kuliko 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef decode_cyclic(s: str):\n    \"\"\"\n    inapokea string iliyosimbwa na kazi ya encode_cyclic. Inarudisha string iliyofumbuliwa.\n    \"\"\"\n","canonical_solution":"    return encode_cyclic(encode_cyclic(s))\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_cyclic(str)\n        assert candidate(encoded_str) == str\n\n","entry_point":"decode_cyclic"}
{"task_id":"HumanEval\/39","prompt":"def prime_fib(n: int):\n    \"\"\"\n    prime_fib inarudisha namba ya n-th ambayo ni namba ya Fibonacci na pia ni prime.\n    >>> prime_fib(1)\n    2\n    >>> prime_fib(2)\n    3\n    >>> prime_fib(3)\n    5\n    >>> prime_fib(4)\n    13\n    >>> prime_fib(5)\n    89\n    \"\"\"\n","canonical_solution":"    import math\n\n    def is_prime(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 2\n    assert candidate(2) == 3\n    assert candidate(3) == 5\n    assert candidate(4) == 13\n    assert candidate(5) == 89\n    assert candidate(6) == 233\n    assert candidate(7) == 1597\n    assert candidate(8) == 28657\n    assert candidate(9) == 514229\n    assert candidate(10) == 433494437\n\n","entry_point":"prime_fib"}
{"task_id":"HumanEval\/40","prompt":"def triples_sum_to_zero(l: list):\n    \"\"\"\n    triples_sum_to_zero inachukua orodha ya integers kama input.\n    inarudisha True kama kuna elementi tatu tofauti katika orodha ambazo\n    jumla yake ni sifuri, na False vinginevyo.\n\n    >>> triples_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> triples_sum_to_zero([1, 3, -2, 1])\n    True\n    >>> triples_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n    True\n    >>> triples_sum_to_zero([1])\n    False\n    \"\"\"\n","canonical_solution":"    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, 5, -1]) == False\n    assert candidate([1, 3, -2, 1]) == True\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([1, 2, 5, 7]) == False\n    assert candidate([2, 4, -5, 3, 9, 7]) == True\n    assert candidate([1]) == False\n    assert candidate([1, 3, 5, -100]) == False\n    assert candidate([100, 3, 5, -100]) == False\n\n","entry_point":"triples_sum_to_zero"}
{"task_id":"HumanEval\/41","prompt":"def car_race_collision(n: int):\n    \"\"\"\n    Fikiria barabara ambayo ni mstari mnyoofu usio na mwisho.\n    Magari n yanakwenda kutoka kushoto kwenda kulia; kwa wakati mmoja, seti nyingine ya magari n\n    inakwenda kutoka kulia kwenda kushoto. Seti mbili za magari zinaanza zikiwa mbali sana\n    kutoka kwa kila moja. Magari yote yanatembea kwa kasi sawa. Inasemekana magari mawili yamegongana\n    wakati gari linalokwenda kutoka kushoto kwenda kulia linagonga gari linalokwenda kutoka kulia kwenda kushoto.\n    Hata hivyo, magari ni imara na yenye nguvu kiasi cha kutokuharibika; kwa matokeo, yanaendelea kusonga\n    katika mwelekeo wao kana kwamba hayakugongana.\n\n    Kazi ya hii function ni kutoa idadi ya migongano kama hiyo.\n    \"\"\"","canonical_solution":"    return n**2\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 4\n    assert candidate(3) == 9\n    assert candidate(4) == 16\n    assert candidate(8) == 64\n    assert candidate(10) == 100\n\n","entry_point":"car_race_collision"}
{"task_id":"HumanEval\/42","prompt":"def incr_list(l: list):\n    \"\"\"Rudisha orodha yenye elementi zilizoongezwa kwa moja.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n","canonical_solution":"    return [(e + 1) for e in l]\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, 3, 3, 9, 0, 123]) == [6, 3, 6, 3, 4, 4, 10, 1, 124]\n\n","entry_point":"incr_list"}
{"task_id":"HumanEval\/43","prompt":"\ndef pairs_sum_to_zero(l):\n    \"\"\"\n    pairs_sum_to_zero inachukua orodha ya namba nzima kama input.\n    inarudisha True kama kuna vipengele viwili tofauti kwenye orodha ambavyo\n    vikijumlishwa vinatoa sifuri, na False vinginevyo.\n    >>> pairs_sum_to_zero([1, 3, 5, 0])\n    False\n    >>> pairs_sum_to_zero([1, 3, -2, 1])\n    False\n    >>> pairs_sum_to_zero([1, 2, 3, 7])\n    False\n    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n    True\n    >>> pairs_sum_to_zero([1])\n    False\n    \"\"\"\n","canonical_solution":"    for i, l1 in enumerate(l):\n        for j in range(i + 1, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 3, 5, 0]) == False\n    assert candidate([1, 3, -2, 1]) == False\n    assert candidate([1, 2, 3, 7]) == False\n    assert candidate([2, 4, -5, 3, 5, 7]) == True\n    assert candidate([1]) == False\n\n    assert candidate([-3, 9, -1, 3, 2, 30]) == True\n    assert candidate([-3, 9, -1, 3, 2, 31]) == True\n    assert candidate([-3, 9, -1, 4, 2, 30]) == False\n    assert candidate([-3, 9, -1, 4, 2, 31]) == False\n\n","entry_point":"pairs_sum_to_zero"}
{"task_id":"HumanEval\/44","prompt":"def change_base(x: int, base: int):\n    \"\"\"Badilisha msingi wa namba ya ingizo x kuwa msingi.\n    rudi uwakilishi wa mnyororo baada ya ubadilishaji.\n    namba za msingi ni chini ya 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"","canonical_solution":"    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x \/\/= base\n    return ret\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n\n","entry_point":"change_base"}
{"task_id":"HumanEval\/45","prompt":"\ndef triangle_area(a, h):\n    \"\"\"Kwa urefu wa upande na urefu, rudi eneo la pembetatu.\n    >>> triangle_area(5, 3)\n    7.5\n    \"\"\"\n","canonical_solution":"    return a * h \/ 2.0\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n\n","entry_point":"triangle_area"}
{"task_id":"HumanEval\/46","prompt":"def fib4(n: int):\n    \"\"\"Mfululizo wa namba za Fib4 ni mfululizo unaofanana na mfululizo wa Fibonacci ambao umeelezwa kama ifuatavyo:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Tafadhali andika kazi itakayohesabu kwa ufanisi kipengele cha n-th cha mfululizo wa namba za fib4. Usitumie urejeleo (recursion).\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n    \"\"\"","canonical_solution":"    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-1]\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(5) == 4\n    assert candidate(8) == 28\n    assert candidate(10) == 104\n    assert candidate(12) == 386\n\n","entry_point":"fib4"}
{"task_id":"HumanEval\/47","prompt":"\ndef median(l: list):\n    \"\"\"Rudisha kiwango cha kati cha elementi katika orodha l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n","canonical_solution":"    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) \/\/ 2 - 1] + l[len(l) \/\/ 2]) \/ 2.0\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == 3\n    assert candidate([-10, 4, 6, 1000, 10, 20]) == 8.0\n    assert candidate([5]) == 5\n    assert candidate([6, 5]) == 5.5\n    assert candidate([8, 1, 3, 9, 9, 2, 7]) == 7 \n\n","entry_point":"median"}
{"task_id":"HumanEval\/48","prompt":"\ndef is_palindrome(text: str):\n    \"\"\"\n    Inakagua kama mfululizo wa herufi uliotolewa ni palindrome\n    >>> is_palindrome('')\n    True\n    >>> is_palindrome('aba')\n    True\n    >>> is_palindrome('aaaaa')\n    True\n    >>> is_palindrome('zbcd')\n    False\n    \"\"\"\n","canonical_solution":"    for i in range(len(text)):\n        if text[i] != text[len(text) - 1 - i]:\n            return False\n    return True\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == True\n    assert candidate('aba') == True\n    assert candidate('aaaaa') == True\n    assert candidate('zbcd') == False\n    assert candidate('xywyx') == True\n    assert candidate('xywyz') == False\n    assert candidate('xywzx') == False\n\n","entry_point":"is_palindrome"}
{"task_id":"HumanEval\/49","prompt":"\ndef modp(n: int, p: int):\n    \"\"\"Rudisha 2^n modulo p (zingatia hesabu za kinyumenyume).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n","canonical_solution":"    ret = 1\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(3, 5) == 3\n    assert candidate(1101, 101) == 2\n    assert candidate(0, 101) == 1\n    assert candidate(3, 11) == 8\n    assert candidate(100, 101) == 1\n    assert candidate(30, 5) == 4\n    assert candidate(31, 5) == 3\n\n","entry_point":"modp"}
{"task_id":"HumanEval\/50","prompt":"\ndef encode_shift(s: str):\n    \"\"\"\n    inarudisha string iliyosimbwa kwa kusogeza kila herufi kwa 5 katika alfabeti.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    inapokea string iliyosimbwa kwa kutumia kazi ya encode_shift. Inarudisha string iliyofumbuliwa.\n    \"\"\"\n","canonical_solution":"    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        encoded_str = encode_shift(str)\n        assert candidate(copy.deepcopy(encoded_str)) == str\n\n","entry_point":"decode_shift"}
{"task_id":"HumanEval\/51","prompt":"def remove_vowels(text):\n    \"\"\"\n    remove_vowels ni kazi inayochukua string na kurudisha string bila irabu.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"","canonical_solution":"    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\"]])\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate(\"abcdef\\nghijklm\") == 'bcdf\\nghjklm'\n    assert candidate('fedcba') == 'fdcb'\n    assert candidate('eeeee') == ''\n    assert candidate('acBAA') == 'cB'\n    assert candidate('EcBOO') == 'cB'\n    assert candidate('ybcd') == 'ybcd'\n\n","entry_point":"remove_vowels"}
{"task_id":"HumanEval\/52","prompt":"\ndef below_threshold(l: list, t: int):\n    \"\"\"Rudisha True ikiwa namba zote katika orodha l ziko chini ya kiwango t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n","canonical_solution":"    for e in l:\n        if e >= t:\n            return False\n    return True\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 100)\n    assert not candidate([1, 20, 4, 10], 5)\n    assert candidate([1, 20, 4, 10], 21)\n    assert candidate([1, 20, 4, 10], 22)\n    assert candidate([1, 8, 4, 10], 11)\n    assert not candidate([1, 8, 4, 10], 10)\n\n","entry_point":"below_threshold"}
{"task_id":"HumanEval\/53","prompt":"\ndef add(x: int, y: int):\n    \"\"\"Ongeza nambari mbili x na y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"","canonical_solution":"    return x + y\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1) == 1\n    assert candidate(1, 0) == 1\n    assert candidate(2, 3) == 5\n    assert candidate(5, 7) == 12\n    assert candidate(7, 5) == 12\n\n    for i in range(100):\n        x, y = random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y) == x + y\n\n","entry_point":"add"}
{"task_id":"HumanEval\/54","prompt":"def same_chars(s0: str, s1: str):\n    \"\"\"\n    Angalia kama maneno mawili yana herufi zilezile.\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> same_chars('abcd', 'dddddddabc')\n    True\n    >>> same_chars('dddddddabc', 'abcd')\n    True\n    >>> same_chars('eabcd', 'dddddddabc')\n    False\n    >>> same_chars('abcd', 'dddddddabce')\n    False\n    >>> same_chars('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"","canonical_solution":"    return set(s0) == set(s1)\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddeddabc') == True\n    assert candidate('abcd', 'dddddddabc') == True\n    assert candidate('dddddddabc', 'abcd') == True\n    assert candidate('eabcd', 'dddddddabc') == False\n    assert candidate('abcd', 'dddddddabcf') == False\n    assert candidate('eabcdzzzz', 'dddzzzzzzzddddabc') == False\n    assert candidate('aabb', 'aaccc') == False\n\n","entry_point":"same_chars"}
{"task_id":"HumanEval\/55","prompt":"\ndef fib(n: int):\n    \"\"\"Rudisha namba ya n-th katika mfululizo wa Fibonacci.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"","canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(10) == 55\n    assert candidate(1) == 1\n    assert candidate(8) == 21\n    assert candidate(11) == 89\n    assert candidate(12) == 144\n\n","entry_point":"fib"}
{"task_id":"HumanEval\/56","prompt":"def correct_bracketing(brackets: str):\n    \"\"\" brackets ni string ya \"<\" na \">\".\n    rudi True kama kila bracket ya kufungua ina bracket inayolingana ya kufunga.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n","canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"<\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"<>\")\n    assert candidate(\"<<><>>\")\n    assert candidate(\"<><><<><>><>\")\n    assert candidate(\"<><><<<><><>><>><<><><<>>>\")\n    assert not candidate(\"<<<><>>>>\")\n    assert not candidate(\"><<>\")\n    assert not candidate(\"<\")\n    assert not candidate(\"<<<<\")\n    assert not candidate(\">\")\n    assert not candidate(\"<<>\")\n    assert not candidate(\"<><><<><>><>><<>\")\n    assert not candidate(\"<><><<><>><>>><>\")\n\n","entry_point":"correct_bracketing"}
{"task_id":"HumanEval\/57","prompt":"def monotonic(l: list):\n    \"\"\"Rudisha True kama vipengele vya orodha vinaongezeka au kupungua kwa mtindo wa monotoniki.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n","canonical_solution":"    if l == sorted(l) or l == sorted(l, reverse=True):\n        return True\n    return False\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10]) == True\n    assert candidate([1, 2, 4, 20]) == True\n    assert candidate([1, 20, 4, 10]) == False\n    assert candidate([4, 1, 0, -10]) == True\n    assert candidate([4, 1, 1, 0]) == True\n    assert candidate([1, 2, 3, 2, 5, 60]) == False\n    assert candidate([1, 2, 3, 4, 5, 60]) == True\n    assert candidate([9, 9, 9, 9]) == True\n\n","entry_point":"monotonic"}
{"task_id":"HumanEval\/58","prompt":"def common(l1: list, l2: list):\n    \"\"\"Rudisha elementi za kipekee zilizopangwa ambazo ni za kawaida kwa orodha mbili.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"","canonical_solution":"    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            if e1 == e2:\n                ret.add(e1)\n    return sorted(list(ret))\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4]) == [2, 3, 4]\n    assert candidate([4, 3, 2, 8], []) == []\n\n","entry_point":"common"}
{"task_id":"HumanEval\/59","prompt":"\ndef largest_prime_factor(n: int):\n    \"\"\"Rudisha kipengele kikubwa zaidi cha n ambacho ni namba asilia. Dhania kwamba n > 1 na si namba asilia.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n","canonical_solution":"    def is_prime(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            largest = max(largest, j)\n    return largest\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(15) == 5\n    assert candidate(27) == 3\n    assert candidate(63) == 7\n    assert candidate(330) == 11\n    assert candidate(13195) == 29\n\n","entry_point":"largest_prime_factor"}
{"task_id":"HumanEval\/60","prompt":"def sum_to_n(n: int):\n    \"\"\"sum_to_n ni kazi inayojumlisha namba kutoka 1 hadi n.\n    >>> sum_to_n(30)\n    465\n    >>> sum_to_n(100)\n    5050\n    >>> sum_to_n(5)\n    15\n    >>> sum_to_n(10)\n    55\n    >>> sum_to_n(1)\n    1\n    \"\"\"","canonical_solution":"    return sum(range(n + 1))\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 21\n    assert candidate(11) == 66\n    assert candidate(30) == 465\n    assert candidate(100) == 5050\n\n","entry_point":"sum_to_n"}
{"task_id":"HumanEval\/61","prompt":"def correct_bracketing(brackets: str):\n    \"\"\" brackets ni mnyororo wa \"(\" na \")\".\n    rudi True kama kila kifungo cha kufungua kina kifungo kinacholingana cha kufunga.\n\n    >>> correct_bracketing(\"(\")\n    False\n    >>> correct_bracketing(\"()\")\n    True\n    >>> correct_bracketing(\"(()())\")\n    True\n    >>> correct_bracketing(\")(()\")\n    False\n    \"\"\"\n","canonical_solution":"    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()(()())()\")\n    assert candidate(\"()()((()()())())(()()(()))\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"(\")\n    assert not candidate(\"((((\")\n    assert not candidate(\")\")\n    assert not candidate(\"(()\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n","entry_point":"correct_bracketing"}
{"task_id":"HumanEval\/62","prompt":"def derivative(xs: list):\n    \"\"\" xs inawakilisha viwango vya polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Rudisha derivative ya polynomial hii katika fomu ile ile.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"","canonical_solution":"    return [(i * x) for i, x in enumerate(xs)][1:]\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3]) == [2, 6]\n    assert candidate([3, 2, 1]) == [2, 2]\n    assert candidate([3, 2, 1, 0, 4]) == [2, 2, 0, 16]\n    assert candidate([1]) == []\n\n","entry_point":"derivative"}
{"task_id":"HumanEval\/63","prompt":"def fibfib(n: int):\n    \"\"\"Mfululizo wa namba za FibFib ni mfululizo unaofanana na mfululizo wa Fibbonacci ambao umeelezwa kama ifuatavyo:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Tafadhali andika kazi itakayohesabu kwa ufanisi kipengele cha n-th cha mfululizo wa namba za fibfib.\n    >>> fibfib(1)\n    0\n    >>> fibfib(5)\n    4\n    >>> fibfib(8)\n    24\n    \"\"\"","canonical_solution":"    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    return fibfib(n - 1) + fibfib(n - 2) + fibfib(n - 3)\n","test":"\n\nMETADATA = {}\n\n\ndef check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 24\n    assert candidate(10) == 81\n    assert candidate(12) == 274\n    assert candidate(14) == 927\n\n","entry_point":"fibfib"}
{"task_id":"HumanEval\/64","prompt":"FIX = \"\"\"\nOngeza mifano zaidi ya majaribio.\n\"\"\"\n\ndef vowels_count(s):\n    \"\"\"Andika kazi inaitwa vowels_count ambayo inapokea neno kama string na\n    inarudisha idadi ya irabu katika string hiyo.\n    Irabu katika kesi hii ni 'a', 'e', 'i', 'o', 'u'. Hapa, 'y' pia ni\n    irabu, lakini tu ikiwa iko mwishoni mwa neno lililotolewa.\n\n    Mfano:\n    >>> vowels_count(\"abcde\")\n    2\n    >>> vowels_count(\"ACEDY\")\n    3\n    \"\"\"\n","canonical_solution":"    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        n_vowels += 1\n    return n_vowels\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\") == 2, \"Test 1\"\n    assert candidate(\"Alone\") == 3, \"Test 2\"\n    assert candidate(\"key\") == 2, \"Test 3\"\n    assert candidate(\"bye\") == 1, \"Test 4\"\n    assert candidate(\"keY\") == 2, \"Test 5\"\n    assert candidate(\"bYe\") == 1, \"Test 6\"\n    assert candidate(\"ACEDY\") == 3, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"vowels_count"}
{"task_id":"HumanEval\/65","prompt":"def circular_shift(x, shift):\n    \"\"\"Fanya usogezaji wa duara wa tarakimu za namba x, sogeza tarakimu kuelekea kulia kwa shift\n    na urudishe matokeo kama string.\n    Ikiwa shift > idadi ya tarakimu, rudisha tarakimu zikiwa zimegeuzwa.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"","canonical_solution":"    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[len(s) - shift:] + s[:len(s) - shift]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(100, 2) == \"001\"\n    assert candidate(12, 2) == \"12\"\n    assert candidate(97, 8) == \"79\"\n    assert candidate(12, 1) == \"21\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(11, 101) == \"11\", \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"circular_shift"}
{"task_id":"HumanEval\/66","prompt":"def digitSum(s):\n    \"\"\"Kazi\n    Andika kazi inayochukua string kama ingizo na inarudisha jumla ya misimbo ya ASCII ya herufi kubwa pekee.\n\n    Mifano:\n        digitSum(\"\") => 0\n        digitSum(\"abAB\") => 131\n        digitSum(\"abcCd\") => 67\n        digitSum(\"helloE\") => 69\n        digitSum(\"woArBld\") => 131\n        digitSum(\"aAaaaXa\") => 153\n    \"\"\"","canonical_solution":"    if s == \"\": return 0\n    return sum(ord(char) if char.isupper() else 0 for char in s)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\") == 0, \"Error\"\n    assert candidate(\"abAB\") == 131, \"Error\"\n    assert candidate(\"abcCd\") == 67, \"Error\"\n    assert candidate(\"helloE\") == 69, \"Error\"\n    assert candidate(\"woArBld\") == 131, \"Error\"\n    assert candidate(\"aAaaaXa\") == 153, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\") == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\") == 327, \"Error\"\n\n","entry_point":"digitSum"}
{"task_id":"HumanEval\/67","prompt":"def fruit_distribution(s,n):\n    \"\"\"\n    Katika kazi hii, utapewa string inayoonyesha idadi ya maapulo na machungwa \n    yaliyogawanywa katika kapu la matunda ambalo lina \n    maapulo, machungwa, na matunda ya maembe. Ukizingatia string inayoonyesha jumla ya idadi ya \n    machungwa na maapulo na integer inayoonyesha jumla ya idadi ya matunda \n    katika kapu rudi idadi ya matunda ya maembe yaliyopo kwenye kapu.\n    kwa mfano:\n    fruit_distribution(\"5 apples and 6 oranges\", 19) -> 19 - 5 - 6 = 8\n    fruit_distribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n    fruit_distribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n    fruit_distribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n    \"\"\"\n","canonical_solution":"    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"5 apples and 6 oranges\",19) == 8\n    assert candidate(\"5 apples and 6 oranges\",21) == 10\n    assert candidate(\"0 apples and 1 oranges\",3) == 2\n    assert candidate(\"1 apples and 0 oranges\",3) == 2\n    assert candidate(\"2 apples and 3 oranges\",100) == 95\n    assert candidate(\"2 apples and 3 oranges\",5) == 0\n    assert candidate(\"1 apples and 100 oranges\",120) == 19\n","entry_point":"fruit_distribution"}
{"task_id":"HumanEval\/68","prompt":"def pluck(arr):\n    \"\"\"\n    \"Ukipewa safu inayowakilisha tawi la mti ambalo lina node zenye thamani isiyo hasi\n    kazi yako ni kung'oa moja ya node hizo na kuirudisha.\n    Node iliyong'olewa inapaswa kuwa node yenye thamani ndogo zaidi ya shufwa.\n    Ikiwa kuna node nyingi zenye thamani ndogo sawa ya shufwa, rudisha node yenye index ndogo zaidi.\n\n    Node iliyong'olewa inapaswa kurudishwa kwenye orodha, [ thamani_ndogo, index_yake ],\n    Ikiwa hakuna thamani za shufwa au safu iliyotolewa ni tupu, rudisha [].\n\n    Mfano wa 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Maelezo: 2 ina thamani ndogo zaidi ya shufwa, na 2 ina index ndogo zaidi.\n\n    Mfano wa 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Maelezo: 2 ina thamani ndogo zaidi ya shufwa, na 2 ina index ndogo zaidi.\n\n    Mfano wa 3:\n        Input: []\n        Output: []\n    \n    Mfano wa 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Maelezo: 0 ni thamani ndogo zaidi, lakini kuna sifuri mbili,\n                 hivyo tutachagua sifuri ya kwanza, ambayo ina index ndogo zaidi.\n\n    Vizuizi:\n        * 1 <= urefu wa nodes <= 10000\n        * 0 <= thamani ya node\n    \"\"\"\n","canonical_solution":"    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [min(evens), arr.index(min(evens))]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3]) == [2, 1], \"Error\"\n    assert candidate([1,2,3]) == [2, 1], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2]) == [0, 1], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3]) == [0, 3], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8]) == [4, 1], \"Error\"\n    assert candidate([7, 6, 7, 1]) == [6, 1], \"Error\"\n    assert candidate([7, 9, 7, 1]) == [], \"Error\"\n\n","entry_point":"pluck"}
{"task_id":"HumanEval\/69","prompt":"def search(lst):\n    '''\n    Umepewa orodha isiyo tupu ya namba nzima chanya. Rudi namba kubwa zaidi ambayo ni kubwa kuliko \n    sifuri, na ina marudio mengi zaidi au sawa na thamani ya namba yenyewe.\n    Marudio ya namba ni idadi ya mara inaonekana katika orodha.\n    Ikiwa hakuna thamani kama hiyo, rudi -1.\n    Mifano:\n        search([4, 1, 2, 2, 3, 1]) == 2\n        search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        search([5, 5, 4, 4, 4]) == -1\n    '''","canonical_solution":"    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = -1\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n","test":"def check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1]) == 1\n    assert candidate([4, 1, 4, 1, 4, 4]) == 4\n    assert candidate([3, 3]) == -1\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8]) == 8\n    assert candidate([2, 3, 3, 2, 2]) == 2\n\n    # automatically generated tests\n    assert candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]) == 1\n    assert candidate([3, 2, 8, 2]) == 2\n    assert candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]) == 1\n    assert candidate([8, 8, 3, 6, 5, 6, 4]) == -1\n    assert candidate([6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]) == 1\n    assert candidate([1, 9, 10, 1, 3]) == 1\n    assert candidate([6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]) == 5\n    assert candidate([1]) == 1\n    assert candidate([8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]) == 4\n    assert candidate([2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]) == 2\n    assert candidate([1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]) == 1\n    assert candidate([9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4]) == 4\n    assert candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]) == 4\n    assert candidate([9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]) == 2\n    assert candidate([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]) == -1\n    assert candidate([10]) == -1\n    assert candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]) == 2\n    assert candidate([5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]) == 1\n    assert candidate([7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]) == 1\n    assert candidate([3, 10, 10, 9, 2]) == -1\n\n","entry_point":"search"}
{"task_id":"HumanEval\/70","prompt":"def strange_sort_list(lst):\n    '''\n    Ukipewa orodha ya nambari za integer, rudisha orodha hiyo kwa mpangilio wa ajabu.\n    Mpangilio wa ajabu, ni pale unapoanza na thamani ndogo zaidi,\n    kisha thamani kubwa zaidi kutoka kwa integer zilizobaki, kisha ndogo zaidi na kuendelea hivyo.\n\n    Mifano:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([]) == []\n    '''\n","canonical_solution":"    res, switch = [], True\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 9, 6, 8, 7]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3]\n    assert candidate([5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7]\n    assert candidate([5, 5, 5, 5]) == [5, 5, 5, 5]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 8, 2, 7, 3, 6, 4, 5]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [-5, 5, -5, 5, 0, 2, 2, 2]\n    assert candidate([111111]) == [111111]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"strange_sort_list"}
{"task_id":"HumanEval\/71","prompt":"def triangle_area(a, b, c):\n    '''\n    Ukipewa urefu wa pande tatu za pembetatu. Rudisha eneo la pembetatu \n    likiwa limezungushwa hadi nafasi mbili za desimali ikiwa pande tatu \n    zinaunda pembetatu halali. Vinginevyo rudisha -1\n    Pande tatu zinaunda pembetatu halali ikiwa jumla ya pande zozote mbili \n    ni kubwa kuliko upande wa tatu.\n    Mfano:\n    triangle_area(3, 4, 5) == 6.00\n    triangle_area(1, 2, 10) == -1\n    '''\n","canonical_solution":"    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)\/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == 6.00, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 10) == -1\n    assert candidate(4, 8, 5) == 8.18\n    assert candidate(2, 2, 2) == 1.73\n    assert candidate(1, 2, 3) == -1\n    assert candidate(10, 5, 7) == 16.25\n    assert candidate(2, 6, 3) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == 0.43, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == -1\n\n","entry_point":"triangle_area"}
{"task_id":"HumanEval\/72","prompt":"def will_it_fly(q,w):\n    '''\n    Andika kazi inayorudisha True ikiwa kitu q kitapaa, na False vinginevyo.\n    Kitu q kitapaa ikiwa kimepangwa sawa (ni orodha ya palindromic) na jumla ya vipengele vyake ni ndogo au sawa na uzito wa juu zaidi w.\n\n    Mfano:\n    will_it_fly([1, 2], 5) ➞ False \n    # 1+2 ni ndogo kuliko uzito wa juu zaidi unaowezekana, lakini haikupangwa sawa.\n\n    will_it_fly([3, 2, 3], 1) ➞ False\n    # imepangwa sawa, lakini 3+2+3 ni zaidi ya uzito wa juu zaidi unaowezekana.\n\n    will_it_fly([3, 2, 3], 9) ➞ True\n    # 3+2+3 ni ndogo kuliko uzito wa juu zaidi unaowezekana, na imepangwa sawa.\n\n    will_it_fly([3], 5) ➞ True\n    # 3 ni ndogo kuliko uzito wa juu zaidi unaowezekana, na imepangwa sawa.\n    '''\n","canonical_solution":"    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9) is True\n    assert candidate([1, 2], 5) is False\n    assert candidate([3], 5) is True\n    assert candidate([3, 2, 3], 1) is False\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6) is False\n    assert candidate([5], 5) is True\n\n","entry_point":"will_it_fly"}
{"task_id":"HumanEval\/73","prompt":"def smallest_change(arr):\n    \"\"\"\n    Kwa kutumia orodha arr ya nambari za integer, pata idadi ndogo zaidi ya elementi\n    ambazo zinahitaji kubadilishwa ili kufanya orodha hiyo kuwa palindromu. Orodha ya palindromu ni orodha ambayo\n    inasomwa vilevile kutoka nyuma kuelekea mbele. Katika mabadiliko moja, unaweza kubadilisha elementi moja kuwa elementi nyingine yoyote.\n\n    Kwa mfano:\n    smallest_change([1,2,3,5,4,7,9,6]) == 4\n    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1\n    smallest_change([1, 2, 3, 2, 1]) == 0\n    \"\"\"","canonical_solution":"    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6]) == 4\n    assert candidate([1, 2, 3, 4, 3, 2, 2]) == 1\n    assert candidate([1, 4, 2]) == 1\n    assert candidate([1, 4, 4, 2]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1]) == 0\n    assert candidate([3, 1, 1, 3]) == 0\n    assert candidate([1]) == 0\n    assert candidate([0, 1]) == 1\n\n","entry_point":"smallest_change"}
{"task_id":"HumanEval\/74","prompt":"def total_match(lst1, lst2):\n    '''\n    Andika kazi inayokubali orodha mbili za misemo na inarudisha orodha ambayo ina \n    idadi ya jumla ya herufi katika misemo yote ya orodha kuwa chini kuliko orodha nyingine.\n\n    ikiwa orodha mbili zina idadi sawa ya herufi, rudisha orodha ya kwanza.\n\n    Mifano\n    total_match([], []) ➞ []\n    total_match(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n    total_match(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n    total_match(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n    total_match(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n    '''\n","canonical_solution":"    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst1\n    else:\n        return lst2\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], []) == []\n    assert candidate(['hi', 'admin'], ['hi', 'hi']) == ['hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5']) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi']) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hi']) == ['hI', 'hi', 'hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii']) == ['hi', 'admin']\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this']) == []\n    assert candidate(['this'], []) == []\n\n","entry_point":"total_match"}
{"task_id":"HumanEval\/75","prompt":"def is_multiply_prime(a):\n    \"\"\"Andika kazi inayorudisha kweli ikiwa namba iliyotolewa ni matokeo ya kuzidisha namba tatu za msingi\n    na uongo vinginevyo.\n    Ikitambulika kwamba (a) ni chini ya 100.\n    Mfano:\n    is_multiply_prime(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"","canonical_solution":"    def is_prime(n):\n        for j in range(2,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not is_prime(i): continue\n        for j in range(2,101):\n            if not is_prime(j): continue\n            for k in range(2,101):\n                if not is_prime(k): continue\n                if i*j*k == a: return True\n    return False\n","test":"def check(candidate):\n\n    assert candidate(5) == False\n    assert candidate(30) == True\n    assert candidate(8) == True\n    assert candidate(10) == False\n    assert candidate(125) == True\n    assert candidate(3 * 5 * 7) == True\n    assert candidate(3 * 6 * 7) == False\n    assert candidate(9 * 9 * 9) == False\n    assert candidate(11 * 9 * 9) == False\n    assert candidate(11 * 13 * 7) == True\n\n","entry_point":"is_multiply_prime"}
{"task_id":"HumanEval\/76","prompt":"def is_simple_power(x, n):\n    \"\"\"Kazi yako ni kuandika kazi inayorudisha kweli ikiwa namba x ni nguvu rahisi\n    ya n na uongo katika hali nyingine.\n    x ni nguvu rahisi ya n ikiwa n**int=x\n    Kwa mfano:\n    is_simple_power(1, 4) => kweli\n    is_simple_power(2, 2) => kweli\n    is_simple_power(8, 2) => kweli\n    is_simple_power(3, 2) => uongo\n    is_simple_power(3, 1) => uongo\n    is_simple_power(5, 3) => uongo\n    \"\"\"","canonical_solution":"    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (power < x): \n        power = power * n \n    return (power == x) \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(143214, 16)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(4, 2)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(9, 3)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(24, 2)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(128, 4)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)==False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(1, 12)==True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"is_simple_power"}
{"task_id":"HumanEval\/77","prompt":"def iscube(a):\n    '''\n    Andika kazi inayochukua namba nzima a na inarudisha True \n    ikiwa namba hii nzima ni kiwango cha tatu cha namba nyingine nzima.\n    Maelezo: unaweza kudhania kwamba ingizo ni sahihi daima.\n    Mifano:\n    iscube(1) ==> True\n    iscube(2) ==> False\n    iscube(-1) ==> True\n    iscube(64) ==> True\n    iscube(0) ==> True\n    iscube(180) ==> False\n    '''\n","canonical_solution":"    a = abs(a)\n    return int(round(a ** (1. \/ 3))) ** 3 == a\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(2) == False, \"Second test error: \" + str(candidate(2))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(64) == True, \"Fourth test error: \" + str(candidate(64))\n    assert candidate(180) == False, \"Fifth test error: \" + str(candidate(180))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1729) == False, \"2nd edge test error: \" + str(candidate(1728))\n\n","entry_point":"iscube"}
{"task_id":"HumanEval\/78","prompt":"def hex_key(num):\n    \"\"\"Umeombwa kuandika kazi inayopokea \n    namba ya hexadecimal kama string na kuhesabu idadi ya tarakimu za hexadecimal \n    ambazo ni primes (namba ya prime, au prime, ni namba asilia \n    kubwa kuliko 1 ambayo si bidhaa ya namba mbili ndogo za asili).\n    Tarakimu za hexadecimal ni 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Namba za prime ni 2, 3, 5, 7, 11, 13, 17,...\n    Hivyo unatakiwa kubaini idadi ya tarakimu zifuatazo: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Kumbuka: unaweza kudhani kuwa ingizo ni sahihi daima au string tupu, \n    na alama A,B,C,D,E,F ziko kwenye herufi kubwa daima.\n    Mifano:\n    Kwa num = \"AB\" matokeo yanapaswa kuwa 1.\n    Kwa num = \"1077E\" matokeo yanapaswa kuwa 2.\n    Kwa num = \"ABED1A33\" matokeo yanapaswa kuwa 4.\n    Kwa num = \"123456789ABCDEF0\" matokeo yanapaswa kuwa 6.\n    Kwa num = \"2020\" matokeo yanapaswa kuwa 2.\n    \"\"\"","canonical_solution":"    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 0\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AB\") == 1, \"First test error: \" + str(candidate(\"AB\"))      \n    assert candidate(\"1077E\") == 2, \"Second test error: \" + str(candidate(\"1077E\"))  \n    assert candidate(\"ABED1A33\") == 4, \"Third test error: \" + str(candidate(\"ABED1A33\"))      \n    assert candidate(\"2020\") == 2, \"Fourth test error: \" + str(candidate(\"2020\"))  \n    assert candidate(\"123456789ABCDEF0\") == 6, \"Fifth test error: \" + str(candidate(\"123456789ABCDEF0\"))      \n    assert candidate(\"112233445566778899AABBCCDDEEFF00\") == 12, \"Sixth test error: \" + str(candidate(\"112233445566778899AABBCCDDEEFF00\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == 0\n\n","entry_point":"hex_key"}
{"task_id":"HumanEval\/79","prompt":"def decimal_to_binary(decimal):\n    \"\"\"Utapewa namba katika mfumo wa desimali na jukumu lako ni kuipeleka katika\n    mfumo wa binary. Kazi hiyo inapaswa kurejesha string, ambapo kila herufi inawakilisha namba ya\n    binary. Kila herufi katika string itakuwa '0' au '1'.\n\n    Kutakuwa na herufi za ziada 'db' mwanzoni na mwishoni mwa string.\n    Herufi za ziada zipo ili kusaidia na muundo.\n\n    Mifano:\n    decimal_to_binary(15)   # inarudisha \"db1111db\"\n    decimal_to_binary(32)   # inarudisha \"db100000db\"\n    \"\"\"","canonical_solution":"    return \"db\" + bin(decimal)[2:] + \"db\"\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == \"db0db\"\n    assert candidate(32) == \"db100000db\"\n    assert candidate(103) == \"db1100111db\"\n    assert candidate(15) == \"db1111db\", \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"decimal_to_binary"}
{"task_id":"HumanEval\/80","prompt":"def is_happy(s):\n    \"\"\"Umepeanwa string s.\n    Kazi yako ni kukagua kama string ni ya furaha au la.\n    String ni ya furaha ikiwa urefu wake ni angalau 3 na kila herufi 3 mfululizo ni tofauti\n    Kwa mfano:\n    is_happy(a) => False\n    is_happy(aa) => False\n    is_happy(abcd) => True\n    is_happy(aabb) => False\n    is_happy(adb) => True\n    is_happy(xyy) => False\n    \"\"\"","canonical_solution":"    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] or s[i+1] == s[i+2] or s[i] == s[i+2]:\n        return False\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == True , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == True , \"adb\"\n    assert candidate(\"xyy\") == False , \"xyy\"\n    assert candidate(\"iopaxpoi\") == True , \"iopaxpoi\"\n    assert candidate(\"iopaxioi\") == False , \"iopaxioi\"\n","entry_point":"is_happy"}
{"task_id":"HumanEval\/81","prompt":"def numerical_letter_grade(grades):\n    \"\"\"Ni wiki ya mwisho ya muhula na mwalimu anahitaji kutoa alama kwa wanafunzi.\n    Mwalimu amekuwa akitengeneza algorithm yake mwenyewe ya kupanga alama.\n    Tatizo pekee ni kwamba, amepoteza kodi aliyokuwa akitumia kupanga alama.\n    Amekupa orodha ya GPA za baadhi ya wanafunzi na unahitaji kuandika\n    kazi ambayo inaweza kutoa orodha ya alama za barua kwa kutumia jedwali lifuatalo:\n             GPA       |    Alama ya barua\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Mfano:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"","canonical_solution":"\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    return letter_grade\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == ['A+', 'B', 'C-', 'C', 'A-']\n    assert candidate([1.2]) == ['D+']\n    assert candidate([0.5]) == ['D-']\n    assert candidate([0.0]) == ['E']\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == ['D', 'D-', 'C-', 'B', 'B+']\n    assert candidate([0, 0.7]) == ['E', 'D-']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"numerical_letter_grade"}
{"task_id":"HumanEval\/82","prompt":"def prime_length(string):\n    \"\"\"Andika kazi inayochukua string na inarudisha True ikiwa urefu wa string\n    ni namba ya msingi au False vinginevyo\n    Mifano\n    prime_length('Hello') == True\n    prime_length('abcdcba') == True\n    prime_length('kittens') == True\n    prime_length('orange') == False\n    \"\"\"\n","canonical_solution":"    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(2, l):\n        if l % i == 0:\n            return False\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello') == True\n    assert candidate('abcdcba') == True\n    assert candidate('kittens') == True\n    assert candidate('orange') == False\n    assert candidate('wow') == True\n    assert candidate('world') == True\n    assert candidate('MadaM') == True\n    assert candidate('Wow') == True\n    assert candidate('') == False\n    assert candidate('HI') == True\n    assert candidate('go') == True\n    assert candidate('gogo') == False\n    assert candidate('aaaaaaaaaaaaaaa') == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('Madam') == True\n    assert candidate('M') == False\n    assert candidate('0') == False\n\n","entry_point":"prime_length"}
{"task_id":"HumanEval\/83","prompt":"def starts_one_ends(n):\n    \"\"\"\n    Kwa kutokana na namba nzuri ya n, rudi idadi ya namba za n-tarakimu\n    ambazo zinaanza au kuishia na 1.\n    \"\"\"\n","canonical_solution":"    if n == 1: return 1\n    return 18 * (10 ** (n - 2))\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 18\n    assert candidate(3) == 180\n    assert candidate(4) == 1800\n    assert candidate(5) == 18000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"starts_one_ends"}
{"task_id":"HumanEval\/84","prompt":"def solve(N):\n    \"\"\"Kwa namba nzuri ya N, rudisha jumla ya jumla ya tarakimu zake katika binary.\n    \n    Mfano\n        Kwa N = 1000, jumla ya tarakimu itakuwa 1 na matokeo yanapaswa kuwa \"1\".\n        Kwa N = 150, jumla ya tarakimu itakuwa 6 na matokeo yanapaswa kuwa \"110\".\n        Kwa N = 147, jumla ya tarakimu itakuwa 12 na matokeo yanapaswa kuwa \"1100\".\n    \n    Variables:\n        @N integer\n             Vikwazo: 0 ≤ N ≤ 10000.\n    Matokeo:\n         string ya namba ya binary\n    \"\"\"","canonical_solution":"    return bin(sum(int(i) for i in str(N)))[2:]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1000) == \"1\", \"Error\"\n    assert candidate(150) == \"110\", \"Error\"\n    assert candidate(147) == \"1100\", \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(333) == \"1001\", \"Error\"\n    assert candidate(963) == \"10010\", \"Error\"\n\n","entry_point":"solve"}
{"task_id":"HumanEval\/85","prompt":"def add(lst):\n    \"\"\"Kwa kutumia orodha isiyo tupu ya integers lst. jumlisha elementi zilizo sawa ambazo zipo kwenye indices za kipekee.\n\n\n    Mifano:\n        add([4, 2, 6, 7]) ==> 2 \n    \"\"\"","canonical_solution":"    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88]) == 88\n    assert candidate([4, 5, 6, 7, 2, 122]) == 122\n    assert candidate([4, 0, 6, 7]) == 0\n    assert candidate([4, 4, 6, 8]) == 12\n\n    # Check some edge cases that are easy to work out by hand.\n    \n","entry_point":"add"}
{"task_id":"HumanEval\/86","prompt":"def anti_shuffle(s):\n    \"\"\"\n    Andika kazi inayochukua string na kurudisha toleo lililopangwa la hiyo.\n    Toleo lililopangwa la string, ni string ambapo maneno yote (yaliyotenganishwa na nafasi)\n    yamebadilishwa na neno jipya ambapo herufi zote zimepangwa katika\n    mpangilio unaokua kulingana na thamani ya ascii.\n    Kumbuka: Unapaswa kudumisha mpangilio wa maneno na nafasi tupu katika sentensi.\n\n    Kwa mfano:\n    anti_shuffle('Hi') inarudisha 'Hi'\n    anti_shuffle('hello') inarudisha 'ehllo'\n    anti_shuffle('Hello World!!!') inarudisha 'Hello !!!Wdlor'\n    \"\"\"","canonical_solution":"    return ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi') == 'Hi'\n    assert candidate('hello') == 'ehllo'\n    assert candidate('number') == 'bemnru'\n    assert candidate('abcd') == 'abcd'\n    assert candidate('Hello World!!!') == 'Hello !!!Wdlor'\n    assert candidate('') == ''\n    assert candidate('Hi. My name is Mister Robot. How are you?') == '.Hi My aemn is Meirst .Rboot How aer ?ouy'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"anti_shuffle"}
{"task_id":"HumanEval\/87","prompt":"def get_row(lst, x):\n    \"\"\"\n    Umepewa data ya vipimo viwili, kama orodha zilizotengenezwa ndani ya orodha nyingine,\n    ambayo ni sawa na matrix, hata hivyo, tofauti na matrix,\n    kila safu inaweza kuwa na idadi tofauti ya nguzo.\n    Ukizingatia lst, na integer x, tafuta integers x katika orodha,\n    na urejeshe orodha ya tuple, [(x1, y1), (x2, y2) ...] ambapo\n    kila tuple ni coordinate - (safu, nguzo), ikiwa naanza na 0.\n    Panga coordinates kwanza kwa safu kwa mpangilio wa kuzidi.\n    Pia, panga coordinates za safu kwa nguzo kwa mpangilio wa kupungua.\n    \n    Mifano:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"","canonical_solution":"    coords = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6]\n    ], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,5,6],\n        [1,1,3,4,5,6],\n        [1,2,1,4,5,6],\n        [1,2,3,1,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)]\n    assert candidate([], 1) == []\n    assert candidate([[1]], 2) == []\n    assert candidate([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"get_row"}
{"task_id":"HumanEval\/88","prompt":"def sort_array(array):\n    \"\"\"\n    Ukipewa safu ya namba zisizo na hasi, rudi nakala ya safu hiyo baada ya kuisorti,\n    utasorti safu hiyo kwa mpangilio wa kiazi kikubwa ikiwa jumla ya (thamani ya kwenye nafasi ya kwanza, thamani ya kwenye nafasi ya mwisho) ni tasa,\n    au sorti kwa mpangilio wa kushuka ikiwa jumla ya (thamani ya kwenye nafasi ya kwanza, thamani ya kwenye nafasi ya mwisho) ni jozi.\n\n    Maelezo:\n    * usibadilishe safu uliyopewa.\n\n    Mifano:\n    * sort_array([]) => []\n    * sort_array([5]) => [5]\n    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n","canonical_solution":"    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([5]) == [5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([2, 1]) == [1, 2], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], \"Error\"\n    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], \"Error\"\n\n","entry_point":"sort_array"}
{"task_id":"HumanEval\/89","prompt":"def encrypt(s):\n    \"\"\"Tengeneza kazi ya encrypt ambayo inachukua string kama hoja na\n    inarudisha string iliyosimbwa na alfabeti ikizungushwa.\n    Alfabeti inapaswa kuzungushwa kwa njia ambayo herufi\n    zinasogea chini kwa mbili zilizozidishwa kwa nafasi mbili.\n    Kwa mfano:\n    encrypt('hi') inarudisha 'lm'\n    encrypt('asdfghjkl') inarudisha 'ewhjklnop'\n    encrypt('gf') inarudisha 'kj'\n    encrypt('et') inarudisha 'ix'\n    \"\"\"","canonical_solution":"    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 26]\n        else:\n            out += c\n    return out\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi') == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl') == 'ewhjklnop', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf') == 'kj', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et') == 'ix', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg')=='jeiajeaijeiak', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend')=='lippsqcjvmirh', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh')=='hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a')=='e', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"encrypt"}
{"task_id":"HumanEval\/90","prompt":"def next_smallest(lst):\n    \"\"\"\n    Umepewa orodha ya nambari za integer.\n    Andika kazi next_smallest() ambayo inarudisha elementi ndogo ya pili katika orodha.\n    Rudi None kama hakuna elementi kama hiyo.\n    \n    next_smallest([1, 2, 3, 4, 5]) == 2\n    next_smallest([5, 1, 4, 3, 2]) == 2\n    next_smallest([]) == None\n    next_smallest([1, 1]) == None\n    \"\"\"","canonical_solution":"    lst = sorted(set(lst))\n    return None if len(lst) < 2 else lst[1]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == 2\n    assert candidate([5, 1, 4, 3, 2]) == 2\n    assert candidate([]) == None\n    assert candidate([1, 1]) == None\n    assert candidate([1,1,1,1,0]) == 1\n    assert candidate([1, 0**0]) == None\n    assert candidate([-35, 34, 12, -45]) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"next_smallest"}
{"task_id":"HumanEval\/91","prompt":"def is_bored(S):\n    \"\"\"\n    Utapewa mfuatano wa maneno, na kazi yako ni kuhesabu idadi\n    ya kuchosha. Kuchosha ni sentensi inayoanza na neno \"I\".\n    Sentensi zinatenganishwa na '.', '?' au '!'.\n   \n    Kwa mfano:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n","canonical_solution":"    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == 'I ' for sentence in sentences)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\") == 0, \"Test 1\"\n    assert candidate(\"Is the sky blue?\") == 0, \"Test 2\"\n    assert candidate(\"I love It !\") == 1, \"Test 3\"\n    assert candidate(\"bIt\") == 0, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\") == 0, \"Test 6\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"is_bored"}
{"task_id":"HumanEval\/92","prompt":"def any_int(x, y, z):\n    '''\n    Tengeneza kazi inayochukua nambari 3.\n    Inarudisha kweli ikiwa mojawapo ya nambari ni sawa na jumla ya zile mbili zingine, na nambari zote ni integer.\n    Inarudisha uongo katika hali nyingine yoyote.\n    \n    Mifano\n    any_int(5, 2, 7) ➞ True\n    \n    any_int(3, 2, 2) ➞ False\n\n    any_int(3, -2, 1) ➞ True\n    \n    any_int(3.6, -2.2, 2) ➞ False\n  \n\n    \n    '''\n","canonical_solution":"    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (x+z==y) or (y+z==x):\n            return True\n        return False\n    return False\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 3, 1)==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(2.5, 2, 3)==False, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(1.5, 5, 3.5)==False, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate(2, 6, 2)==False, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(4, 2, 2)==True, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate(2.2, 2.2, 2.2)==False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate(-4, 6, 2)==True, \"This prints if this assert fails 7 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2,1,1)==True, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate(3,4,7)==True, \"This prints if this assert fails 9 (also good for debugging!)\"\n    assert candidate(3.0,4,7)==False, \"This prints if this assert fails 10 (also good for debugging!)\"\n\n","entry_point":"any_int"}
{"task_id":"HumanEval\/93","prompt":"def encode(message):\n    \"\"\"\n    Andika kazi inayochukua ujumbe, na kuuweka katika msimbo kwa \n    njia ambayo inabadilisha herufi zote kuwa za kesi tofauti, \n    inabadilisha irabu zote katika ujumbe na herufi inayotokea \n    mahali pa pili mbele ya irabu hiyo katika alfabeti ya Kiingereza.\n    Dhania herufi pekee.\n    \n    Mifano:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n","canonical_solution":"    vowels = \"aeiouAEIOU\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST') == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir') == 'mWDCSKR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES') == 'ygs', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message') == 'tHKS KS C MGSSCGG', \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\") == 'k dQnT kNqW wHcT Tq wRkTg', \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"encode"}
{"task_id":"HumanEval\/94","prompt":"def skjkasdkd(lst):\n    \"\"\"Umepeanwa orodha ya nambari za integer.\n    Unahitaji kupata thamani kubwa zaidi ya prime na kurudisha jumla ya tarakimu zake.\n\n    Mifano:\n    Kwa lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] jibu linapaswa kuwa 10\n    Kwa lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] jibu linapaswa kuwa 25\n    Kwa lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] jibu linapaswa kuwa 13\n    Kwa lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] jibu linapaswa kuwa 11\n    Kwa lst = [0,81,12,3,1,21] jibu linapaswa kuwa 3\n    Kwa lst = [0,8,1,2,1,7] jibu linapaswa kuwa 7\n    \"\"\"","canonical_solution":"    def isPrime(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n\n        return True\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and isPrime(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]) == 10, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]) == 25, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]) == 13, \"This prints if this assert fails 3 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,724,32,71,99,32,6,0,5,91,83,0,5,6]) == 11, \"This prints if this assert fails 4 (also good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,81,12,3,1,21]) == 3, \"This prints if this assert fails 5 (also good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7]) == 7, \"This prints if this assert fails 6 (also good for debugging!)\"\n\n    assert candidate([8191]) == 19, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate([8191, 123456, 127, 7]) == 19, \"This prints if this assert fails 8 (also good for debugging!)\"\n    assert candidate([127, 97, 8192]) == 10, \"This prints if this assert fails 9 (also good for debugging!)\"\n","entry_point":"skjkasdkd"}
{"task_id":"HumanEval\/95","prompt":"def check_dict_case(dict):\n    \"\"\"\n    Ukizingatia kamusi, rudi True ikiwa funguo zote ni string katika herufi \n    ndogo au funguo zote ni string katika herufi kubwa, la sivyo rudi False.\n    Kazi hiyo inapaswa kurudi False ikiwa kamusi iliyotolewa ni tupu.\n    Mifano:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) inapaswa kurudi True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) inapaswa kurudi False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) inapaswa kurudi False.\n    check_dict_case({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) inapaswa kurudi False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) inapaswa kurudi True.\n    \"\"\"\n","canonical_solution":"    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"p\":\"pineapple\", \"b\":\"banana\"}) == True, \"First test error: \" + str(candidate({\"p\":\"pineapple\", \"b\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}) == False, \"Second test error: \" + str(candidate({\"p\":\"pineapple\", \"A\":\"banana\", \"B\":\"banana\"}))\n    assert candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}) == False, \"Third test error: \" + str(candidate({\"p\":\"pineapple\", 5:\"banana\", \"a\":\"apple\"}))\n    assert candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) == False, \"Fourth test error: \" + str(candidate({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) == True, \"Fifth test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }))      \n    assert candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }) == True, \"Fourth test error: \" + str(candidate({\"fruit\":\"Orange\", \"taste\":\"Sweet\" }))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate({}) == False, \"1st edge test error: \" + str(candidate({}))\n\n","entry_point":"check_dict_case"}
{"task_id":"HumanEval\/96","prompt":"def count_up_to(n):\n    \"\"\"Tekeleza kazi ambayo inapokea namba isiyo na ishara hasi na inarudisha orodha ya namba za kwanza n\n    ambazo ni namba asilia na ni chini ya n.\n    kwa mfano:\n    count_up_to(5) => [2,3]\n    count_up_to(11) => [2,3,5,7]\n    count_up_to(0) => []\n    count_up_to(20) => [2,3,5,7,11,13,17,19]\n    count_up_to(1) => []\n    count_up_to(18) => [2,3,5,7,11,13,17]\n    \"\"\"","canonical_solution":"    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n","test":"def check(candidate):\n\n    assert candidate(5) == [2,3]\n    assert candidate(6) == [2,3,5]\n    assert candidate(7) == [2,3,5]\n    assert candidate(10) == [2,3,5,7]\n    assert candidate(0) == []\n    assert candidate(22) == [2,3,5,7,11,13,17,19]\n    assert candidate(1) == []\n    assert candidate(18) == [2,3,5,7,11,13,17]\n    assert candidate(47) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    assert candidate(101) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\n","entry_point":"count_up_to"}
{"task_id":"HumanEval\/97","prompt":"def multiply(a, b):\n    \"\"\"Kamilisha kazi ambayo inachukua tarakimu mbili na inarudisha \n    zao la tarakimu zao za mwisho.\n    Dhania kwamba ingizo ni sahihi daima.\n    Mifano:\n    multiply(148, 412) inapaswa kurudisha 16.\n    multiply(19, 28) inapaswa kurudisha 72.\n    multiply(2020, 1851) inapaswa kurudisha 0.\n    multiply(14,-15) inapaswa kurudisha 20.\n    \"\"\"","canonical_solution":"    return abs(a % 10) * abs(b % 10)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412) == 16, \"First test error: \" + str(candidate(148, 412))                    \n    assert candidate(19, 28) == 72, \"Second test error: \" + str(candidate(19, 28))           \n    assert candidate(2020, 1851) == 0, \"Third test error: \" + str(candidate(2020, 1851))\n    assert candidate(14,-15) == 20, \"Fourth test error: \" + str(candidate(14,-15))      \n    assert candidate(76, 67) == 42, \"Fifth test error: \" + str(candidate(76, 67))      \n    assert candidate(17, 27) == 49, \"Sixth test error: \" + str(candidate(17, 27))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1) == 0, \"1st edge test error: \" + str(candidate(0, 1))\n    assert candidate(0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0))\n\n","entry_point":"multiply"}
{"task_id":"HumanEval\/98","prompt":"def count_upper(s):\n    \"\"\"\n    Ukipewa string s, hesabu idadi ya irabu kubwa zilizo kwenye viashiria vya shufwa.\n    \n    Kwa mfano:\n    count_upper('aBCdEf') inarudisha 1\n    count_upper('abcdefg') inarudisha 0\n    count_upper('dBBE') inarudisha 0\n    \"\"\"\n","canonical_solution":"    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 1\n    return count\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('aBCdEf')  == 1\n    assert candidate('abcdefg') == 0\n    assert candidate('dBBE') == 0\n    assert candidate('B')  == 0\n    assert candidate('U')  == 1\n    assert candidate('') == 0\n    assert candidate('EEEE') == 2\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"count_upper"}
{"task_id":"HumanEval\/99","prompt":"def closest_integer(value):\n    '''\n    Tengeneza kazi inayochukua thamani (string) inayoonyesha namba\n    na inarudisha integer iliyo karibu zaidi nayo. Ikiwa namba iko katikati\n    sawa na integer mbili, ikirundike mbali na sifuri.\n\n    Mifano\n    >>> closest_integer(\"10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Maelezo:\n    Kukirundika mbali na sifuri inamaanisha kwamba ikiwa namba iliyotolewa iko katikati\n    sawa na integer mbili, ile unayopaswa kurudisha ni ile iliyo mbali zaidi na sifuri. Kwa mfano closest_integer(\"14.5\") inapaswa\n    kurudisha 15 na closest_integer(\"-14.5\") inapaswa kurudisha -15.\n    '''","canonical_solution":"    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = ceil(num)\n        else:\n            res = floor(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"10\") == 10, \"Test 1\"\n    assert candidate(\"14.5\") == 15, \"Test 2\"\n    assert candidate(\"-15.5\") == -16, \"Test 3\"\n    assert candidate(\"15.3\") == 15, \"Test 3\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"0\") == 0, \"Test 0\"\n\n","entry_point":"closest_integer"}
{"task_id":"HumanEval\/100","prompt":"def make_a_pile(n):\n    \"\"\"\n    Ukipewa namba nzuri ya n, unatakiwa kutengeneza rundo la mawe yenye ngazi n.\n    Ngazi ya kwanza ina mawe n.\n    Idadi ya mawe katika ngazi inayofuata ni:\n        - namba inayofuata ya ajabu ikiwa n ni ya ajabu.\n        - namba inayofuata ya usawa ikiwa n ni ya usawa.\n    Rudisha idadi ya mawe katika kila ngazi kwenye orodha, ambapo elementi kwenye index\n    i inawakilisha idadi ya mawe katika ngazi (i+1).\n\n    Mifano:\n    >>> make_a_pile(3)\n    [3, 5, 7]\n    \"\"\"","canonical_solution":"    return [n + 2*i for i in range(n)]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3) == [3, 5, 7], \"Test 3\"\n    assert candidate(4) == [4,6,8,10], \"Test 4\"\n    assert candidate(5) == [5, 7, 9, 11, 13]\n    assert candidate(6) == [6, 8, 10, 12, 14, 16]\n    assert candidate(8) == [8, 10, 12, 14, 16, 18, 20, 22]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"make_a_pile"}
{"task_id":"HumanEval\/101","prompt":"def words_string(s):\n    \"\"\"\n    Utapewa string ya maneno yaliyotenganishwa kwa koma au nafasi. Kazi yako ni\n    kugawanya string hiyo katika maneno na kurudisha array ya maneno hayo.\n    \n    Kwa mfano:\n    words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    words_string(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"","canonical_solution":"    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    assert candidate(\"Hi, my name\") == [\"Hi\", \"my\", \"name\"]\n    assert candidate(\"One,, two, three, four, five, six,\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\"\") == []\n    assert candidate(\"ahmed     , gamal\") == [\"ahmed\", \"gamal\"]\n\n","entry_point":"words_string"}
{"task_id":"HumanEval\/102","prompt":"def choose_num(x, y):\n    \"\"\"Kazi ya hii function ni kupokea nambari mbili chanya x na y na kurejesha\n    nambari kubwa zaidi ya usawa ambayo iko katika masafa [x, y] pamoja. Ikiwa\n    hakuna nambari kama hiyo, basi function inapaswa kurejesha -1.\n\n    Kwa mfano:\n    choose_num(12, 15) = 14\n    choose_num(13, 12) = -1\n    \"\"\"","canonical_solution":"    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(12, 15) == 14\n    assert candidate(13, 12) == -1\n    assert candidate(33, 12354) == 12354\n    assert candidate(5234, 5233) == -1\n    assert candidate(6, 29) == 28\n    assert candidate(27, 10) == -1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 7) == -1\n    assert candidate(546, 546) == 546\n\n","entry_point":"choose_num"}
{"task_id":"HumanEval\/103","prompt":"def rounded_avg(n, m):\n    \"\"\"Ukipewa namba mbili chanya n na m, kazi yako ni kuhesabu wastani wa \n    namba kuanzia n hadi m (ikiwa ni pamoja na n na m).\n    Mzunguko wa jibu hadi namba ya karibu zaidi na uibadilishe kuwa binary.\n    Ikiwa n ni kubwa kuliko m, rudi -1.\n    Mfano:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"","canonical_solution":"    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n + 1)))\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 5) == \"0b11\"\n    assert candidate(7, 13) == \"0b1010\"\n    assert candidate(964,977) == \"0b1111001010\"\n    assert candidate(996,997) == \"0b1111100100\"\n    assert candidate(560,851) == \"0b1011000010\"\n    assert candidate(185,546) == \"0b101101110\"\n    assert candidate(362,496) == \"0b110101101\"\n    assert candidate(350,902) == \"0b1001110010\"\n    assert candidate(197,233) == \"0b11010111\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(7, 5) == -1\n    assert candidate(5, 1) == -1\n    assert candidate(5, 5) == \"0b101\"\n\n","entry_point":"rounded_avg"}
{"task_id":"HumanEval\/104","prompt":"def unique_digits(x):\n    \"\"\"Kwa kutumia orodha ya namba nzima chanya x. rudisha orodha iliyopangwa ya \n    elementi zote ambazo hazina tarakimu yoyote shufwa.\n\n    Maelezo: Orodha iliyorudishwa inapaswa kupangwa kwa utaratibu unaongezeka.\n    \n    Kwa mfano:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n","canonical_solution":"    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    return sorted(odd_digit_elements)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 33, 1422, 1]) == [1, 15, 33]\n    assert candidate([152, 323, 1422, 10]) == []\n    assert candidate([12345, 2033, 111, 151]) == [111, 151]\n    assert candidate([135, 103, 31]) == [31, 135]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"unique_digits"}
{"task_id":"HumanEval\/105","prompt":"def by_length(arr):\n    \"\"\"\n    Kwa kutumia orodha ya nambari za integer, panga nambari za integer zilizo kati ya 1 na 9 ikiwa ni pamoja,\n    geuza orodha iliyopangwa kinyume, na kisha badilisha kila tarakimu kwa jina lake linalolingana kutoka\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    Kwa mfano:\n      arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> panga arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n            -> geuza arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      rudi [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n    \n      Ikiwa orodha ni tupu, rudi orodha tupu:\n      arr = []\n      rudi []\n    \n      Ikiwa orodha ina nambari yoyote ya ajabu ipuuze:\n      arr = [1, -1 , 55] \n            -> panga arr -> [-1, 1, 55]\n            -> geuza arr -> [55, 1, -1]\n      rudi = ['One']\n    \"\"\"","canonical_solution":"    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3]) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, -1, 3, 2]) == [\"Three\", \"Two\", \"One\"]\n    assert candidate([9, 4, 8]) == [\"Nine\", \"Eight\", \"Four\"]\n\n","entry_point":"by_length"}
{"task_id":"HumanEval\/106","prompt":"def f(n):\n    \"\"\" Tekeleza kazi f ambayo inapokea n kama kigezo,\n    na inarudisha orodha yenye ukubwa wa n, ambapo thamani ya elementi kwenye index i ni faktoriali ya i ikiwa i ni shufwa\n    au jumla ya nambari kutoka 1 hadi i vinginevyo.\n    i inaanza kutoka 1.\n    faktoriali ya i ni uzidishaji wa nambari kutoka 1 hadi i (1 * 2 * ... * i).\n    Mfano:\n    f(5) == [1, 2, 6, 24, 15]\n    \"\"\"","canonical_solution":"    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n","test":"def check(candidate):\n\n    assert candidate(5) == [1, 2, 6, 24, 15]\n    assert candidate(7) == [1, 2, 6, 24, 15, 720, 28]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 6]\n","entry_point":"f"}
{"task_id":"HumanEval\/107","prompt":"def even_odd_palindrome(n):\n    \"\"\"\n    Kwa namba nzuri ya integer n, rudisha tuple inayokuwa na idadi ya palindromes za integer za shufwa na za witiri\n    zinazoangukia ndani ya masafa ya (1, n), ikiwa ni pamoja na n yenyewe.\n\n    Mfano 1:\n\n        Input: 3\n        Output: (1, 2)\n        Maelezo:\n        Palindromes za integer ni 1, 2, 3. moja wapo ni shufwa, na mbili zao ni za witiri.\n\n    Mfano 2:\n\n        Input: 12\n        Output: (4, 6)\n        Maelezo:\n        Palindromes za integer ni 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. nne kati yao ni shufwa, na sita kati yao ni za witiri.\n\n    Kumbuka:\n        1. 1 <= n <= 10^3\n        2. tuple iliyorudishwa ina idadi ya palindromes za integer za shufwa na za witiri mtawalia.\n    \"\"\"\n","canonical_solution":"    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(123) == (8, 13)\n    assert candidate(12) == (4, 6)\n    assert candidate(3) == (1, 2)\n    assert candidate(63) == (6, 8)\n    assert candidate(25) == (5, 6)\n    assert candidate(19) == (4, 6)\n    assert candidate(9) == (4, 5), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"even_odd_palindrome"}
{"task_id":"HumanEval\/108","prompt":"def count_nums(arr):\n    \"\"\"\n    Andika kazi inaitwa count_nums ambayo inapokea safu ya nambari za integer na inarudisha\n    idadi ya elementi ambazo jumla ya tarakimu zake ni kubwa kuliko 0.\n    Ikiwa nambari ni hasi, basi tarakimu yake ya kwanza itakuwa na ishara hasi:\n    kwa mfano -123 ina tarakimu zenye ishara -1, 2, na 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n","canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in arr])))\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0\n    assert candidate([-1, -2, 0]) == 0\n    assert candidate([1, 1, 2, -2, 3, 4, 5]) == 6\n    assert candidate([1, 6, 9, -6, 0, 1, 5]) == 5\n    assert candidate([1, 100, 98, -7, 1, -1]) == 4\n    assert candidate([12, 23, 34, -45, -56, 0]) == 5\n    assert candidate([-0, 1**0]) == 1\n    assert candidate([1]) == 1\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"count_nums"}
{"task_id":"HumanEval\/109","prompt":"def move_one_ball(arr):\n    \"\"\"Tuna orodha 'arr' ya N integers arr[1], arr[2], ..., arr[N]. Nambari\n    katika orodha zitakuwa zimepangwa kiholela. Kazi yako ni kubaini ikiwa\n    inawezekana kupata orodha iliyopangwa kwa mpangilio usio-shuka kwa kufanya\n    operesheni ifuatayo kwenye orodha iliyotolewa:\n        Unaruhusiwa kufanya operesheni ya kusogeza kulia mara kadhaa.\n    \n    Operesheni moja ya kusogeza kulia inamaanisha kusogeza elementi zote za orodha\n    kwa nafasi moja kuelekea kulia. Elementi ya mwisho ya orodha itahamishwa hadi\n    nafasi ya kuanzia katika orodha yaani index ya 0.\n\n    Ikiwa inawezekana kupata orodha iliyopangwa kwa kufanya operesheni iliyotajwa\n    hapo juu basi rudi True vinginevyo rudi False.\n    Ikiwa orodha iliyotolewa ni tupu basi rudi True.\n\n    Kumbuka: Orodha iliyotolewa inahakikishiwa kuwa na elementi za kipekee.\n\n    Kwa Mfano:\n    \n    move_one_ball([3, 4, 5, 1, 2])==>True\n    Maelezo: Kwa kufanya operesheni 2 za kusogeza kulia, mpangilio usio-shuka unaweza\n             kupatikana kwa orodha iliyotolewa.\n    move_one_ball([3, 5, 4, 1, 2])==>False\n    Maelezo: Haiwezekani kupata mpangilio usio-shuka kwa orodha iliyotolewa kwa kufanya\n             idadi yoyote ya operesheni za kusogeza kulia.\n                \n    \"\"\"","canonical_solution":"    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=arr.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True\n    assert candidate([4, 3, 1, 2])==False\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([])==True\n","entry_point":"move_one_ball"}
{"task_id":"HumanEval\/110","prompt":"def exchange(lst1, lst2):\n    \"\"\"Katika tatizo hili, utatekeleza kazi ambayo inachukua orodha mbili za nambari,\n    na kuamua iwapo inawezekana kufanya ubadilishanaji wa vipengele\n    kati yao ili kufanya lst1 kuwa orodha ya nambari za jozi pekee.\n    Hakuna kikomo kwa idadi ya vipengele vilivyobadilishwa kati ya lst1 na lst2.\n    Ikiwa inawezekana kubadilishana vipengele kati ya lst1 na lst2 ili kufanya\n    vipengele vyote vya lst1 kuwa vya jozi, rudi \"YES\".\n    Vinginevyo, rudi \"NO\".\n    Kwa mfano:\n    exchange([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    exchange([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    Inadhaniwa kwamba orodha za pembejeo zitakuwa zisizo tupu.\n    \"\"\"","canonical_solution":"    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            odd += 1\n    for i in lst2:\n        if i%2 == 0:\n            even += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 5, 3, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4]) == \"YES\"\n    assert candidate([5, 7, 3], [2, 6, 3]) == \"NO\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200]) == \"YES\"\n\n","entry_point":"exchange"}
{"task_id":"HumanEval\/111","prompt":"def histogram(test):\n    \"\"\"Kwa kutumia string inayowakilisha herufi ndogo zilizotenganishwa na nafasi, rudi kamusi\n    ya herufi iliyo na marudio mengi zaidi na ikiwa na kuhesabu husika.\n    Ikiwa herufi kadhaa zina matukio sawa, rudi zote.\n    \n    Mfano:\n    histogram('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    histogram('a b b a') == {'a': 2, 'b': 2}\n    histogram('a b c a b') == {'a': 2, 'b': 2}\n    histogram('b b b b a') == {'b': 4}\n    histogram('') == {}\n\n    \"\"\"","canonical_solution":"    dict1={}\n    list1=test.split(\" \")\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('a b b a') == {'a':2,'b': 2}, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('a b c a b') == {'a': 2, 'b': 2}, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('a b c d g') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'g': 1}, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate('b b b b a') == {'b': 4}, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate('r t g') == {'r': 1,'t': 1,'g': 1}, \"This prints if this assert fails 6 (good for debugging!)\"\n    \n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == {}, \"This prints if this assert fails 7 (also good for debugging!)\"\n    assert candidate('a') == {'a': 1}, \"This prints if this assert fails 8 (also good for debugging!)\"\n\n","entry_point":"histogram"}
{"task_id":"HumanEval\/112","prompt":"def reverse_delete(s,c):\n    \"\"\"Kazi\n    Tumepewa misitari miwili s na c, unatakiwa kufuta herufi zote katika s ambazo ni sawa na herufi yoyote katika c\n    kisha angalia kama mstari uliobaki ni palindrome.\n    Mstari unaitwa palindrome ikiwa unasomeka vilevile kutoka nyuma kama mbele.\n    Unapaswa kurudisha tuple inayojumuisha mstari uliobaki na Kweli\/Uongo kwa ajili ya ukaguzi.\n    Mfano\n    Kwa s = \"abcde\", c = \"ae\", matokeo yanapaswa kuwa ('bcd',False)\n    Kwa s = \"abcdef\", c = \"b\" matokeo yanapaswa kuwa ('acdef',False)\n    Kwa s = \"abcdedcba\", c = \"ab\", matokeo yanapaswa kuwa ('cdedc',True)\n    \"\"\"","canonical_solution":"    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] == s)\n","test":"def check(candidate):\n\n    assert candidate(\"abcde\",\"ae\") == ('bcd',False)\n    assert candidate(\"abcdef\", \"b\") == ('acdef',False)\n    assert candidate(\"abcdedcba\",\"ab\") == ('cdedc',True)\n    assert candidate(\"dwik\",\"w\") == ('dik',False)\n    assert candidate(\"a\",\"a\") == ('',True)\n    assert candidate(\"abcdedcba\",\"\") == ('abcdedcba',True)\n    assert candidate(\"abcdedcba\",\"v\") == ('abcdedcba',True)\n    assert candidate(\"vabba\",\"v\") == ('abba',True)\n    assert candidate(\"mamma\", \"mia\") == (\"\", True)\n","entry_point":"reverse_delete"}
{"task_id":"HumanEval\/113","prompt":"def odd_count(lst):\n    \"\"\"Kwa kutokana na orodha ya misemo, ambapo kila msemo una tarakimu pekee, rudisha orodha.\n    Kila kipengele i cha matokeo kinapaswa kuwa \"idadi ya vipengele vya kipekee katika\n    msemo i wa ingizo.\" ambapo i zote zinapaswa kubadilishwa na idadi\n    ya tarakimu za kipekee katika msemo wa i katika ingizo.\n\n    >>> odd_count(['1234567'])\n    [\"idadi ya vipengele vya kipekee 4 katika msemo 4 wa 4ngizo.\"]\n    >>> odd_count(['3',\"11111111\"])\n    [\"idadi ya vipengele vya kipekee 1 katika msemo 1 wa 1ngizo.\",\n     \"idadi ya vipengele vya kipekee 8 katika msemo 8 wa 8ngizo.\"]\n    \"\"\"\n","canonical_solution":"    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['1234567']) == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"], \"Test 1\"\n    assert candidate(['3',\"11111111\"]) == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\", \"the number of odd elements 8n the str8ng 8 of the 8nput.\"], \"Test 2\"\n    assert candidate(['271', '137', '314']) == [\n        'the number of odd elements 2n the str2ng 2 of the 2nput.',\n        'the number of odd elements 3n the str3ng 3 of the 3nput.',\n        'the number of odd elements 2n the str2ng 2 of the 2nput.'\n    ]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"odd_count"}
{"task_id":"HumanEval\/114","prompt":"def minSubArraySum(nums):\n    \"\"\"\n    Kwa kutumia orodha ya nambari za integers nums, pata jumla ndogo zaidi ya sehemu yoyote isiyo tupu\n    ya nums.\n    Mfano\n    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1\n    minSubArraySum([-1, -2, -3]) == -6\n    \"\"\"\n","canonical_solution":"    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = -max_sum\n    return min_sum\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == 1, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1, -2, -3]) == -6\n    assert candidate([-1, -2, -3, 2, -10]) == -14\n    assert candidate([-9999999999999999]) == -9999999999999999\n    assert candidate([0, 10, 20, 1000000]) == 0\n    assert candidate([-1, -2, -3, 10, -5]) == -6\n    assert candidate([100, -1, -2, -3, 10, -5]) == -6\n    assert candidate([10, 11, 13, 8, 3, 4]) == 3\n    assert candidate([100, -33, 32, -1, 0, -2]) == -33\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-10]) == -10, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([7]) == 7\n    assert candidate([1, -1]) == -1\n","entry_point":"minSubArraySum"}
{"task_id":"HumanEval\/115","prompt":"def max_fill(grid, capacity):\n    import math\n    \"\"\"\n    Umepewa gridi ya mstatili yenye visima. Kila safu inawakilisha kisima kimoja,\n    na kila 1 katika safu inawakilisha kipimo kimoja cha maji.\n    Kila kisima kina ndoo inayolingana ambayo inaweza kutumika kutoa maji kutoka ndani yake,\n    na ndoo zote zina uwezo sawa.\n    Kazi yako ni kutumia ndoo hizo kutoa maji kutoka kwenye visima.\n    Toa idadi ya mara ngapi unahitaji kushusha ndoo hizo.\n\n    Mfano wa 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Mfano wa 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Mfano wa 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Vizuizi:\n        * visima vyote vina urefu sawa\n        * 1 <= urefu wa grid.length <= 10^2\n        * 1 <= urefu wa grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= uwezo wa ndoo <= 10\n    \"\"\"\n","canonical_solution":"    return sum([math.ceil(sum(arr)\/capacity) for arr in grid])\n","test":"def check(candidate):\n\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1) == 6, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2) == 5, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5) == 0, \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2) == 4, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9) == 2, \"Error\"\n\n","entry_point":"max_fill"}
{"task_id":"HumanEval\/116","prompt":"def sort_array(arr):\n    \"\"\"\n    Katika Kata hii, unatakiwa kupanga array ya namba zisizo na ishara hasi kulingana na\n    idadi ya moja katika uwakilishi wao wa binary kwa mpangilio unaopanda.\n    Kwa idadi sawa ya moja, panga kulingana na thamani ya desimali.\n\n    Lazima itekelezwe hivi:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"","canonical_solution":"    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,5,2,3,4]) == [1, 2, 4, 3, 5]\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4]) == [0, 1, 2, 4, 3]\n    assert candidate([]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([3,6,44,12,32,5]) == [32, 3, 5, 6, 12, 44]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32]) == [2, 4, 8, 16, 32]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"sort_array"}
{"task_id":"HumanEval\/117","prompt":"def select_words(s, n):\n    \"\"\"Ukipewa string s na namba asilia n, umetakiwa kutekeleza \n    kazi ya kurudisha orodha ya maneno yote kutoka kwenye string s ambayo yana herufi za konsonanti \n    n kwa usahihi, kulingana na mpangilio wa maneno hayo katika string s.\n    Ikiwa string s ni tupu basi kazi hiyo inapaswa kurudisha orodha tupu.\n    Kumbuka: unaweza kudhani kwamba string ya kuingiza ina herufi na nafasi tu.\n    Mifano:\n    select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    select_words(\"simple white space\", 2) ==> []\n    select_words(\"Hello world\", 4) ==> [\"world\"]\n    select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"","canonical_solution":"    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb\", 4) == [\"little\"], \"First test error: \" + str(candidate(\"Mary had a little lamb\", 4))      \n    assert candidate(\"Mary had a little lamb\", 3) == [\"Mary\", \"lamb\"], \"Second test error: \" + str(candidate(\"Mary had a little lamb\", 3))  \n    assert candidate(\"simple white space\", 2) == [], \"Third test error: \" + str(candidate(\"simple white space\", 2))      \n    assert candidate(\"Hello world\", 4) == [\"world\"], \"Fourth test error: \" + str(candidate(\"Hello world\", 4))  \n    assert candidate(\"Uncle sam\", 3) == [\"Uncle\"], \"Fifth test error: \" + str(candidate(\"Uncle sam\", 3))\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 4) == [], \"1st edge test error: \" + str(candidate(\"\", 4))\n    assert candidate(\"a b c d e f\", 1) == [\"b\", \"c\", \"d\", \"f\"], \"2nd edge test error: \" + str(candidate(\"a b c d e f\", 1))\n\n","entry_point":"select_words"}
{"task_id":"HumanEval\/118","prompt":"def get_closest_vowel(word):\n    \"\"\"Utapewa neno. Kazi yako ni kupata irabu iliyo karibu zaidi ambayo ipo kati ya \n    konsonanti mbili kutoka upande wa kulia wa neno (inatofautisha herufi kubwa na ndogo).\n    \n    Irabu zilizo mwanzoni na mwishoni mwa neno hazihesabiki. Rudi string tupu ikiwa hukupata\n    irabu yoyote inayokidhi masharti yaliyotajwa hapo juu.\n\n    Unaweza kudhani kwamba string iliyotolewa ina herufi za Kiingereza pekee.\n\n    Mfano:\n    get_closest_vowel(\"yogurt\") ==> \"u\"\n    get_closest_vowel(\"FULL\") ==> \"U\"\n    get_closest_vowel(\"quick\") ==> \"\"\n    get_closest_vowel(\"ab\") ==> \"\"\n    \"\"\"","canonical_solution":"    if len(word) < 3:\n        return \"\"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \"\"\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"yogurt\") == \"u\"\n    assert candidate(\"full\") == \"u\"\n    assert candidate(\"easy\") == \"\"\n    assert candidate(\"eAsy\") == \"\"\n    assert candidate(\"ali\") == \"\"\n    assert candidate(\"bad\") == \"a\"\n    assert candidate(\"most\") == \"o\"\n    assert candidate(\"ab\") == \"\"\n    assert candidate(\"ba\") == \"\"\n    assert candidate(\"quick\") == \"\"\n    assert candidate(\"anime\") == \"i\"\n    assert candidate(\"Asia\") == \"\"\n    assert candidate(\"Above\") == \"o\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"get_closest_vowel"}
{"task_id":"HumanEval\/119","prompt":"def match_parens(lst):\n    '''\n    Umepewa orodha ya misitari miwili, kila mstari una funga za wazi '('\n    au funga za kufunga ')' pekee.\n    Kazi yako ni kuangalia ikiwa inawezekana kuunganisha misitari miwili kwa\n    mpangilio fulani, ili mstari utakaozalishwa utakuwa mzuri.\n    Mstari S unachukuliwa kuwa mzuri ikiwa na ikiwa tu funga zote katika S\n    zimepangwa vizuri. Kwa mfano: mstari '(())()' ni mzuri, wakati mstari\n    '())' sio mzuri.\n    Rudi 'Yes' ikiwa kuna njia ya kutengeneza mstari mzuri, na rudi 'No' vinginevyo.\n\n    Mifano:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n","canonical_solution":"    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'Yes' if check(S1) or check(S2) else 'No'\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')']) == 'Yes'\n    assert candidate([')', ')']) == 'No'\n    assert candidate(['(()(())', '())())']) == 'No'\n    assert candidate([')())', '(()()(']) == 'Yes'\n    assert candidate(['(())))', '(()())((']) == 'Yes'\n    assert candidate(['()', '())']) == 'No'\n    assert candidate(['(()(', '()))()']) == 'Yes'\n    assert candidate(['((((', '((())']) == 'No'\n    assert candidate([')(()', '(()(']) == 'No'\n    assert candidate([')(', ')(']) == 'No'\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')']) == 'Yes'\n    assert candidate([')', '(']) == 'Yes' \n\n","entry_point":"match_parens"}
{"task_id":"HumanEval\/120","prompt":"def maximum(arr, k):\n    \"\"\"\n    Ukipewa orodha arr ya nambari za integer na nambari nzuri ya integer k, rudi orodha iliyopangwa \n    yenye urefu wa k ikiwa na nambari kubwa k zaidi katika arr.\n\n    Mfano 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Mfano 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Mfano 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Kumbuka:\n        1. Urefu wa orodha utakuwa katika masafa ya [1, 1000].\n        2. Elementi katika orodha zitakuwa katika masafa ya [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"","canonical_solution":"    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]\n    assert candidate([4, -4, 4], 2) == [4, 4]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]\n    assert candidate([1, 0, 5, -7], 1) == [5]\n    assert candidate([4, -4], 2) == [-4, 4]\n    assert candidate([-10, 10], 2) == [-10, 10]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n","entry_point":"maximum"}
{"task_id":"HumanEval\/121","prompt":"def solution(lst):\n    \"\"\"Kwa kutumia orodha isiyo tupu ya nambari za integer, rudisha jumla ya elementi zote za ajabu zilizo katika nafasi za shufwa.\n    \n\n    Mifano\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\"","canonical_solution":"    return sum([x for idx, x in enumerate(lst) if idx%2==0 and x%2==1])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1])    == 12\n    assert candidate([3, 3, 3, 3, 3]) == 9\n    assert candidate([30, 13, 24, 321]) == 0\n    assert candidate([5, 9]) == 5\n    assert candidate([2, 4, 8]) == 0\n    assert candidate([30, 13, 23, 32]) == 23\n    assert candidate([3, 13, 2, 9]) == 3\n\n    # Check some edge cases that are easy to work out by hand.\n\n","entry_point":"solution"}
{"task_id":"HumanEval\/122","prompt":"def add_elements(arr, k):\n    \"\"\"\n    Ukipewa orodha isiyo tupu ya nambari za integer arr na integer k, rudisha\n    jumla ya elementi zenye tarakimu mbili au chini kutoka kwa elementi za kwanza k za arr.\n\n    Mfano:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # jumla ya 21 + 3\n\n    Vizuizi:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \"\"\"","canonical_solution":"    return sum(elem for elem in arr[:k] if len(str(elem)) <= 2)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3) == -4\n    assert candidate([111,121,3,4000,5,6], 2) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"add_elements"}
{"task_id":"HumanEval\/123","prompt":"def get_odd_collatz(n):\n    \"\"\"\n    Kwa namba nzuri ya integer n, rudisha orodha iliyo na mpangilio ambayo ina namba za kipekee katika mfululizo wa collatz.\n\n    Nadharia ya Collatz ni nadharia katika hisabati inayohusu mfululizo uliofafanuliwa\n    kama ifuatavyo: anza na namba yoyote nzuri ya integer n. Kisha kila kipengele kinapatikana kutoka kwa \n    kipengele kilichopita kama ifuatavyo: ikiwa kipengele kilichopita ni cha usawa, kipengele kinachofuata ni nusu moja ya \n    kipengele kilichopita. Ikiwa kipengele kilichopita ni cha kipekee, kipengele kinachofuata ni mara tatu ya kipengele\n    kilichopita pamoja na 1. Nadharia ni kwamba haijalishi thamani ya n, mfululizo utafikia 1 daima.\n\n    Kumbuka: \n        1. Collatz(1) ni [1].\n        2. orodha iliyorudishwa imepangwa kwa mpangilio unaokua.\n\n    Kwa mfano:\n    get_odd_collatz(5) inarudisha [1, 5] # Mfululizo wa collatz kwa 5 ni [5, 16, 8, 4, 2, 1], hivyo namba za kipekee ni 1, na 5 tu.\n    \"\"\"\n","canonical_solution":"    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*3 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == [1, 5, 7, 11, 13, 17]\n    assert candidate(5) == [1, 5]\n    assert candidate(12) == [1, 3, 5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == [1], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"get_odd_collatz"}
{"task_id":"HumanEval\/124","prompt":"def valid_date(date):\n    \"\"\"Lazima uandike kazi inayothibitisha uhalali wa tarehe iliyotolewa na\n    inarudisha True ikiwa tarehe ni halali vinginevyo False.\n    Tarehe ni halali ikiwa sheria zifuatazo zimeridhika:\n    1. Mfuatano wa tarehe si tupu.\n    2. Idadi ya siku si chini ya 1 au zaidi ya siku 31 kwa miezi 1,3,5,7,8,10,12. Na idadi ya siku si chini ya 1 au zaidi ya siku 30 kwa miezi 4,6,9,11. Na, idadi ya siku si chini ya 1 au zaidi ya 29 kwa mwezi wa 2.\n    3. Miezi haipaswi kuwa chini ya 1 au zaidi ya 12.\n    4. Tarehe inapaswa kuwa katika muundo: mm-dd-yyyy\n\n    kwa mfano: \n    valid_date('03-11-2000') => True\n\n    valid_date('15-01-2012') => False\n\n    valid_date('04-0-2040') => False\n\n    valid_date('06-04-2020') => True\n\n    valid_date('06\/04\/2020') => False\n    \"\"\"","canonical_solution":"    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('03-32-2011') == False\n\n    assert candidate('') == False\n\n    assert candidate('04-31-3000') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n\n    assert candidate('04122003') == False\n\n    assert candidate('20030412') == False\n\n    assert candidate('2003-04') == False\n\n    assert candidate('2003-04-12') == False\n\n    assert candidate('04-2003') == False\n","entry_point":"valid_date"}
{"task_id":"HumanEval\/125","prompt":"def split_words(txt):\n    '''\n    Ukipewa string ya maneno, rudi orodha ya maneno yaliyogawanyika kwa nafasi nyeupe, ikiwa hakuna nafasi nyeupe zilizopo kwenye maandishi unapaswa\n    kugawanya kwa koma ',' ikiwa hakuna koma zilizopo unapaswa kurudisha idadi ya herufi ndogo za alfabeti zenye mpangilio wa kipekee,\n    ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Mifano\n    split_words(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n    split_words(\"abcdef\") == 3 \n    '''\n","canonical_solution":"    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(',',' ').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n","test":"def check(candidate):\n\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello world,!\") == [\"Hello\",\"world,!\"]\n    assert candidate(\"Hello,Hello,world !\") == [\"Hello,Hello,world\",\"!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"aaaBb\") == 1\n    assert candidate(\"\") == 0\n","entry_point":"split_words"}
{"task_id":"HumanEval\/126","prompt":"def is_sorted(lst):\n    '''\n    Kwa kutumia orodha ya nambari, rudisha iwapo zimepangwa\n    kwa mpangilio unaopanda au la. Ikiwa orodha ina zaidi ya nakala moja ya nambari\n    ile ile, rudisha Uongo. Dhania hakuna nambari hasi na ni nambari nzima pekee.\n\n    Mifano\n    is_sorted([5]) ➞ Kweli\n    is_sorted([1, 2, 3, 4, 5]) ➞ Kweli\n    is_sorted([1, 3, 2, 4, 5]) ➞ Uongo\n    is_sorted([1, 2, 3, 4, 5, 6]) ➞ Kweli\n    is_sorted([1, 2, 3, 4, 5, 6, 7]) ➞ Kweli\n    is_sorted([1, 3, 2, 4, 5, 6, 7]) ➞ Uongo\n    is_sorted([1, 2, 2, 3, 3, 4]) ➞ Kweli\n    is_sorted([1, 2, 2, 2, 3, 4]) ➞ Uongo\n    '''\n","canonical_solution":"    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1 \n    if any(count_digit[i] > 2 for i in lst):\n        return False\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5]) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 6]) == True\n    assert candidate([1, 2, 3, 4, 5, 6, 7]) == True\n    assert candidate([1, 3, 2, 4, 5, 6, 7]) == False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([]) == True, \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([1]) == True, \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([3, 2, 1]) == False, \"This prints if this assert fails 4 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 2, 2, 3, 4]) == False, \"This prints if this assert fails 5 (good for debugging!)\"\n    assert candidate([1, 2, 3, 3, 3, 4]) == False, \"This prints if this assert fails 6 (good for debugging!)\"\n    assert candidate([1, 2, 2, 3, 3, 4]) == True, \"This prints if this assert fails 7 (good for debugging!)\"\n    assert candidate([1, 2, 3, 4]) == True, \"This prints if this assert fails 8 (good for debugging!)\"\n\n","entry_point":"is_sorted"}
{"task_id":"HumanEval\/127","prompt":"def intersection(interval1, interval2):\n    \"\"\"Umepeanwa vipindi viwili,\n    ambapo kila kipindi ni jozi ya nambari za integer. Kwa mfano, kipindi = (mwanzo, mwisho) = (1, 2).\n    Vipindi vilivyopeanwa ni vya kufungwa ambavyo ina maana kwamba kipindi (mwanzo, mwisho)\n    kinajumuisha mwanzo na mwisho wote.\n    Kwa kila kipindi kilichopeanwa, inadhaniwa kwamba mwanzo wake ni mdogo au sawa na mwisho wake.\n    Kazi yako ni kubaini iwapo urefu wa muingiliano wa vipindi hivi viwili\n    ni nambari ya kwanza.\n    Kwa mfano, muingiliano wa vipindi (1, 3), (2, 4) ni (2, 3)\n    ambayo urefu wake ni 1, ambayo si nambari ya kwanza.\n    Ikiwa urefu wa muingiliano ni nambari ya kwanza, rudi \"YES\",\n    vinginevyo, rudi \"NO\".\n    Ikiwa vipindi viwili havikatani, rudi \"NO\".\n\n\n    [input\/output] sampuli:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"","canonical_solution":"    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0 and is_prime(length):\n        return \"YES\"\n    return \"NO\"\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate((1, 2), (2, 3)) == \"NO\"\n    assert candidate((-1, 1), (0, 4)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0)) == \"YES\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate((-11, 2), (-1, -1)) == \"NO\"\n    assert candidate((1, 2), (3, 5)) == \"NO\"\n    assert candidate((1, 2), (1, 2)) == \"NO\"\n    assert candidate((-2, -2), (-3, -2)) == \"NO\"\n\n","entry_point":"intersection"}
{"task_id":"HumanEval\/128","prompt":"def prod_signs(arr):\n    \"\"\"\n    Umepewa array arr ya integers na unahitaji kurudisha\n    jumla ya ukubwa wa integers ikizidishwa na zao la alama zote\n    za kila namba kwenye array, zinazowakilishwa na 1, -1 au 0.\n    Kumbuka: rudisha None kwa arr tupu.\n\n    Mfano:\n    >>> prod_signs([1, 2, 2, -4]) == -9\n    >>> prod_signs([0, 1]) == 0\n    >>> prod_signs([]) == None\n    \"\"\"\n","canonical_solution":"    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1, 2, 2, -4]) == -9\n    assert candidate([0, 1]) == 0\n    assert candidate([1, 1, 1, 2, 3, -1, 1]) == -10\n    assert candidate([]) == None\n    assert candidate([2, 4,1, 2, -1, -1, 9]) == 20\n    assert candidate([-1, 1, -1, 1]) == 4\n    assert candidate([-1, 1, 1, 1]) == -4\n    assert candidate([-1, 1, 1, 0]) == 0\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"prod_signs"}
{"task_id":"HumanEval\/129","prompt":"def minPath(grid, k):\n    \"\"\"\n    Ukizingatia gridi yenye safu N na nguzo N (N >= 2) na namba nzuri ya k, \n    kila seli ya gridi ina thamani. Kila namba katika masafa [1, N * N]\n    inaonekana mara moja tu kwenye seli za gridi.\n\n    Lazima upate njia ndogo zaidi ya urefu k kwenye gridi. Unaweza kuanza\n    kutoka kwenye seli yoyote, na kwa kila hatua unaweza kuhamia kwenye seli jirani,\n    kwa maneno mengine, unaweza kwenda kwenye seli ambazo zinashiriki ukingo na seli yako ya sasa.\n    Tafadhali kumbuka kwamba njia ya urefu k inamaanisha kutembelea seli k za kipekee (sio\n    lazima ziwe tofauti).\n    HUWEZI kutoka nje ya gridi.\n    Njia A (ya urefu k) inachukuliwa kuwa ndogo kuliko njia B (ya urefu k) ikiwa\n    baada ya kutengeneza orodha zilizopangwa za thamani kwenye seli ambazo A na B zinapitia (tuziite orodha_A na orodha_B), orodha_A ni ndogo kwa mpangilio wa leksografia kuliko orodha_B, kwa maneno mengine, kuna namba ya tarakimu i (1 <= i <= k)\n    ambapo orodha_A[i] < orodha_B[i] na kwa j yoyote (1 <= j < i) tuna\n    orodha_A[j] = orodha_B[j].\n    Inahakikishwa kwamba jibu ni la kipekee.\n    Rudi orodha iliyopangwa ya thamani kwenye seli ambazo njia ndogo zaidi inapitia.\n\n    Mifano:\n\n        Input: gridi = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: gridi = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"","canonical_solution":"    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n","test":"def check(candidate):\n\n    # Check some simple cases\n    print\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3) == [1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1) == [1]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4) == [1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\n    assert candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5) == [1, 7, 1, 7, 1]\n    assert candidate([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9) == [1, 6, 1, 6, 1, 6, 1, 6, 1]\n    assert candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8, 7, 2]], 12) == [1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]\n    assert candidate([[2, 7, 4], [3, 1, 5], [6, 8, 9]], 8) == [1, 3, 1, 3, 1, 3, 1, 3]\n    assert candidate([[6, 1, 5], [3, 8, 9], [2, 7, 4]], 8) == [1, 5, 1, 5, 1, 5, 1, 5]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[1, 2], [3, 4]], 10) == [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([[1, 3], [3, 2]], 10) == [1, 3, 1, 3, 1, 3, 1, 3, 1, 3]\n\n","entry_point":"minPath"}
{"task_id":"HumanEval\/130","prompt":"def tri(n):\n    \"\"\"Kila mtu anajua mfululizo wa Fibonacci, ulichunguzwa kwa kina na wanahisabati katika \n    karne mbili zilizopita. Hata hivyo, kile watu hawajui ni mfululizo wa Tribonacci.\n    Mfululizo wa Tribonacci umeelezwa kwa kurudia:\n    tri(1) = 3\n    tri(n) = 1 + n \/ 2, ikiwa n ni shufwa.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), ikiwa n ni witiri.\n    Kwa mfano:\n    tri(2) = 1 + (2 \/ 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    Umepewa namba isiyo na hasi n, unatakiwa kurudisha orodha ya \n    namba za kwanza n + 1 za mfululizo wa Tribonacci.\n    Mifano:\n    tri(3) = [1, 3, 2, 8]\n    \"\"\"","canonical_solution":"    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i \/ 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) \/ 2)\n    return my_tri\n","test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate(3) == [1, 3, 2.0, 8.0]\n    assert candidate(4) == [1, 3, 2.0, 8.0, 3.0]\n    assert candidate(5) == [1, 3, 2.0, 8.0, 3.0, 15.0]\n    assert candidate(6) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0]\n    assert candidate(7) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0]\n    assert candidate(8) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0]\n    assert candidate(9) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0]\n    assert candidate(20) == [1, 3, 2.0, 8.0, 3.0, 15.0, 4.0, 24.0, 5.0, 35.0, 6.0, 48.0, 7.0, 63.0, 8.0, 80.0, 9.0, 99.0, 10.0, 120.0, 11.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [1]\n    assert candidate(1) == [1, 3]\n","entry_point":"tri"}
{"task_id":"HumanEval\/131","prompt":"def digits(n):\n    \"\"\"Kwa kutokana na namba nzima chanya n, rudisha zao la tarakimu za kipekee.\n    Rudisha 0 ikiwa tarakimu zote ni za shufwa.\n    Kwa mfano:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"","canonical_solution":"    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(5) == 5\n    assert candidate(54) == 5\n    assert candidate(120) ==1\n    assert candidate(5014) == 5\n    assert candidate(98765) == 315\n    assert candidate(5576543) == 2625\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2468) == 0\n\n","entry_point":"digits"}
{"task_id":"HumanEval\/132","prompt":"def is_nested(string):\n    '''\n    Tengeneza kazi ambayo inapokea string kama ingizo ambalo lina mabano ya mraba pekee.\n    Kazi hiyo inapaswa kurudisha True ikiwa na ikiwa tu kuna mlolongo halali wa mabano\n    ambapo angalau mabano moja katika mlolongo huo yameingiliana.\n\n    is_nested('[[]]') ➞ True\n    is_nested('[]]]]]]][[[[[]') ➞ False\n    is_nested('[][]') ➞ False\n    is_nested('[]') ➞ False\n    is_nested('[[][]]') ➞ True\n    is_nested('[[]][[') ➞ True\n    '''\n","canonical_solution":"    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('[[]]') == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('[]]]]]]][[[[[]') == False\n    assert candidate('[][]') == False\n    assert candidate(('[]')) == False\n    assert candidate('[[[[]]]]') == True\n    assert candidate('[]]]]]]]]]]') == False\n    assert candidate('[][][[]]') == True\n    assert candidate('[[]') == False\n    assert candidate('[]]') == False\n    assert candidate('[[]][[') == True\n    assert candidate('[[][]]') == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('') == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n\n","entry_point":"is_nested"}
{"task_id":"HumanEval\/133","prompt":"def sum_squares(lst):\n    \"\"\"Umepeanwa orodha ya nambari.\n    Unahitaji kurudisha jumla ya nambari za mraba katika orodha iliyotolewa,\n    mviringo kila kipengele katika orodha hadi int ya juu (Ceiling) kwanza.\n    Mifano:\n    Kwa lst = [1,2,3] matokeo yanapaswa kuwa 14\n    Kwa lst = [1,4,9] matokeo yanapaswa kuwa 98\n    Kwa lst = [1,3,5,7] matokeo yanapaswa kuwa 84\n    Kwa lst = [1.4,4.2,0] matokeo yanapaswa kuwa 29\n    Kwa lst = [-2.4,1,1] matokeo yanapaswa kuwa 6\n    \n    \"\"\"","canonical_solution":"    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)**2\n    return squared\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==14, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==84, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==29, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==10230, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==75, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==1086, \"This prints if this assert fails 1 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"sum_squares"}
{"task_id":"HumanEval\/134","prompt":"def check_if_last_char_is_a_letter(txt):\n    '''\n    Tengeneza kazi ambayo inarudisha True ikiwa herufi ya mwisho\n    ya string iliyotolewa ni herufi ya alfabeti na siyo\n    sehemu ya neno, na False vinginevyo.\n    Maelezo: \"neno\" ni kikundi cha herufi kilichotenganishwa kwa nafasi.\n\n    Mifano:\n    check_if_last_char_is_a_letter(\"apple pie\") ➞ False\n    check_if_last_char_is_a_letter(\"apple pi e\") ➞ True\n    check_if_last_char_is_a_letter(\"apple pi e \") ➞ False\n    check_if_last_char_is_a_letter(\"\") ➞ False \n    '''\n","canonical_solution":" \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"apple\") == False\n    assert candidate(\"apple pi e\") == True\n    assert candidate(\"eeeee\") == False\n    assert candidate(\"A\") == True\n    assert candidate(\"Pumpkin pie \") == False\n    assert candidate(\"Pumpkin pie 1\") == False\n    assert candidate(\"\") == False\n    assert candidate(\"eeeee e \") == False\n    assert candidate(\"apple pie\") == False\n    assert candidate(\"apple pi e \") == False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"check_if_last_char_is_a_letter"}
{"task_id":"HumanEval\/135","prompt":"def can_arrange(arr):\n    \"\"\"Tengeneza kazi ambayo inarudisha index kubwa zaidi ya element ambayo\n    si kubwa zaidi au sawa na element inayofuatia moja kwa moja nyuma yake. Kama\n    hakuna element kama hiyo basi rudisha -1. Array iliyotolewa haitakuwa na\n    thamani zinazojirudia.\n\n    Mifano:\n    can_arrange([1,2,4,3,5]) = 3\n    can_arrange([1,2,3]) = -1\n    \"\"\"\n","canonical_solution":"    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n    return ind\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,2,4,5])==-1\n    assert candidate([1,4,2,5,6,7,8,9,10])==2\n    assert candidate([4,8,5,7,3])==4\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([])==-1\n\n","entry_point":"can_arrange"}
{"task_id":"HumanEval\/136","prompt":"def largest_smallest_integers(lst):\n    '''\n    Tengeneza kazi inayorudisha tuple (a, b), ambapo 'a' ni\n    kubwa zaidi ya namba hasi, na 'b' ni ndogo zaidi\n    ya namba chanya katika orodha.\n    Kama hakuna namba hasi au chanya, rudisha kama None.\n\n    Mifano:\n    largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n    largest_smallest_integers([]) == (None, None)\n    largest_smallest_integers([0]) == (None, None)\n    '''","canonical_solution":"    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, 1)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, 1)\n    assert candidate([1, 3, 2, 4, 5, 6, -2]) == (-2, 1)\n    assert candidate([4, 5, 3, 6, 2, 7, -7]) == (-7, 2)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9]) == (-9, 2)\n    assert candidate([]) == (None, None)\n    assert candidate([0]) == (None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, None)\n    assert candidate([-6, -4, -4, -3, 1]) == (-3, 1)\n    assert candidate([-6, -4, -4, -3, -100, 1]) == (-3, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n","entry_point":"largest_smallest_integers"}
{"task_id":"HumanEval\/137","prompt":"def compare_one(a, b):\n    \"\"\"\n    Tengeneza kazi inayochukua integers, floats, au strings zinazowakilisha\n    namba halisi, na inarudisha variable kubwa zaidi katika aina yake ya variable iliyotolewa.\n    Rudisha None ikiwa thamani ni sawa.\n    Kumbuka: Ikiwa namba halisi imewakilishwa kama string, nukta ya desimali inaweza kuwa . au ,\n\n    compare_one(1, 2.5) ➞ 2.5\n    compare_one(1, \"2,3\") ➞ \"2,3\"\n    compare_one(\"5,1\", \"6\") ➞ \"6\"\n    compare_one(\"1\", 1) ➞ None\n    \"\"\"\n","canonical_solution":"    temp_a, temp_b = a, b\n    if isinstance(temp_a, str): temp_a = temp_a.replace(',','.')\n    if isinstance(temp_b, str): temp_b = temp_b.replace(',','.')\n    if float(temp_a) == float(temp_b): return None\n    return a if float(temp_a) > float(temp_b) else b \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 2) == 2\n    assert candidate(1, 2.5) == 2.5\n    assert candidate(2, 3) == 3\n    assert candidate(5, 6) == 6\n    assert candidate(1, \"2,3\") == \"2,3\"\n    assert candidate(\"5,1\", \"6\") == \"6\"\n    assert candidate(\"1\", \"2\") == \"2\"\n    assert candidate(\"1\", 1) == None\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"compare_one"}
{"task_id":"HumanEval\/138","prompt":"def is_equal_to_sum_even(n):\n    \"\"\"Tathmini iwapo namba iliyotolewa n inaweza kuandikwa kama jumla ya namba nne chanya zenye usawa\n    Mfano\n    is_equal_to_sum_even(4) == False\n    is_equal_to_sum_even(6) == False\n    is_equal_to_sum_even(8) == True\n    \"\"\"","canonical_solution":"    return n%2 == 0 and n >= 8\n","test":"def check(candidate):\n    assert candidate(4) == False\n    assert candidate(6) == False\n    assert candidate(8) == True\n    assert candidate(10) == True\n    assert candidate(11) == False\n    assert candidate(12) == True\n    assert candidate(13) == False\n    assert candidate(16) == True\n","entry_point":"is_equal_to_sum_even"}
{"task_id":"HumanEval\/139","prompt":"def special_factorial(n):\n    \"\"\"Kifactorial cha Brazil kimefafanuliwa kama:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    ambapo n > 0\n\n    Kwa mfano:\n    >>> special_factorial(4)\n    288\n\n    Function itapokea integer kama input na inapaswa kurejesha special\n    factorial ya integer hii.\n    \"\"\"","canonical_solution":"    fact_i = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= i\n        special_fact *= fact_i\n    return special_fact\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(4) == 288, \"Test 4\"\n    assert candidate(5) == 34560, \"Test 5\"\n    assert candidate(7) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == 1, \"Test 1\"\n\n","entry_point":"special_factorial"}
{"task_id":"HumanEval\/140","prompt":"def fix_spaces(text):\n    \"\"\"\n    Kwa kutumia string text, badilisha nafasi zote ndani yake kuwa alama za chini, \n    na ikiwa string ina nafasi zaidi ya mbili mfululizo, \n    basi badilisha nafasi zote mfululizo kuwa alama ya dashi\n    \n    fix_spaces(\"Example\") == \"Example\"\n    fix_spaces(\"Example 1\") == \"Example_1\"\n    fix_spaces(\" Example 2\") == \"_Example_2\"\n    fix_spaces(\" Example   3\") == \"_Example-3\"\n    \"\"\"\n","canonical_solution":"    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\"+text[i]\n            elif end - start > 0:\n                new_text += \"_\"*(end - start)+text[i]\n            else:\n                new_text += text[i]\n            start, end = i+1, i+1\n        i+=1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n    return new_text\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Example\") == \"Example\", \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"Mudasir Hanif \") == \"Mudasir_Hanif_\", \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate(\"Yellow Yellow  Dirty  Fellow\") == \"Yellow_Yellow__Dirty__Fellow\", \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Exa   mple\") == \"Exa-mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n    assert candidate(\"   Exa 1 2 2 mple\") == \"-Exa_1_2_2_mple\", \"This prints if this assert fails 4 (good for debugging!)\"\n\n","entry_point":"fix_spaces"}
{"task_id":"HumanEval\/141","prompt":"def file_name_check(file_name):\n    \"\"\"Tengeneza kazi ambayo inachukua string inayowakilisha jina la faili, na inarudisha\n    'Ndiyo' ikiwa jina la faili ni halali, na inarudisha 'Hapana' vinginevyo.\n    Jina la faili linachukuliwa kuwa halali ikiwa na ikiwa tu masharti yafuatayo \n    yametimizwa:\n    - Haipaswi kuwa na zaidi ya tarakimu tatu ('0'-'9') katika jina la faili.\n    - Jina la faili linapaswa kuwa na nukta moja tu '.'\n    - Kipande cha jina kabla ya nukta haipaswi kuwa tupu, na inaanza na herufi kutoka \n    kwa alfabeti ya Kilatini ('a'-'z' na 'A'-'Z').\n    - Kipande cha jina baada ya nukta kinapaswa kuwa mojawapo ya hizi: ['txt', 'exe', 'dll']\n    Mifano:\n    file_name_check(\"example.txt\") # => 'Ndiyo'\n    file_name_check(\"1example.dll\") # => 'Hapana' (jina linapaswa kuanza na herufi ya alfabeti ya Kilatini)\n    \"\"\"","canonical_solution":"    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    return 'Yes'\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"example.txt\") == 'Yes'\n    assert candidate(\"1example.dll\") == 'No'\n    assert candidate('s1sdf3.asd') == 'No'\n    assert candidate('K.dll') == 'Yes'\n    assert candidate('MY16FILE3.exe') == 'Yes'\n    assert candidate('His12FILE94.exe') == 'No'\n    assert candidate('_Y.txt') == 'No'\n    assert candidate('?aREYA.exe') == 'No'\n    assert candidate('\/this_is_valid.dll') == 'No'\n    assert candidate('this_is_valid.wow') == 'No'\n    assert candidate('this_is_valid.txt') == 'Yes'\n    assert candidate('this_is_valid.txtexe') == 'No'\n    assert candidate('#this2_i4s_5valid.ten') == 'No'\n    assert candidate('@this1_is6_valid.exe') == 'No'\n    assert candidate('this_is_12valid.6exe4.txt') == 'No'\n    assert candidate('all.exe.txt') == 'No'\n    assert candidate('I563_No.exe') == 'Yes'\n    assert candidate('Is3youfault.txt') == 'Yes'\n    assert candidate('no_one#knows.dll') == 'Yes'\n    assert candidate('1I563_Yes3.exe') == 'No'\n    assert candidate('I563_Yes3.txtt') == 'No'\n    assert candidate('final..txt') == 'No'\n    assert candidate('final132') == 'No'\n    assert candidate('_f4indsartal132.') == 'No'\n    \n        \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('.txt') == 'No'\n    assert candidate('s.') == 'No'\n\n","entry_point":"file_name_check"}
{"task_id":"HumanEval\/142","prompt":"def sum_squares(lst):\n    \"\"\"\n    Kazi ya hii function ni kupokea orodha ya namba za integer. Kwa kila kipengele kilicho kwenye orodha, function itapandisha kipengele cha integer \n    kwenye kipeo cha pili ikiwa index yake ni ganda la 3 na itapandisha kipengele cha integer kwenye kipeo cha tatu ikiwa index yake ni ganda la 4 \n    na si ganda la 3. Function haitabadilisha vipengele kwenye orodha ambavyo index zake si ganda la 3 au 4. Kisha function itarudisha jumla ya \n    vipengele vyote.\n    \n    Mifano:\n    Kwa lst = [1,2,3] matokeo yanapaswa kuwa 6\n    Kwa lst = []  matokeo yanapaswa kuwa 0\n    Kwa lst = [-1,-5,2,-1,-5]  matokeo yanapaswa kuwa -126\n    \"\"\"","canonical_solution":"    result =[]\n    for i in range(len(lst)):\n        if i %3 == 0:\n            result.append(lst[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result.append(lst[i]**3)\n        else:\n            result.append(lst[i])\n    return sum(result)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3]) == 6\n    assert candidate([1,4,9]) == 14\n    assert candidate([]) == 0\n    assert candidate([1,1,1,1,1,1,1,1,1]) == 9\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1]) == -3\n    assert candidate([0]) == 0\n    assert candidate([-1,-5,2,-1,-5]) == -126\n    assert candidate([-56,-99,1,0,-2]) == 3030\n    assert candidate([-1,0,0,0,0,0,0,0,-1]) == 0\n    assert candidate([-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37]) == -14196\n    assert candidate([-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10]) == -1448\n    \n    \n    # Don't remove this line:\n","entry_point":"sum_squares"}
{"task_id":"HumanEval\/143","prompt":"def words_in_sentence(sentence):\n    \"\"\"\n    Umepewa string inayowakilisha sentensi,\n    sentensi hiyo ina maneno kadhaa yaliyotenganishwa kwa nafasi,\n    na unatakiwa kurudisha string inayocontain maneno kutoka sentensi asilia,\n    ambayo urefu wake ni namba za msingi,\n    mpangilio wa maneno katika string mpya unapaswa kuwa sawa na ule wa asili.\n\n    Mfano 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Mfano 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Vizuizi:\n        * 1 <= len(sentence) <= 100\n        * sentence ina herufi pekee\n    \"\"\"","canonical_solution":"    new_lst = []\n    for word in sentence.split():\n        flg = 0\n        if len(word) == 1:\n            flg = 1\n        for i in range(2, len(word)):\n            if len(word)%i == 0:\n                flg = 1\n        if flg == 0 or len(word) == 2:\n            new_lst.append(word)\n    return \" \".join(new_lst)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"This is a test\") == \"is\"\n    assert candidate(\"lets go for swimming\") == \"go for\"\n    assert candidate(\"there is no place available here\") == \"there is no place\"\n    assert candidate(\"Hi I am Hussein\") == \"Hi am Hussein\"\n    assert candidate(\"go for it\") == \"go for it\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"here\") == \"\"\n    assert candidate(\"here is\") == \"is\"\n\n","entry_point":"words_in_sentence"}
{"task_id":"HumanEval\/144","prompt":"def simplify(x, n):\n    \"\"\"Kazi yako ni kutekeleza kazi ambayo itarahisisha usemi\n    x * n. Kazi inarudisha True ikiwa x * n inakadiriwa kuwa nambari nzima na False\n    vinginevyo. Vyote x na n, ni uwakilishi wa mnyambuliko wa sehemu, na vinafuata muundo ufuatao,\n    <numerator>\/<denominator> ambapo numerator na denominator ni nambari nzima chanya.\n\n    Unaweza kudhani kwamba x, na n ni mnyambuliko halali, na hawana sifuri kama denominator.\n\n    simplify(\"1\/5\", \"5\/1\") = True\n    simplify(\"1\/6\", \"2\/1\") = False\n    simplify(\"7\/10\", \"10\/2\") = False\n    \"\"\"","canonical_solution":"    a, b = x.split(\"\/\")\n    c, d = n.split(\"\/\")\n    numerator = int(a) * int(c)\n    denom = int(b) * int(d)\n    if (numerator\/denom == int(numerator\/denom)):\n        return True\n    return False\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test1'\n    assert candidate(\"1\/6\", \"2\/1\") == False, 'test2'\n    assert candidate(\"5\/1\", \"3\/1\") == True, 'test3'\n    assert candidate(\"7\/10\", \"10\/2\") == False, 'test4'\n    assert candidate(\"2\/10\", \"50\/10\") == True, 'test5'\n    assert candidate(\"7\/2\", \"4\/2\") == True, 'test6'\n    assert candidate(\"11\/6\", \"6\/1\") == True, 'test7'\n    assert candidate(\"2\/3\", \"5\/2\") == False, 'test8'\n    assert candidate(\"5\/2\", \"3\/5\") == False, 'test9'\n    assert candidate(\"2\/4\", \"8\/4\") == True, 'test10'\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"2\/4\", \"4\/2\") == True, 'test11'\n    assert candidate(\"1\/5\", \"5\/1\") == True, 'test12'\n    assert candidate(\"1\/5\", \"1\/5\") == False, 'test13'\n\n","entry_point":"simplify"}
{"task_id":"HumanEval\/145","prompt":"def order_by_points(nums):\n    \"\"\"\n    Andika kazi ambayo inapanga orodha iliyotolewa ya namba za integer\n    kwa mpangilio wa kuzidi kulingana na jumla ya tarakimu zao.\n    Kumbuka: ikiwa kuna vitu kadhaa vyenye jumla ya tarakimu zao zinazofanana,\n    viweke kwa mpangilio kulingana na faharisi yao katika orodha asilia.\n\n    Kwa mfano:\n    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    >>> order_by_points([]) == []\n    \"\"\"\n","canonical_solution":"    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n    return sorted(nums, key=digits_sum)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]\n    assert candidate([]) == []\n    assert candidate([1, -11, -32, 43, 54, -98, 2, -3]) == [-3, -32, -98, -11, 1, 2, 43, 54]\n    assert candidate([1,2,3,4,5,6,7,8,9,10,11]) == [1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([0,6,6,-76,-21,23,4]) == [-76, -21, 0, 4, 23, 6, 6]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"order_by_points"}
{"task_id":"HumanEval\/146","prompt":"def specialFilter(nums):\n    \"\"\"Andika kazi inayochukua safu ya nambari kama ingizo na inarudisha \n    idadi ya vipengele katika safu ambavyo ni vikubwa kuliko 10 na nambari \n    ya kwanza na ya mwisho ni za kipekee (1, 3, 5, 7, 9).\n    Kwa mfano:\n    specialFilter([15, -73, 14, -15]) => 1 \n    specialFilter([33, -2, -3, 45, 21, 109]) => 2\n    \"\"\"","canonical_solution":"    \n    count = 0\n    for num in nums:\n        if num > 10:\n            odd_digits = (1, 3, 5, 7, 9)\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                count += 1\n        \n    return count \n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, -2, 1, -5]) == 0  \n    assert candidate([15, -73, 14, -15]) == 1\n    assert candidate([33, -2, -3, 45, 21, 109]) == 2\n    assert candidate([43, -12, 93, 125, 121, 109]) == 4\n    assert candidate([71, -2, -33, 75, 21, 19]) == 3\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == 0              \n    assert candidate([]) == 0                   \n\n","entry_point":"specialFilter"}
{"task_id":"HumanEval\/147","prompt":"def get_max_triples(n):\n    \"\"\"\n    Umepewa namba nzima chanya n. Unatakiwa kutengeneza safu ya namba nzima a yenye urefu wa n.\n        Kwa kila i (1 ≤ i ≤ n), thamani ya a[i] = i * i - i + 1.\n        Rudi idadi ya vikundi vitatu (a[i], a[j], a[k]) vya a ambapo i < j < k, \n    na a[i] + a[j] + a[k] ni kigawo cha 3.\n\n    Mfano :\n        Input: n = 5\n        Output: 1\n        Maelezo: \n        a = [1, 3, 7, 13, 21]\n        Kikundi pekee halali ni (1, 7, 13).\n    \"\"\"","canonical_solution":"    A = [i*i - i + 1 for i in range(1,n+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(j+1,n):\n                if (A[i]+A[j]+A[k])%3 == 0:\n                    ans += [(A[i],A[j],A[k])]\n    return len(ans)\n","test":"def check(candidate):\n\n    assert candidate(5) == 1\n    assert candidate(6) == 4\n    assert candidate(10) == 36\n    assert candidate(100) == 53361\n","entry_point":"get_max_triples"}
{"task_id":"HumanEval\/148","prompt":"def bf(planet1, planet2):\n    '''\n    Kuna sayari nane katika mfumo wetu wa jua: iliyo karibu zaidi na Jua \n    ni Mercury, inayofuata ni Venus, kisha Dunia, Mars, Jupiter, Saturn, \n    Uranus, Neptune.\n    Andika kazi inayochukua majina mawili ya sayari kama string planet1 na planet2. \n    Kazi hiyo inapaswa kurudisha tuple inayojumuisha sayari zote ambazo obiti zao ziko \n    kati ya obiti ya planet1 na obiti ya planet2, zikiwa zimepangwa kwa \n    ukaribu na jua. \n    Kazi hiyo inapaswa kurudisha tuple tupu ikiwa planet1 au planet2\n    sio majina sahihi ya sayari. \n    Mifano\n    bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n    '''\n","canonical_solution":"    planet_names = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return ()\n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    if planet1_index < planet2_index:\n        return (planet_names[planet1_index + 1: planet2_index])\n    else:\n        return (planet_names[planet2_index + 1 : planet1_index])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\"), \"First test error: \" + str(len(candidate(\"Jupiter\", \"Neptune\")))      \n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",), \"Second test error: \" + str(candidate(\"Earth\", \"Mercury\"))  \n    assert candidate(\"Mercury\", \"Uranus\") == (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"), \"Third test error: \" + str(candidate(\"Mercury\", \"Uranus\"))      \n    assert candidate(\"Neptune\", \"Venus\") == (\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"), \"Fourth test error: \" + str(candidate(\"Neptune\", \"Venus\"))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\") == ()\n    assert candidate(\"Jupiter\", \"Makemake\") == ()\n\n","entry_point":"bf"}
{"task_id":"HumanEval\/149","prompt":"def sorted_list_sum(lst):\n    \"\"\"Andika kazi inayokubali orodha ya misemo kama parameta,\n    inafuta misemo yenye urefu wa ajabu kutoka kwayo,\n    na inarudisha orodha iliyopangwa kwa mpangilio uliopangwa,\n    Orodha hiyo ni orodha ya misemo kila wakati na kamwe si safu ya nambari,\n    na inaweza kuwa na nakala rudufu.\n    Mpangilio wa orodha unapaswa kuwa kwa urefu unaopanda wa kila neno, na unapaswa\n    kurudisha orodha iliyopangwa kwa kanuni hiyo.\n    Ikiwa maneno mawili yana urefu sawa, panga orodha kwa alfabeti.\n    Kazi hiyo inapaswa kurudisha orodha ya misemo kwa mpangilio uliopangwa.\n    Unaweza kudhani kuwa maneno yote yatakuwa na urefu sawa.\n    Kwa mfano:\n    assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\n    \"\"\"","canonical_solution":"    lst.sort()\n    new_lst = []\n    for i in lst:\n        if len(i)%2 == 0:\n            new_lst.append(i)\n    return sorted(new_lst, key=len)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"]) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"]) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"]) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"]) == [\"abcd\", \"dcba\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"]) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"]) == []\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc']) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n","entry_point":"sorted_list_sum"}
{"task_id":"HumanEval\/150","prompt":"def x_or_y(n, x, y):\n    \"\"\"Programu rahisi ambayo inapaswa kurejesha thamani ya x ikiwa n ni \n    namba ya msingi na inapaswa kurejesha thamani ya y vinginevyo.\n\n    Mifano:\n    kwa x_or_y(7, 34, 12) == 34\n    kwa x_or_y(15, 8, 5) == 5\n    \n    \"\"\"","canonical_solution":"    if n == 1:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return y\n            break\n    else:\n        return x\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12) == 34\n    assert candidate(15, 8, 5) == 5\n    assert candidate(3, 33, 5212) == 33\n    assert candidate(1259, 3, 52) == 3\n    assert candidate(7919, -1, 12) == -1\n    assert candidate(3609, 1245, 583) == 583\n    assert candidate(91, 56, 129) == 129\n    assert candidate(6, 34, 1234) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0) == 0\n    assert candidate(2, 2, 0) == 2\n\n","entry_point":"x_or_y"}
{"task_id":"HumanEval\/151","prompt":"def double_the_difference(lst):\n    '''\n    Ukizingatia orodha ya nambari, rudisha jumla ya viwango vya mraba wa nambari\n    katika orodha ambazo ni za kipekee. Puuza nambari ambazo ni hasi au siyo integer.\n    \n    double_the_difference([1, 3, 2, 0]) == 1 + 9 + 0 + 0 = 10\n    double_the_difference([-1, -2, 0]) == 0\n    double_the_difference([9, -2]) == 81\n    double_the_difference([0]) == 0  \n    \n    Ikiwa orodha ya maingizo ni tupu, rudisha 0.\n    '''","canonical_solution":"    return sum([i**2 for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([]) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4]) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3]) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30]) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8]) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5]) == 34, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**2 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n\n","entry_point":"double_the_difference"}
{"task_id":"HumanEval\/152","prompt":"def compare(game, guess):\n    \"\"\"Nadhani sote tunakumbuka hisia ile wakati matokeo ya tukio lililosubiriwa kwa muda mrefu\n    hatimaye yanajulikana. Hisia na mawazo uliyonayo wakati huo bila shaka yanastahili\n    kuyanakili na kuyalinganisha.\n    Kazi yako ni kubaini kama mtu amekisia matokeo ya mechi kadhaa kwa usahihi.\n    Unapewa mfululizo wa alama na makisio yenye urefu sawa, ambapo kila kielezo kinaonyesha mechi.\n    Rudi mfululizo wa urefu ule ule kuonyesha ni kwa kiasi gani kila kisio kilikuwa tofauti. Ikiwa wamekisia kwa usahihi,\n    thamani ni 0, na ikiwa sivyo, thamani ni tofauti kamili kati ya kisio na alama.\n    \n    \n    mfano:\n\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2]) -> [0,0,0,0,3,3]\n    compare([0,5,0,0,0,4],[4,1,1,0,0,-2]) -> [4,4,1,0,0,6]\n    \"\"\"","canonical_solution":"    return [abs(x-y) for x,y in zip(game,guess)]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2])==[0,0,0,0,3,3], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3])==[2,4,6], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4])==[2,0,0,1], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"compare"}
{"task_id":"HumanEval\/153","prompt":"def Strongest_Extension(class_name, extensions):\n    \"\"\"Utapewa jina la darasa (string) na orodha ya viendelezi.\n    Viendelezi hivyo vinatumika kupakia madarasa ya ziada kwenye darasa. Nguvu\n    ya kiendelezi inafuata hivi: Wacha CAP iwe idadi ya herufi kubwa katika jina la\n    kiendelezi, na wacha SM iwe idadi ya herufi ndogo katika jina la kiendelezi,\n    nguvu inapewa na uwiano wa CAP - SM. Unapaswa kupata kiendelezi chenye nguvu\n    zaidi na kurudisha string kwa muundo huu: JinaLaDarasa.JinaLaKiendeleziChenyeNguvu.\n    Ikiwa kuna viendelezi viwili au zaidi vyenye nguvu sawa, unapaswa\n    kuchagua kile kinachokuja cha kwanza kwenye orodha.\n    Kwa mfano, ikiwa umepewa \"Slices\" kama darasa na orodha ya\n    viendelezi: ['SErviNGSliCes', 'Cheese', 'StuFfed'] basi unapaswa\n    kurudisha 'Slices.SErviNGSliCes' kwa kuwa 'SErviNGSliCes' ni kiendelezi chenye nguvu\n    zaidi (nguvu yake ni -1).\n    Mfano:\n    kwa Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    \"\"\"","canonical_solution":"    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val:\n            strong = s\n            my_val = val\n\n    ans = class_name + \".\" + strong\n    return ans\n\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'\n    \n","entry_point":"Strongest_Extension"}
{"task_id":"HumanEval\/154","prompt":"def cycpattern_check(a , b):\n    \"\"\"Ukipewa maneno 2. Unahitaji kurudisha True ikiwa neno la pili au mzunguko wowote wa neno hilo ni sehemu ndogo katika neno la kwanza\n    cycpattern_check(\"abcd\",\"abd\") => False\n    cycpattern_check(\"hello\",\"ell\") => True\n    cycpattern_check(\"whassup\",\"psus\") => False\n    cycpattern_check(\"abab\",\"baa\") => True\n    cycpattern_check(\"efef\",\"eeff\") => False\n    cycpattern_check(\"himenss\",\"simen\") => True\n\n    \"\"\"","canonical_solution":"    l = len(b)\n    pat = b + b\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                return True\n    return False\n","test":"def check(candidate):\n\n    # Check some simple cases\n    #assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    #assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert  candidate(\"xyzw\",\"xyw\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\") == True , \"test #5\"\n\n","entry_point":"cycpattern_check"}
{"task_id":"HumanEval\/155","prompt":"def even_odd_count(num):\n    \"\"\"Kwa kutumia namba ya integer. rudi tuple inayokuwa na idadi ya tarakimu za shufwa na witiri mtawalia.\n\n     Mfano:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"","canonical_solution":"    even_count = 0\n    odd_count = 0\n    for i in str(abs(num)):\n        if int(i)%2==0:\n            even_count +=1\n        else:\n            odd_count +=1\n    return (even_count, odd_count)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(7) == (0, 1)\n    assert candidate(-78) == (1, 1)\n    assert candidate(3452) == (2, 2)\n    assert candidate(346211) == (3, 3)\n    assert candidate(-345821) == (3, 3)\n    assert candidate(-2) == (1, 0)\n    assert candidate(-45347) == (2, 3)\n    assert candidate(0) == (1, 0)\n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"even_odd_count"}
{"task_id":"HumanEval\/156","prompt":"def int_to_mini_roman(number):\n    \"\"\"\n    Kwa kutumia namba nzuri ya kijumla, pata sawa na namba yake ya Kirumi kama string,\n    na irudishe ikiwa imeandikwa kwa herufi ndogo.\n    Vizuizi: 1 <= num <= 1000\n\n    Mifano:\n    >>> int_to_mini_roman(19) == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426) == 'cdxxvi'\n    \"\"\"\n","canonical_solution":"    num = [1, 4, 5, 9, 10, 40, 50, 90,  \n           100, 400, 500, 900, 1000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\",  \n           \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"] \n    i = 12\n    res = ''\n    while number: \n        div = number \/\/ num[i] \n        number %= num[i] \n        while div: \n            res += sym[i] \n            div -= 1\n        i -= 1\n    return res.lower()\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(19) == 'xix'\n    assert candidate(152) == 'clii'\n    assert candidate(251) == 'ccli'\n    assert candidate(426) == 'cdxxvi'\n    assert candidate(500) == 'd'\n    assert candidate(1) == 'i'\n    assert candidate(4) == 'iv'\n    assert candidate(43) == 'xliii'\n    assert candidate(90) == 'xc'\n    assert candidate(94) == 'xciv'\n    assert candidate(532) == 'dxxxii'\n    assert candidate(900) == 'cm'\n    assert candidate(994) == 'cmxciv'\n    assert candidate(1000) == 'm'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"int_to_mini_roman"}
{"task_id":"HumanEval\/157","prompt":"def right_angle_triangle(a, b, c):\n    '''\n    Kwa kuzingatia urefu wa pande tatu za pembetatu. Rudi Thibitisha kama pande tatu\n    zinaunda pembetatu yenye pembe kulia, Rudi Uongo vinginevyo.\n    Pembetatu yenye pembe kulia ni pembetatu ambayo pembe moja ni pembe kulia au\n    digrii 90.\n    Mfano:\n    right_angle_triangle(3, 4, 5) == True\n    right_angle_triangle(1, 2, 3) == False\n    '''\n","canonical_solution":"    return a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 4, 5) == True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1, 2, 3) == False\n    assert candidate(10, 6, 8) == True\n    assert candidate(2, 2, 2) == False\n    assert candidate(7, 24, 25) == True\n    assert candidate(10, 5, 7) == False\n    assert candidate(5, 12, 13) == True\n    assert candidate(15, 8, 17) == True\n    assert candidate(48, 55, 73) == True\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1, 1) == False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2, 2, 10) == False\n\n","entry_point":"right_angle_triangle"}
{"task_id":"HumanEval\/158","prompt":"def find_max(words):\n    \"\"\"Andika kazi inayokubali orodha ya misemo.\n    Orodha ina maneno tofauti. Rudisha neno lenye idadi kubwa zaidi\n    ya herufi za kipekee. Ikiwa misemo mingi ina idadi kubwa ya herufi za kipekee,\n    rudisha ile inayokuja kwanza kwa utaratibu wa leksikografia.\n\n    find_max([\"name\", \"of\", \"string\"]) == \"string\"\n    find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n    find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"aaaaaaa\"\n    \"\"\"\n","canonical_solution":"    return sorted(words, key = lambda x: (-len(set(x)), x))[0]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"]) == \"string\"), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"]) == \"enam\"), 't2'\n    assert (candidate([\"aaaaaaa\", \"bb\", \"cc\"]) == \"aaaaaaa\"), 't3'\n    assert (candidate([\"abc\", \"cba\"]) == \"abc\"), 't4'\n    assert (candidate([\"play\", \"this\", \"game\", \"of\",\"footbott\"]) == \"footbott\"), 't5'\n    assert (candidate([\"we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\"), 't6'\n    assert (candidate([\"we\", \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\"), 't7'\n    assert (candidate([\"this\", \"is\", \"a\", \"prrk\"]) == \"this\"), 't8'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert (candidate([\"b\"]) == \"b\"), 't9'\n    assert (candidate([\"play\", \"play\", \"play\"]) == \"play\"), 't10'\n\n","entry_point":"find_max"}
{"task_id":"HumanEval\/159","prompt":"def eat(number, need, remaining):\n    \"\"\"\n    Wewe ni sungura mwenye njaa, na tayari umekula karoti kadhaa,\n    lakini sasa unahitaji kula karoti zaidi ili kukamilisha mlo wa siku.\n    unapaswa kurudisha safu ya [ idadi ya jumla ya karoti ulizokula baada ya milo yako,\n                                    idadi ya karoti zilizobaki baada ya milo yako ]\n    ikiwa hakuna karoti za kutosha zilizobaki, utakula karoti zote zilizobaki, lakini bado utakuwa na njaa.\n    \n    Mfano:\n    * eat(5, 6, 10) -> [11, 4]\n    * eat(4, 8, 9) -> [12, 1]\n    * eat(1, 10, 10) -> [11, 0]\n    * eat(2, 11, 5) -> [7, 0]\n    \n    Vigezo:\n    @number : integer\n        idadi ya karoti ambazo umekula.\n    @need : integer\n        idadi ya karoti ambazo unahitaji kula.\n    @remaining : integer\n        idadi ya karoti zilizobaki ambazo zipo katika akiba\n    \n    Zuia:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Furahia :)\n    \"\"\"","canonical_solution":"    if(need <= remaining):\n        return [ number + need , remaining-need ]\n    else:\n        return [ number + remaining , 0]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10) == [11, 4], \"Error\"\n    assert candidate(4, 8, 9) == [12, 1], \"Error\"\n    assert candidate(1, 10, 10) == [11, 0], \"Error\"\n    assert candidate(2, 11, 5) == [7, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7) == [9, 2], \"Error\"\n    assert candidate(4, 5, 1) == [5, 0], \"Error\"\n\n","entry_point":"eat"}
{"task_id":"HumanEval\/160","prompt":"def do_algebra(operator, operand):\n    \"\"\"\n    Kwa kutumia orodha mbili, operator na operand. Orodha ya kwanza ina operesheni za msingi za aljebra, na \n    orodha ya pili ni orodha ya namba nzima. Tumia orodha hizi mbili kujenga usemi wa aljebra na urudishe \n    matokeo ya usemi huu.\n\n    Operesheni za msingi za aljebra:\n    Jumlisha ( + )\n    Toa ( - )\n    Zidisha ( * )\n    Gawanya kwa sakafu ( \/\/ )\n    Fanya nguvu ( ** )\n\n    Mfano:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    matokeo = 2 + 3 * 4 - 5\n    => matokeo = 9\n\n    Maelezo:\n        Urefu wa orodha ya operator ni sawa na urefu wa orodha ya operand pungufu moja.\n        Operand ni orodha ya namba nzima zisizo na hasi.\n        Orodha ya operator ina angalau operesheni moja, na orodha ya operand ina angalau operendi mbili.\n\n    \"\"\"","canonical_solution":"    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression+= oprt + str(oprn)\n    return eval(expression)\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['\/\/', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"do_algebra"}
{"task_id":"HumanEval\/161","prompt":"def solve(s):\n    \"\"\"Utapewa string s.\n    ikiwa s[i] ni herufi, geuza hali yake kutoka herufi ndogo hadi kubwa au kinyume chake,\n    vinginevyo iache kama ilivyo.\n    Ikiwa string haina herufi, geuza string hiyo.\n    Function inapaswa kurudisha string iliyotokana.\n    Mifano\n    solve(\"1234\") = \"4321\"\n    solve(\"ab\") = \"AB\"\n    solve(\"#a@C\") = \"#A@c\"\n    \"\"\"\n","canonical_solution":"    flg = 0\n    idx = 0\n    new_str = list(s)\n    for i in s:\n        if i.isalpha():\n            new_str[idx] = i.swapcase()\n            flg = 1\n        idx += 1\n    s = \"\"\n    for i in new_str:\n        s += i\n    if flg == 0:\n        return s[len(s)::-1]\n    return s\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"AsDf\") == \"aSdF\"\n    assert candidate(\"1234\") == \"4321\"\n    assert candidate(\"ab\") == \"AB\"\n    assert candidate(\"#a@C\") == \"#A@c\"\n    assert candidate(\"#AsdfW^45\") == \"#aSDFw^45\"\n    assert candidate(\"#6@2\") == \"2@6#\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"#$a^D\") == \"#$A^d\"\n    assert candidate(\"#ccc\") == \"#CCC\"\n\n    # Don't remove this line:\n","entry_point":"solve"}
{"task_id":"HumanEval\/162","prompt":"def string_to_md5(text):\n    \"\"\"\n    Ukizingatia string 'text', rudi string sawa na hash ya md5.\n    Ikiwa 'text' ni string tupu, rudi None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n","canonical_solution":"    import hashlib\n    return hashlib.md5(text.encode('ascii')).hexdigest() if text else None\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    assert candidate('') == None\n    assert candidate('A B C') == '0ef78513b0cb8cef12743f5aeb35f888'\n    assert candidate('password') == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n","entry_point":"string_to_md5"}
{"task_id":"HumanEval\/163","prompt":"def generate_integers(a, b):\n    \"\"\"\n    Ukipewa namba mbili chanya a na b, rudi tarakimu zote shufwa zilizopo kati ya a\n    na b, kwa mpangilio unaopanda.\n\n    Kwa mfano:\n    generate_integers(2, 8) => [2, 4, 6, 8]\n    generate_integers(8, 2) => [2, 4, 6, 8]\n    generate_integers(10, 14) => []\n    \"\"\"\n","canonical_solution":"    lower = max(2, min(a, b))\n    upper = min(8, max(a, b))\n\n    return [i for i in range(lower, upper+1) if i % 2 == 0]\n","test":"def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10) == [2, 4, 6, 8], \"Test 1\"\n    assert candidate(10, 2) == [2, 4, 6, 8], \"Test 2\"\n    assert candidate(132, 2) == [2, 4, 6, 8], \"Test 3\"\n    assert candidate(17,89) == [], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n","entry_point":"generate_integers"}
